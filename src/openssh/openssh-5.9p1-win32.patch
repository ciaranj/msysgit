diff --git a/Makefile.in b/Makefile.in
index 3be3aa6..2bb1ae0 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -55,7 +55,7 @@ PERL=@PERL@
 SED=@SED@
 ENT=@ENT@
 XAUTH_PATH=@XAUTH_PATH@
-LDFLAGS=-L. -Lopenbsd-compat/ @LDFLAGS@
+LDFLAGS=-L. -Lopenbsd-compat/ -Lcontrib/win32/win32compat @LDFLAGS@
 EXEEXT=@EXEEXT@
 MANFMT=@MANFMT@
 
@@ -128,6 +128,10 @@ $(SSHDOBJS): Makefile.in config.h
 .c.o:
 	$(CC) $(CFLAGS) $(CPPFLAGS) -c $<
 
+LIBWIN32COMPAT=contrib/win32/win32compat/@LIBWIN32COMPAT@
+$(LIBWIN32COMPAT): always
+	(cd contrib/win32/win32compat && $(MAKE))
+
 LIBCOMPAT=openbsd-compat/libopenbsd-compat.a
 $(LIBCOMPAT): always
 	(cd openbsd-compat && $(MAKE))
@@ -137,42 +141,42 @@ libssh.a: $(LIBSSH_OBJS)
 	$(AR) rv $@ $(LIBSSH_OBJS)
 	$(RANLIB) $@
 
-ssh$(EXEEXT): $(LIBCOMPAT) libssh.a $(SSHOBJS)
-	$(LD) -o $@ $(SSHOBJS) $(LDFLAGS) -lssh -lopenbsd-compat $(SSHLIBS) $(LIBS)
+ssh$(EXEEXT): $(LIBCOMPAT) libssh.a @LIBWIN32COMPATDEPEND@ $(SSHOBJS)
+	$(LD) -o $@ $(SSHOBJS) $(LDFLAGS) -lssh -lopenbsd-compat $(SSHLIBS) @LINKWIN32COMPAT@ $(LIBS)
 
-sshd$(EXEEXT): libssh.a	$(LIBCOMPAT) $(SSHDOBJS)
-	$(LD) -o $@ $(SSHDOBJS) $(LDFLAGS) -lssh -lopenbsd-compat $(SSHDLIBS) $(LIBS)
+sshd$(EXEEXT): libssh.a @LIBWIN32COMPATDEPEND@ $(LIBCOMPAT) $(SSHDOBJS)
+	$(LD) -o $@ $(SSHDOBJS) $(LDFLAGS) -lssh -lopenbsd-compat @LINKWIN32COMPAT@ $(SSHDLIBS) $(LIBS)
 
-scp$(EXEEXT): $(LIBCOMPAT) libssh.a scp.o progressmeter.o
-	$(LD) -o $@ scp.o progressmeter.o bufaux.o $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS)
+scp$(EXEEXT): $(LIBCOMPAT) libssh.a scp.o progressmeter.o @LIBWIN32COMPATDEPEND@
+	$(LD) -o $@ scp.o progressmeter.o bufaux.o $(LDFLAGS) -lssh -lopenbsd-compat @LINKWIN32COMPAT@ $(LIBS)
 
-ssh-add$(EXEEXT): $(LIBCOMPAT) libssh.a ssh-add.o
-	$(LD) -o $@ ssh-add.o $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS)
+ssh-add$(EXEEXT): $(LIBCOMPAT) libssh.a ssh-add.o @LIBWIN32COMPATDEPEND@
+	$(LD) -o $@ ssh-add.o $(LDFLAGS) -lssh -lopenbsd-compat @LINKWIN32COMPAT@ $(LIBS)
 
-ssh-agent$(EXEEXT): $(LIBCOMPAT) libssh.a ssh-agent.o ssh-pkcs11-client.o
-	$(LD) -o $@ ssh-agent.o ssh-pkcs11-client.o $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS)
+ssh-agent$(EXEEXT): $(LIBCOMPAT) libssh.a ssh-agent.o ssh-pkcs11-client.o @LIBWIN32COMPATDEPEND@
+	$(LD) -o $@ ssh-agent.o ssh-pkcs11-client.o $(LDFLAGS) -lssh -lopenbsd-compat @LINKWIN32COMPAT@ $(LIBS)
 
-ssh-keygen$(EXEEXT): $(LIBCOMPAT) libssh.a ssh-keygen.o
-	$(LD) -o $@ ssh-keygen.o $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS)
+ssh-keygen$(EXEEXT): $(LIBCOMPAT) libssh.a ssh-keygen.o @LIBWIN32COMPATDEPEND@
+	$(LD) -o $@ ssh-keygen.o $(LDFLAGS) -lssh -lopenbsd-compat @LINKWIN32COMPAT@ $(LIBS)
 
-ssh-keysign$(EXEEXT): $(LIBCOMPAT) libssh.a ssh-keysign.o roaming_dummy.o readconf.o
-	$(LD) -o $@ ssh-keysign.o readconf.o roaming_dummy.o $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS)
+ssh-keysign$(EXEEXT): $(LIBCOMPAT) libssh.a ssh-keysign.o roaming_dummy.o readconf.o @LIBWIN32COMPATDEPEND@
+	$(LD) -o $@ ssh-keysign.o readconf.o roaming_dummy.o $(LDFLAGS) -lssh -lopenbsd-compat @LINKWIN32COMPAT@ $(LIBS)
 
-ssh-pkcs11-helper$(EXEEXT): $(LIBCOMPAT) libssh.a ssh-pkcs11-helper.o ssh-pkcs11.o
-	$(LD) -o $@ ssh-pkcs11-helper.o ssh-pkcs11.o $(LDFLAGS) -lssh -lopenbsd-compat -lssh -lopenbsd-compat $(LIBS)
+ssh-pkcs11-helper$(EXEEXT): $(LIBCOMPAT) libssh.a ssh-pkcs11-helper.o ssh-pkcs11.o @LIBWIN32COMPATDEPEND@
+	$(LD) -o $@ ssh-pkcs11-helper.o ssh-pkcs11.o $(LDFLAGS) -lssh -lopenbsd-compat -lssh -lopenbsd-compat @LINKWIN32COMPAT@ $(LIBS)
 
-ssh-keyscan$(EXEEXT): $(LIBCOMPAT) libssh.a ssh-keyscan.o roaming_dummy.o
-	$(LD) -o $@ ssh-keyscan.o roaming_dummy.o $(LDFLAGS) -lssh -lopenbsd-compat -lssh $(LIBS)
+ssh-keyscan$(EXEEXT): $(LIBCOMPAT) libssh.a ssh-keyscan.o roaming_dummy.o @LIBWIN32COMPATDEPEND@
+	$(LD) -o $@ ssh-keyscan.o roaming_dummy.o $(LDFLAGS) -lssh -lopenbsd-compat -lssh @LINKWIN32COMPAT@ $(LIBS)
 
-sftp-server$(EXEEXT): $(LIBCOMPAT) libssh.a sftp.o sftp-common.o sftp-server.o sftp-server-main.o
-	$(LD) -o $@ sftp-server.o sftp-common.o sftp-server-main.o $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS)
+sftp-server$(EXEEXT): $(LIBCOMPAT) libssh.a sftp.o sftp-common.o sftp-server.o sftp-server-main.o @LIBWIN32COMPATDEPEND@
+	$(LD) -o $@ sftp-server.o sftp-common.o sftp-server-main.o $(LDFLAGS) -lssh -lopenbsd-compat @LINKWIN32COMPAT@ $(LIBS)
 
-sftp$(EXEEXT): $(LIBCOMPAT) libssh.a sftp.o sftp-client.o sftp-common.o sftp-glob.o progressmeter.o
-	$(LD) -o $@ progressmeter.o sftp.o sftp-client.o sftp-common.o sftp-glob.o $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS) $(LIBEDIT)
+sftp$(EXEEXT): $(LIBCOMPAT) libssh.a sftp.o sftp-client.o sftp-common.o sftp-glob.o progressmeter.o @LIBWIN32COMPATDEPEND@
+	$(LD) -o $@ progressmeter.o sftp.o sftp-client.o sftp-common.o sftp-glob.o $(LDFLAGS) -lssh -lopenbsd-compat @LINKWIN32COMPAT@ $(LIBS) $(LIBEDIT)
 
 # test driver for the loginrec code - not built by default
-logintest: logintest.o $(LIBCOMPAT) libssh.a loginrec.o
-	$(LD) -o $@ logintest.o $(LDFLAGS) loginrec.o -lopenbsd-compat -lssh $(LIBS)
+logintest: logintest.o $(LIBCOMPAT) libssh.a loginrec.o @LIBWIN32COMPATDEPEND@
+	$(LD) -o $@ logintest.o $(LDFLAGS) loginrec.o -lopenbsd-compat -lssh @LINKWIN32COMPAT@ $(LIBS)
 
 $(MANPAGES): $(MANPAGES_IN)
 	if test "$(MANTYPE)" = "cat"; then \
@@ -198,14 +202,20 @@ clean:	regressclean
 	rm -f *.o *.a $(TARGETS) logintest config.cache config.log
 	rm -f *.out core survey
 	(cd openbsd-compat && $(MAKE) clean)
+	if test -f contrib/win32/win32compat/Makefile ; then \
+		(cd contrib/win32/win32compat && $(MAKE) clean) \
+	fi
 
 distclean:	regressclean
 	rm -f *.o *.a $(TARGETS) logintest config.cache config.log
 	rm -f *.out core opensshd.init openssh.xml
 	rm -f Makefile buildpkg.sh config.h config.status
-	rm -f survey.sh openbsd-compat/regress/Makefile *~ 
+	rm -f survey.sh openbsd-compat/regress/Makefile *~
 	rm -rf autom4te.cache
 	(cd openbsd-compat && $(MAKE) distclean)
+	if test -f contrib/win32/win32compat/Makefile ; then \
+		(cd contrib/win32/win32compat && $(MAKE) distclean) \
+	fi
 	if test -d pkg ; then \
 		rm -fr pkg ; \
 	fi
@@ -439,4 +449,3 @@ package: $(CONFIGFILES) $(MANPAGES) $(TARGETS)
 	if [ "@MAKE_PACKAGE_SUPPORTED@" = yes ]; then \
 		sh buildpkg.sh; \
 	fi
-
diff --git a/README.win32 b/README.win32
new file mode 100644
index 0000000..affa817
--- /dev/null
+++ b/README.win32
@@ -0,0 +1,115 @@
+README.win32
+
+openssh-5.9p1-win32
+
+- Updated to OpenSSH version 5.9p1.
+
+- The openSSH SFTP client has been ported to Win 32.
+
+openssh-4.7p1-win32-1
+
+- The following tools have been ported to Win32: ssh-agent, ssh-add,
+  sftp-server program and ssh-keygen. All the basic functionalities
+  related to the creation of the key-pairs are fully supported. The
+  managing of the known_hosts file is missing.
+
+- Added support to SSH client for MIT Kerberos for Windows and for
+  authorization based on smartcard devices.
+
+- Updated SSH server to support login also when the account doesn't
+  have administrative privileges.
+
+- Added support for native RSA/DSA key authorization via nxlsa, a new
+  NX tool. Installing this tool requires administrative privileges and
+  a reboot of the machine.
+
+- The ProxyCommand option is now supported on Win32.
+
+- Added support for installing SSHD as a service by means of sc.exe
+  command line tool for Windows. Since command line parameters are not
+  passed to the SSHD process, a default sshd_config file is searched
+  in the following locations: in the installation directory where
+  sshd.exe is located (e.g. C:\sshd); the directory 'etc' under
+  the installation directory (e.g. C:\sshd\etc), and the directory 'etc'  
+  in the installation directory (e.g C:\etc).
+
+- Improved SSH server to be fully operative on Windows Vista. SSHD can
+  work on Windows XP without SP1.
+
+- Improved logging facilities of SSHD: now all instances of the SSH
+  server log to the same file and SSHD creates a minidump file if a
+  crash occurs.
+
+- Solved problem with processes that may be left running when the SSHD
+  service is stopped or after an abnormal closure of the SSH session.
+
+- Fixed some memory leaks.
+
+- Fixed possible crashes of SSHD when a great number of connections is
+  established.
+
+- Fixed possible hanging of the SSHD service that may occurr when the
+  SSH session is closing and when reading a passphrase.
+
+- Fixed logging behavior of SSH client. Now when the client is run in
+  debug mode, output of packet dumps can be redirected to a file.
+  Solved other issues occurring when packet dumps when standard error
+  is redirected.
+
+- Fixed a problem related to the inheritance of handles in SSHD.
+
+- Fixed a bug in the session_get() function causing a segmentation
+  fault of SSHD.
+
+- Fixed the closure of startup pipes. This solves a problem which was
+  limiting the number of sessions to 10.
+
+- Fixed a problem causing a delay in establishing the connection when
+  SSHD is started as a Win32 service. Speeded-up login.
+
+- Disabled the privilege separation on Win32.
+
+- Solved issues preventing the correct detection of home directory
+  either on Windows 7 and when the user domain is set to NULL.
+
+- Fixed a segmentation fault of SSHD on Windows 7 at 64bit.
+
+- Added the setting of the USERPROFILE variable to the value detected
+  just after a successful login.
+
+openssh-5.4p1-win32
+
+- Updated to OpenSSH version 5.4p1.
+
+openssh-4.7p1-win32
+
+- Added the Win32 compat layer.
+
+- The Win32 layer provides support for: User identity and password
+  management functions like getuid(),setuid(),getpw*() and others;
+  string management functions like strcasecmp(), strncasecmp() and
+  other functions such as gettimeofday() and gethomedir(); management
+  of file descriptors, file handlers and sockets in an unified way;
+  file descriptor and sockets functions such as fstat(), fdopen(),
+  open(), dup(),dup2(), pipe(),create(),shutdown(),accept(),read(),
+  write(),close(), socket(), setsockopt(),getsockopt(), getpeername(),
+  getsockname(), ioctlsocket(), listen(),bind(),connect(), and others;
+  the select() function which can work on sockets, files, pipes and
+  console handlers; Windows users authentication.
+
+- Introduced some changes to the OpenSSH code for: supporting the
+  CreateProcess() function replacing fork() and allowing compilation
+  on Win32 platform.
+
+- Open Issues: SSHD cannot be installed as a Windows service by means
+  of Win32 administrative tools; if SSHD is running as a Windows
+  service, it requires that property 'Allow service to interact with
+  desktop' is set; to allow the connecting user to be authenticated by
+  SSHD, it is necessary that the user belongs to the 'Administrators'
+  group; if the connecting user has been authorized with public key
+  authentication, the GetUserName() function always returns 'SYSTEM'
+  instead of the username; possible crashes may occur during autho-
+  rization phase when SSHD is running on Vista; port of the ssh-keygen
+  tool is not available in this version.
+
+
diff --git a/audit.c b/audit.c
index ced57fa..c2b9bb0 100644
--- a/audit.c
+++ b/audit.c
@@ -26,6 +26,15 @@
 
 #include "includes.h"
 
+/*
+ * We support only client side kerberos on Windows.
+ */
+
+#ifdef NX_WIN32_FIXME
+  #undef GSSAPI
+  #undef KRB5
+#endif
+
 #include <stdarg.h>
 #include <string.h>
 
diff --git a/auth-bsdauth.c b/auth-bsdauth.c
index 0b3262b..e634480 100644
--- a/auth-bsdauth.c
+++ b/auth-bsdauth.c
@@ -25,6 +25,15 @@
 
 #include "includes.h"
 
+/*
+ * We support only client side kerberos on Windows.
+ */
+
+#ifdef NX_WIN32_FIXME
+  #undef GSSAPI
+  #undef KRB5
+#endif
+
 #include <sys/types.h>
 
 #include <stdarg.h>
diff --git a/auth-krb5.c b/auth-krb5.c
index d019fe2..b23eaca 100644
--- a/auth-krb5.c
+++ b/auth-krb5.c
@@ -30,6 +30,15 @@
 
 #include "includes.h"
 
+/*
+ * We support only client side kerberos on Windows.
+ */
+
+#ifdef NX_WIN32_FIXME
+  #undef GSSAPI
+  #undef KRB5
+#endif
+
 #include <sys/types.h>
 #include <pwd.h>
 #include <stdarg.h>
diff --git a/auth-options.c b/auth-options.c
index eae45cf..13d72ef 100644
--- a/auth-options.c
+++ b/auth-options.c
@@ -12,6 +12,15 @@
 
 #include "includes.h"
 
+/*
+ * We support only client side kerberos on Windows.
+ */
+
+#ifdef NX_WIN32_FIXME
+  #undef GSSAPI
+  #undef KRB5
+#endif
+
 #include <sys/types.h>
 
 #include <netdb.h>
@@ -646,4 +655,3 @@ auth_cert_options(Key *k, struct passwd *pw)
 	}
 	return 0;
 }
-
diff --git a/auth-pam.c b/auth-pam.c
index 675006e..e6c9f9e 100644
--- a/auth-pam.c
+++ b/auth-pam.c
@@ -48,6 +48,15 @@
 /* Based on $FreeBSD: src/crypto/openssh/auth2-pam-freebsd.c,v 1.11 2003/03/31 13:48:18 des Exp $ */
 #include "includes.h"
 
+/*
+ * We support only client side kerberos on Windows.
+ */
+
+#ifdef NX_WIN32_FIXME
+  #undef GSSAPI
+  #undef KRB5
+#endif
+
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/wait.h>
diff --git a/auth-passwd.c b/auth-passwd.c
index b1c6ce0..04e3483 100644
--- a/auth-passwd.c
+++ b/auth-passwd.c
@@ -38,6 +38,15 @@
 
 #include "includes.h"
 
+/*
+ * We support only client side kerberos on Windows.
+ */
+
+#ifdef NX_WIN32_FIXME
+  #undef GSSAPI
+  #undef KRB5
+#endif
+
 #include <sys/types.h>
 
 #include <pwd.h>
@@ -187,6 +196,61 @@ sys_auth_passwd(Authctxt *authctxt, const char *password)
 		return (auth_close(as));
 	}
 }
+#elif defined(NX_WIN32_FIXME)
+int sys_auth_passwd(Authctxt *authctxt, const char *password)
+{
+  /* 
+   * Authenticate on Windows 
+   */
+   
+  struct passwd *pw = authctxt -> pw;
+
+  HANDLE hToken = INVALID_HANDLE_VALUE;
+  
+  BOOL worked;
+
+  authctxt -> methoddata = hToken;
+
+  /*
+   * Check the password for the user 
+   */
+  
+  worked = LogonUser(authctxt->user, ".", password,
+                         LOGON32_LOGON_INTERACTIVE, 
+                             LOGON32_PROVIDER_DEFAULT, &hToken);
+                             
+  if (!worked || hToken == INVALID_HANDLE_VALUE)
+  {
+    return 0;
+  }
+
+  /*
+   * Make sure this can be inherited for when 
+   * we start shells or commands.
+   */
+   
+  worked = SetHandleInformation(hToken, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT);
+  
+  if (!worked)
+  {
+    CloseHandle(hToken);
+    
+    hToken = INVALID_HANDLE_VALUE;
+    
+    authctxt -> methoddata = hToken;
+
+    return 0;
+  }
+
+  /*
+   * Save the handle (or invalid handle) as method-specific data.
+   */
+   
+  authctxt -> methoddata = hToken;
+
+  return 1;
+}
+
 #elif !defined(CUSTOM_SYS_AUTH_PASSWD)
 int
 sys_auth_passwd(Authctxt *authctxt, const char *password)
diff --git a/auth-rh-rsa.c b/auth-rh-rsa.c
index b21a0f4..f588d0a 100644
--- a/auth-rh-rsa.c
+++ b/auth-rh-rsa.c
@@ -15,6 +15,15 @@
 
 #include "includes.h"
 
+/*
+ * We support only client side kerberos on Windows.
+ */
+
+#ifdef NX_WIN32_FIXME
+  #undef GSSAPI
+  #undef KRB5
+#endif
+
 #include <sys/types.h>
 
 #include <pwd.h>
diff --git a/auth-rhosts.c b/auth-rhosts.c
index 06ae7f0..87313bc 100644
--- a/auth-rhosts.c
+++ b/auth-rhosts.c
@@ -56,6 +56,7 @@ check_rhosts_file(const char *filename, const char *hostname,
 		  const char *ipaddr, const char *client_user,
 		  const char *server_user)
 {
+#ifndef NX_WIN32_FIXME
 	FILE *f;
 	char buf[1024];	/* Must not be larger than host, user, dummy below. */
 	int fd;
@@ -175,6 +176,9 @@ check_rhosts_file(const char *filename, const char *hostname,
 	/* Authentication using this file denied. */
 	fclose(f);
 	return 0;
+#else
+  return 1;
+#endif
 }
 
 /*
diff --git a/auth-rsa.c b/auth-rsa.c
index 4ab46cd..0157b93 100644
--- a/auth-rsa.c
+++ b/auth-rsa.c
@@ -16,6 +16,15 @@
 
 #include "includes.h"
 
+/*
+ * We support only client side kerberos on Windows.
+ */
+
+#ifdef NX_WIN32_FIXME
+  #undef GSSAPI
+  #undef KRB5
+#endif
+
 #include <sys/types.h>
 #include <sys/stat.h>
 
diff --git a/auth.c b/auth.c
index cd95da9..4d40877 100644
--- a/auth.c
+++ b/auth.c
@@ -25,6 +25,15 @@
 
 #include "includes.h"
 
+/*
+ * We support only client side kerberos on Windows.
+ */
+
+#ifdef NX_WIN32_FIXME
+  #undef GSSAPI
+  #undef KRB5
+#endif
+
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/param.h>
@@ -167,6 +176,7 @@ allowed_user(struct passwd * pw)
 			xfree(shell);
 			return 0;
 		}
+#ifndef NX_WIN32_FIXME
 		if (S_ISREG(st.st_mode) == 0 ||
 		    (st.st_mode & (S_IXOTH|S_IXUSR|S_IXGRP)) == 0) {
 			logit("User %.100s not allowed because shell %.100s "
@@ -174,6 +184,7 @@ allowed_user(struct passwd * pw)
 			xfree(shell);
 			return 0;
 		}
+#endif
 		xfree(shell);
 	}
 
@@ -425,6 +436,7 @@ static int
 secure_filename(FILE *f, const char *file, struct passwd *pw,
     char *err, size_t errlen)
 {
+#ifndef NX_WIN32_FIXME
 	uid_t uid = pw->pw_uid;
 	char buf[MAXPATHLEN], homedir[MAXPATHLEN];
 	char *cp;
@@ -476,6 +488,9 @@ secure_filename(FILE *f, const char *file, struct passwd *pw,
 			break;
 	}
 	return 0;
+#else
+  return 0;
+#endif  
 }
 
 static FILE *
diff --git a/auth.h b/auth.h
index 0d786c4..3ea65b2 100644
--- a/auth.h
+++ b/auth.h
@@ -38,8 +38,20 @@
 #ifdef BSD_AUTH
 #include <bsd_auth.h>
 #endif
+
+#ifdef NX_WIN32_FIXME
+
+  #include <windows.h>
+
+  #ifdef KRB5
+  # include <kfwfix.h>
+  # include <krb5.h>
+  #endif
+
+#endif  
+
 #ifdef KRB5
-#include <krb5.h>
+# include <krb5.h>
 #endif
 
 typedef struct Authctxt Authctxt;
@@ -73,6 +85,12 @@ struct Authctxt {
 #endif
 	Buffer		*loginmsg;
 	void		*methoddata;
+
+  #ifdef NX_WIN32_FIXME
+
+    HANDLE hTokenLsa_;
+
+  #endif
 };
 /*
  * Every authentication method has to handle authentication requests for
diff --git a/auth1.c b/auth1.c
index cc85aec..aefffcb 100644
--- a/auth1.c
+++ b/auth1.c
@@ -12,6 +12,15 @@
 
 #include "includes.h"
 
+/*
+ * We support only client side kerberos on Windows.
+ */
+
+#ifdef NX_WIN32_FIXME
+  #undef GSSAPI
+  #undef KRB5
+#endif
+
 #include <sys/types.h>
 
 #include <stdarg.h>
diff --git a/auth2-gss.c b/auth2-gss.c
index 0d59b21..013ff84 100644
--- a/auth2-gss.c
+++ b/auth2-gss.c
@@ -26,6 +26,15 @@
 
 #include "includes.h"
 
+/*
+ * We support only client side kerberos on Windows.
+ */
+
+#ifdef NX_WIN32_FIXME
+  #undef GSSAPI
+  #undef KRB5
+#endif
+
 #ifdef GSSAPI
 
 #include <sys/types.h>
diff --git a/auth2-hostbased.c b/auth2-hostbased.c
index cdf442f..2262668 100644
--- a/auth2-hostbased.c
+++ b/auth2-hostbased.c
@@ -25,6 +25,15 @@
 
 #include "includes.h"
 
+/*
+ * We support only client side kerberos on Windows.
+ */
+
+#ifdef NX_WIN32_FIXME
+  #undef GSSAPI
+  #undef KRB5
+#endif
+
 #include <sys/types.h>
 
 #include <pwd.h>
diff --git a/auth2-none.c b/auth2-none.c
index c8c6c74..bde804a 100644
--- a/auth2-none.c
+++ b/auth2-none.c
@@ -25,6 +25,15 @@
 
 #include "includes.h"
 
+/*
+ * We support only client side kerberos on Windows.
+ */
+
+#ifdef NX_WIN32_FIXME
+  #undef GSSAPI
+  #undef KRB5
+#endif
+
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/uio.h>
diff --git a/auth2-pubkey.c b/auth2-pubkey.c
index 137887e..ef59906 100644
--- a/auth2-pubkey.c
+++ b/auth2-pubkey.c
@@ -64,9 +64,21 @@ extern ServerOptions options;
 extern u_char *session_id2;
 extern u_int session_id2_len;
 
+#ifdef NX_WIN32_FIXME
+  
+  extern char HomeDirLsa[MAX_PATH];
+  
+#endif
+
 static int
 userauth_pubkey(Authctxt *authctxt)
 {
+  #ifdef NX_WIN32_FIXME
+  
+  int loginStat = 1;
+  
+  #endif
+
 	Buffer b;
 	Key *key = NULL;
 	char *pkalg;
@@ -139,10 +151,88 @@ userauth_pubkey(Authctxt *authctxt)
 #endif
 		/* test for correct signature */
 		authenticated = 0;
+
+    /*
+     * On pure win32 try to logon using nxlsa first.
+     */
+
+    #ifdef NX_WIN32_FIXME
+
+    authctxt -> methoddata = NULL;
+    
+    authctxt -> hTokenLsa_ = NULL;
+  
+    loginStat = LsaLogon(&authctxt -> hTokenLsa_, HomeDirLsa,
+                             authctxt -> user, pkblob, blen, sig, slen,
+                                 buffer_ptr(&b), buffer_len(&b), datafellows);
+
+    /*
+     * If lsa logon process success.
+     */
+  
+    if (loginStat == 0)
+    {
+      /*
+       * And user authorized OK.
+       */
+    
+      if (authctxt -> hTokenLsa_)
+      {
+        /*
+         * This is part of openssh authorization needed for parsing
+         * 'options' block in key.
+         */
+      
+        authctxt -> pw -> pw_dir = GetHomeDir(authctxt -> user);
+      
+        if (PRIVSEP(user_key_allowed(authctxt -> pw, key)))
+        {
+          authenticated = 1;
+        }
+        else
+        {
+          authenticated = 0;
+        }
+          
+        buffer_free(&b);
+
+        xfree(sig);
+      }
+    }
+
+    #ifdef NX_USE_NTCREATETOKEN
+
+    else
+    {
+      /*
+       * If lsa fails, test for correct signature using openssh code.
+       */
+
+      authctxt -> pw -> pw_dir = GetHomeDir(authctxt -> user);
+    
+      if (PRIVSEP(user_key_allowed(authctxt->pw, key)) &&
+              PRIVSEP(key_verify(key, sig, slen, buffer_ptr(&b), buffer_len(&b))) == 1)
+    
+      {
+        authenticated = 1;
+      }
+    }
+    
+    #endif /* #ifdef NX_USE_NTCREATETOKEN */
+    
+    /*
+     * Original code.
+     */
+
+    #else /* #ifdef NX_WIN32_FIXME */
+
 		if (PRIVSEP(user_key_allowed(authctxt->pw, key)) &&
 		    PRIVSEP(key_verify(key, sig, slen, buffer_ptr(&b),
 		    buffer_len(&b))) == 1)
 			authenticated = 1;
+
+    #endif /* else #ifdef NX_WIN32_FIXME. */
+
 		buffer_free(&b);
 		xfree(sig);
 	} else {
@@ -157,7 +247,14 @@ userauth_pubkey(Authctxt *authctxt)
 		 * if a user is not allowed to login. is this an
 		 * issue? -markus
 		 */
-		if (PRIVSEP(user_key_allowed(authctxt->pw, key))) {
+
+      #ifndef NX_WIN32_FIXME
+
+      if (PRIVSEP(user_key_allowed(authctxt -> pw, key))) 
+ 
+      #endif
+  
+			{
 			packet_start(SSH2_MSG_USERAUTH_PK_OK);
 			packet_put_string(pkalg, alen);
 			packet_put_string(pkblob, blen);
diff --git a/auth2.c b/auth2.c
index c06c95f..d976852 100644
--- a/auth2.c
+++ b/auth2.c
@@ -25,6 +25,15 @@
 
 #include "includes.h"
 
+/*
+ * We support only client side kerberos on Windows.
+ */
+
+#ifdef NX_WIN32_FIXME
+  #undef GSSAPI
+  #undef KRB5
+#endif
+
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/uio.h>
@@ -406,4 +415,3 @@ authmethod_lookup(const char *name)
 	    name ? name : "NULL");
 	return NULL;
 }
-
diff --git a/authfd.c b/authfd.c
index f037e83..da06e38 100644
--- a/authfd.c
+++ b/authfd.c
@@ -110,11 +110,14 @@ ssh_get_authentication_socket(void)
 	if (sock < 0)
 		return -1;
 
+#ifndef NX_WIN32_FIXME
 	/* close on exec */
 	if (fcntl(sock, F_SETFD, FD_CLOEXEC) == -1) {
 		close(sock);
 		return -1;
 	}
+#endif /* #ifndef NX_WIN32_FIXME */
+
 	if (connect(sock, (struct sockaddr *)&sunaddr, sizeof sunaddr) < 0) {
 		close(sock);
 		return -1;
diff --git a/authfile.c b/authfile.c
index 1d7e53c..7ad24b6 100644
--- a/authfile.c
+++ b/authfile.c
@@ -219,7 +219,6 @@ static int
 key_save_private_blob(Buffer *keybuf, const char *filename)
 {
 	int fd;
-
 	if ((fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0600)) < 0) {
 		error("open %s failed: %s.", filename, strerror(errno));
 		return 0;
@@ -360,6 +359,7 @@ key_load_file(int fd, const char *filename, Buffer *blob)
 		}
 	}
 	bzero(buf, sizeof(buf));
+#ifndef NX_WIN32_FIXME
 	if ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&
 	    st.st_size != buffer_len(blob)) {
 		debug("%s: key file %.200s%schanged size while reading",
@@ -368,6 +368,7 @@ key_load_file(int fd, const char *filename, Buffer *blob)
 		buffer_clear(blob);
 		return 0;
 	}
+#endif
 
 	return 1;
 }
@@ -624,6 +625,7 @@ key_perm_ok(int fd, const char *filename)
 #ifdef HAVE_CYGWIN
 	if (check_ntsec(filename))
 #endif
+#ifndef NX_WIN32_FIXME
 	if ((st.st_uid == getuid()) && (st.st_mode & 077) != 0) {
 		error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
 		error("@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @");
@@ -634,6 +636,7 @@ key_perm_ok(int fd, const char *filename)
 		error("This private key will be ignored.");
 		return 0;
 	}
+#endif /* ifndef NX_WIN32_FIXME */
 	return 1;
 }
 
@@ -725,7 +728,12 @@ key_load_private(const char *filename, const char *passphrase,
 	Buffer buffer;
 	int fd;
 
+#ifdef NX_WIN32_FIXME
+	fd = open(filename, O_RDONLY | O_BINARY);
+#else
 	fd = open(filename, O_RDONLY);
+#endif
+
 	if (fd < 0) {
 		debug("could not open key file '%s': %s", filename,
 		    strerror(errno));
@@ -943,4 +951,3 @@ key_in_file(Key *key, const char *filename, int strict_type)
 	fclose(f);
 	return ret;
 }
-
diff --git a/channels.c b/channels.c
index 24d4a9f..844d69a 100644
--- a/channels.c
+++ b/channels.c
@@ -78,6 +78,11 @@
 #include "authfd.h"
 #include "pathnames.h"
 
+/* NX */
+#ifdef NX_WIN32_FIXME
+#define isatty(a) WSHELPisatty(a)
+#endif
+
 /* -- channel core */
 
 /*
@@ -229,12 +234,14 @@ channel_register_fds(Channel *c, int rfd, int wfd, int efd,
 	channel_max_fd = MAX(channel_max_fd, wfd);
 	channel_max_fd = MAX(channel_max_fd, efd);
 
+#ifndef NX_WIN32_FIXME
 	if (rfd != -1)
 		fcntl(rfd, F_SETFD, FD_CLOEXEC);
 	if (wfd != -1 && wfd != rfd)
 		fcntl(wfd, F_SETFD, FD_CLOEXEC);
 	if (efd != -1 && efd != rfd && efd != wfd)
 		fcntl(efd, F_SETFD, FD_CLOEXEC);
+#endif
 
 	c->rfd = rfd;
 	c->wfd = wfd;
@@ -1705,6 +1712,7 @@ channel_handle_wfd(Channel *c, fd_set *readset, fd_set *writeset)
 			}
 			return -1;
 		}
+#ifndef NX_WIN32_FIXME
 #ifndef BROKEN_TCGETATTR_ICANON
 		if (compat20 && c->isatty && dlen >= 1 && buf[0] != '\r') {
 			if (tcgetattr(c->wfd, &tio) == 0 &&
@@ -1720,6 +1728,7 @@ channel_handle_wfd(Channel *c, fd_set *readset, fd_set *writeset)
 			}
 		}
 #endif
+#endif
 		buffer_consume(&c->output, len);
 	}
  out:
@@ -2096,6 +2105,12 @@ channel_prepare_select(fd_set **readsetp, fd_set **writesetp, int *maxfdp,
 
 	n = MAX(*maxfdp, channel_max_fd);
 
+  /*
+   * Winsock can't support this sort of fdset reallocation 
+   */
+   
+  #ifndef NX_WIN32_FIXME
+
 	nfdset = howmany(n+1, NFDBITS);
 	/* Explicitly test here, because xrealloc isn't always called */
 	if (nfdset && SIZE_T_MAX / nfdset < sizeof(fd_mask))
@@ -2108,10 +2123,29 @@ channel_prepare_select(fd_set **readsetp, fd_set **writesetp, int *maxfdp,
 		*writesetp = xrealloc(*writesetp, nfdset, sizeof(fd_mask));
 		*nallocp = sz;
 	}
+
+  #endif /* NX_WIN32_FIXME */
+  
 	*maxfdp = n;
+
+  #ifdef NX_WIN32_FIXME
+    
+    if (*readsetp == NULL) 
+    {
+      *readsetp = malloc(sizeof(fd_set));
+      *writesetp = malloc(sizeof(fd_set));
+    }
+    
+    FD_ZERO(*readsetp);
+    FD_ZERO(*writesetp);
+
+  #else /* NX_WIN32_FIXME */ 
+
 	memset(*readsetp, 0, sz);
 	memset(*writesetp, 0, sz);
-
+  
+  #endif /* else NX_WIN32_FIXME */
+  
 	if (!rekeying)
 		channel_handler(channel_pre, *readsetp, *writesetp);
 }
@@ -3222,6 +3256,7 @@ channel_connect_to(const char *host, u_short port, char *ctype, char *rname)
 void
 channel_send_window_changes(void)
 {
+#ifndef NX_WIN32_FIXME
 	u_int i;
 	struct winsize ws;
 
@@ -3238,6 +3273,7 @@ channel_send_window_changes(void)
 		packet_put_int((u_int)ws.ws_ypixel);
 		packet_send();
 	}
+#endif
 }
 
 /* -- X11 forwarding */
diff --git a/clientloop.c b/clientloop.c
index c19b01f..2139f3c 100644
--- a/clientloop.c
+++ b/clientloop.c
@@ -111,6 +111,16 @@
 #include "msg.h"
 #include "roaming.h"
 
+/* NX */
+#ifdef NX_WIN32_FIXME
+/*
+FIXME: GFPZR: Function stat() may be undeclared.
+*/
+#include <sys/stat.h>
+
+#define isatty(a) WSHELPisatty(a)
+#endif
+
 /* import options */
 extern Options options;
 
@@ -225,7 +235,9 @@ static void
 window_change_handler(int sig)
 {
 	received_window_change_signal = 1;
+#ifndef NX_WIN32_FIXME
 	signal(SIGWINCH, window_change_handler);
+#endif
 }
 
 /*
@@ -321,6 +333,7 @@ client_x11_get_proto(const char *display, const char *xauth_path,
 			display = xdisplay;
 		}
 		if (trusted == 0) {
+#ifndef NX_WIN32_FIXME
 			xauthdir = xmalloc(MAXPATHLEN);
 			xauthfile = xmalloc(MAXPATHLEN);
 			mktemp_proto(xauthdir, MAXPATHLEN);
@@ -343,6 +356,7 @@ client_x11_get_proto(const char *display, const char *xauth_path,
 						x11_refuse_time = now + timeout;
 				}
 			}
+#endif /* !NX_WIN32_FIXME */
 		}
 
 		/*
@@ -351,6 +365,7 @@ client_x11_get_proto(const char *display, const char *xauth_path,
 		 * above.
 		 */
 		if (trusted || generated) {
+#ifndef NX_WIN32_FIXME
 			snprintf(cmd, sizeof(cmd),
 			    "%s %s%s list %s 2>" _PATH_DEVNULL,
 			    xauth_path,
@@ -364,6 +379,7 @@ client_x11_get_proto(const char *display, const char *xauth_path,
 				got_data = 1;
 			if (f)
 				pclose(f);
+#endif /* !NX_WIN32_FIXME */
 		} else
 			error("Warning: untrusted X11 forwarding setup failed: "
 			    "xauth key data not generated");
@@ -497,6 +513,7 @@ client_make_packets_from_stdin_data(void)
 static void
 client_check_window_change(void)
 {
+#ifndef NX_WIN32_FIXME
 	struct winsize ws;
 
 	if (! received_window_change_signal)
@@ -518,6 +535,7 @@ client_check_window_change(void)
 		packet_put_int((u_int)ws.ws_ypixel);
 		packet_send();
 	}
+#endif /* !NX_WIN32_FIXME */
 }
 
 static void
@@ -652,6 +670,7 @@ client_wait_until_can_do_something(fd_set **readsetp, fd_set **writesetp,
 static void
 client_suspend_self(Buffer *bin, Buffer *bout, Buffer *berr)
 {
+#ifndef NX_WIN32_FIXME
 	/* Flush stdout and stderr buffers. */
 	if (buffer_len(bout) > 0)
 		atomicio(vwrite, fileno(stdout), buffer_ptr(bout),
@@ -682,6 +701,7 @@ client_suspend_self(Buffer *bin, Buffer *bout, Buffer *berr)
 	buffer_init(berr);
 
 	enter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);
+#endif /* !NX_WIN32_FIXME */
 }
 
 static void
@@ -848,7 +868,9 @@ process_cmdline(void)
 	fwd.listen_host = fwd.connect_host = NULL;
 
 	leave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);
+#ifndef NX_WIN32_FIXME
 	handler = signal(SIGINT, SIG_IGN);
+#endif
 	cmd = s = read_passphrase("\r\nssh> ", RP_ECHO);
 	if (s == NULL)
 		goto out;
@@ -1061,6 +1083,7 @@ process_escapes(Channel *c, Buffer *bin, Buffer *bout, Buffer *berr,
 				}
 				continue;
 
+#ifndef NX_WIN32_FIXME
 			case '&':
 				if (c && c->ctl_chan != -1)
 					goto noescape;
@@ -1112,6 +1135,7 @@ process_escapes(Channel *c, Buffer *bin, Buffer *bout, Buffer *berr,
 					}
 				}
 				continue;
+#endif /* !NX_WIN32_FIXME */
 
 			case '?':
 				if (c && c->ctl_chan != -1) {
@@ -1426,6 +1450,7 @@ client_loop(int have_pty, int escape_char_arg, int ssh2_chan_id)
 	 * Set signal handlers, (e.g. to restore non-blocking mode)
 	 * but don't overwrite SIG_IGN, matches behaviour from rsh(1)
 	 */
+#ifndef NX_WIN32_FIXME
 	if (signal(SIGHUP, SIG_IGN) != SIG_IGN)
 		signal(SIGHUP, signal_handler);
 	if (signal(SIGINT, SIG_IGN) != SIG_IGN)
@@ -1435,6 +1460,7 @@ client_loop(int have_pty, int escape_char_arg, int ssh2_chan_id)
 	if (signal(SIGTERM, SIG_IGN) != SIG_IGN)
 		signal(SIGTERM, signal_handler);
 	signal(SIGWINCH, window_change_handler);
+#endif
 
 	if (have_pty)
 		enter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);
@@ -1567,7 +1593,9 @@ client_loop(int have_pty, int escape_char_arg, int ssh2_chan_id)
 	/* Terminate the session. */
 
 	/* Stop watching for window change. */
+#ifndef NX_WIN32_FIXME
 	signal(SIGWINCH, SIG_DFL);
+#endif
 
 	if (compat20) {
 		packet_start(SSH2_MSG_DISCONNECT);
@@ -2000,14 +2028,18 @@ client_session2_setup(int id, int want_tty, int want_subsystem,
 	    options.ip_qos_interactive, options.ip_qos_bulk);
 
 	if (want_tty) {
+#ifndef NX_WIN32_FIXME
 		struct winsize ws;
 
 		/* Store window size in the packet. */
 		if (ioctl(in_fd, TIOCGWINSZ, &ws) < 0)
 			memset(&ws, 0, sizeof(ws));
+#endif /* !NX_WIN32_FIXME */
 
 		channel_request_start(id, "pty-req", 1);
 		client_expect_confirm(id, "PTY allocation", CONFIRM_TTY);
+
+#ifndef NX_WIN32_FIXME
 		packet_put_cstring(term != NULL ? term : "");
 		packet_put_int((u_int)ws.ws_col);
 		packet_put_int((u_int)ws.ws_row);
@@ -2016,6 +2048,14 @@ client_session2_setup(int id, int want_tty, int want_subsystem,
 		if (tiop == NULL)
 			tiop = get_saved_tio();
 		tty_make_modes(-1, tiop);
+#else
+		packet_put_int((u_int) 80 /*ws.ws_col*/);
+		packet_put_int((u_int) 25 /*ws.ws_row*/);
+		packet_put_int((u_int) 640 /*ws.ws_xpixel*/);
+		packet_put_int((u_int) 480 /*ws.ws_ypixel*/);
+		tty_make_modes(-1, NULL);
+#endif /* else !NX_WIN32_FIXME */
+
 		packet_send();
 		/* XXX wait for reply */
 		c->client_tty = 1;
diff --git a/config.h.in b/config.h.in
index baf0011..b5b514b 100644
--- a/config.h.in
+++ b/config.h.in
@@ -714,6 +714,9 @@
 /* Define to 1 if you have the `prctl' function. */
 #undef HAVE_PRCTL
 
+/* Define to 1 if you have priveleged-port concept */
+#undef HAVE_PRIV_CONCEPT
+
 /* Define if you have /proc/$pid/fd */
 #undef HAVE_PROC_PID
 
@@ -1086,6 +1089,9 @@
 /* Define to 1 if you have the `truncate' function. */
 #undef HAVE_TRUNCATE
 
+/* Define to 1 if you have tty support */
+#undef HAVE_TTY
+
 /* Define to 1 if you have the <ttyent.h> header file. */
 #undef HAVE_TTYENT_H
 
@@ -1456,6 +1462,9 @@
 /* Use PIPES instead of a socketpair() */
 #undef USE_PIPES
 
+/* Define if you want to sanitize fds */
+#undef USE_SANITISE_STDFD
+
 /* Define if you have Solaris process contracts */
 #undef USE_SOLARIS_PROCESS_CONTRACTS
 
diff --git a/config.h.tail b/config.h.tail
new file mode 100644
index 0000000..014677c
--- /dev/null
+++ b/config.h.tail
@@ -0,0 +1,92 @@
+/*
+ * NX
+ */
+#define WIN32_LEAN_AND_MEAN 1
+#define _CRT_SECURE_NO_DEPRECATE 1
+#define _CRT_NONSTDC_NO_DEPRECATE 1
+#define NX_WIN32_FIXME 1
+#undef NX_USE_NTCREATETOKEN
+
+/* Define if you must implement a startup_needs function for your platform */
+#define HAVE_STARTUP_NEEDS 1
+
+/* Define if your platform uses Winsock instead of BSD sockets (yeah, there are a lot of platforms like this :) */
+#define HAVE_WINSOCK 1
+
+#define snprintf _snprintf /* NX */
+
+#define BROKEN_READV_COMPARISON /* NX */
+
+/* Override detection of some headers and functions on MinGW */
+#undef BROKEN_SNPRINTF
+#define GETPGRP_VOID 1
+#undef HAVE_CRYPT_H
+#define HAVE_DAEMON 1
+#undef HAVE_ENDIAN_H
+#undef HAVE_FCNTL_H
+#define HAVE_FREEADDRINFO 1
+#define HAVE_GAI_STRERROR 1
+#define HAVE_GETADDRINFO 1
+#define HAVE_GETGROUPLIST 1
+#define HAVE_GETNAMEINFO 1
+#undef HAVE_ID_IN_UTMPX
+#define HAVE_INET_ATON 1
+#define HAVE_INET_NTOA 1
+#define HAVE_INNETGR 1
+#undef HAVE_LIBCRYPT
+#define HAVE_MKDTEMP 1
+#define HAVE_NANOSLEEP 1
+#undef HAVE_PATHS_H
+#undef HAVE_POLL_H
+#undef HAVE_PROC_PID
+#undef HAVE_PTY_H
+#define HAVE_NANOSLEEP 1
+#define HAVE_READPASSPHRASE 1
+#define HAVE_REALPATH 1
+#undef HAVE_SIG_ATOMIC_T
+#define HAVE_SIZE_T 1
+#undef HAVE_STRERROR
+#define HAVE_STRMODE 1
+
+#ifdef __MINGW32__ /* NX */ /* FIXME: Use autoconf to set this correctly */
+/* Define to 1 if you have the `strcasecmp' function. */
+#define HAVE_STRCASECMP 1
+
+/* Define to 1 if you have the `strncasecmp' function. */
+#define HAVE_STRNCASECMP 1
+#endif
+
+#define HAVE_STRUCT_IN6_ADDR 1
+#define HAVE_STRUCT_SOCKADDR_IN6 1
+#define HAVE_STRUCT_TIMEVAL 1
+#undef HAVE_SYS_CDEFS_H
+#undef HAVE_SYS_SYSMACROS_H
+#undef HAVE_SYS_MMAN_H
+#undef HAVE_SYS_UN_H
+
+#define HAVE_TCGETPGRP 1
+
+#undef HAVE_TIME
+
+#define HAVE_TRUNCATE 1
+
+#define HAVE_VIS_H 1
+
+#define MISSING_FD_MASK 1
+#define MISSING_HOWMANY 1
+#define MISSING_NFDBITS 1
+
+#undef SSH_PRIVSEP_USER
+
+#define HAVE_OPENPTY 1
+
+/* Fixes for loginrec.c */
+#undef CONF_UTMP_FILE
+#undef CONF_WTMPX_FILE
+#undef CONF_WTMP_FILE
+#undef CONF_UTMPX_FILE
+#undef CONF_LASTLOG_FILE
+
+#define BROKEN_SYS_TERMIO_H
+
+#define strerror strerror_win32
diff --git a/configure b/configure
index 43c4372..9535b4e 100644
--- a/configure
+++ b/configure
@@ -1,7 +1,7 @@
 #! /bin/sh
 # From configure.ac Revision: 1.480 .
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.68 for OpenSSH Portable.
+# Generated by GNU Autoconf 2.67 for OpenSSH Portable.
 #
 # Report bugs to <openssh-unix-dev@mindrot.org>.
 #
@@ -92,7 +92,6 @@ fi
 IFS=" ""	$as_nl"
 
 # Find who we are.  Look in the path if we contain no directory separator.
-as_myself=
 case $0 in #((
   *[\\/]* ) as_myself=$0 ;;
   *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
@@ -218,18 +217,11 @@ IFS=$as_save_IFS
   # We cannot yet assume a decent shell, so we have to provide a
 	# neutralization value for shells without unset; and this also
 	# works around shells that cannot unset nonexistent variables.
-	# Preserve -v and -x to the replacement shell.
 	BASH_ENV=/dev/null
 	ENV=/dev/null
 	(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
 	export CONFIG_SHELL
-	case $- in # ((((
-	  *v*x* | *x*v* ) as_opts=-vx ;;
-	  *v* ) as_opts=-v ;;
-	  *x* ) as_opts=-x ;;
-	  * ) as_opts= ;;
-	esac
-	exec "$CONFIG_SHELL" $as_opts "$as_myself" ${1+"$@"}
+	exec "$CONFIG_SHELL" "$as_myself" ${1+"$@"}
 fi
 
     if test x$as_have_required = xno; then :
@@ -606,6 +598,10 @@ ac_includes_default="\
 ac_subst_vars='LTLIBOBJS
 LIBOBJS
 TEST_SSH_IPV6
+WIN32COMPAT
+LIBWIN32COMPATDEPEND
+LIBWIN32COMPAT
+LINKWIN32COMPAT
 piddir
 user_path
 mansubdir
@@ -1171,7 +1167,7 @@ Try \`$0 --help' for more information"
     $as_echo "$as_me: WARNING: you should use --build, --host, --target" >&2
     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
       $as_echo "$as_me: WARNING: invalid host type: $ac_option" >&2
-    : "${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}"
+    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
     ;;
 
   esac
@@ -1514,7 +1510,7 @@ test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
 OpenSSH configure Portable
-generated by GNU Autoconf 2.68
+generated by GNU Autoconf 2.67
 
 Copyright (C) 2010 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
@@ -1560,7 +1556,7 @@ sed 's/^/| /' conftest.$ac_ext >&5
 
 	ac_retval=1
 fi
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
   as_fn_set_status $ac_retval
 
 } # ac_fn_c_try_compile
@@ -1602,7 +1598,7 @@ sed 's/^/| /' conftest.$ac_ext >&5
        ac_retval=$ac_status
 fi
   rm -rf conftest.dSYM conftest_ipa8_conftest.oo
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
   as_fn_set_status $ac_retval
 
 } # ac_fn_c_try_run
@@ -1639,7 +1635,7 @@ sed 's/^/| /' conftest.$ac_ext >&5
 
     ac_retval=1
 fi
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
   as_fn_set_status $ac_retval
 
 } # ac_fn_c_try_cpp
@@ -1653,7 +1649,7 @@ ac_fn_c_check_header_compile ()
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
 $as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
+if eval "test \"\${$3+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -1671,7 +1667,7 @@ fi
 eval ac_res=\$$3
 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
 
 } # ac_fn_c_check_header_compile
 
@@ -1686,7 +1682,7 @@ ac_fn_c_check_decl ()
   as_decl_use=`echo $2|sed -e 's/(/((/' -e 's/)/) 0&/' -e 's/,/) 0& (/g'`
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $as_decl_name is declared" >&5
 $as_echo_n "checking whether $as_decl_name is declared... " >&6; }
-if eval \${$3+:} false; then :
+if eval "test \"\${$3+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -1717,7 +1713,7 @@ fi
 eval ac_res=\$$3
 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
 
 } # ac_fn_c_check_decl
 
@@ -1762,7 +1758,7 @@ fi
   # interfere with the next link command; also delete a directory that is
   # left behind by Apple's compiler.  We do this before executing the actions.
   rm -rf conftest.dSYM conftest_ipa8_conftest.oo
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
   as_fn_set_status $ac_retval
 
 } # ac_fn_c_try_link
@@ -1775,10 +1771,10 @@ fi
 ac_fn_c_check_header_mongrel ()
 {
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if eval \${$3+:} false; then :
+  if eval "test \"\${$3+set}\"" = set; then :
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
 $as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
+if eval "test \"\${$3+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 fi
 eval ac_res=\$$3
@@ -1845,7 +1841,7 @@ $as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
 esac
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
 $as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
+if eval "test \"\${$3+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   eval "$3=\$ac_header_compiler"
@@ -1854,7 +1850,7 @@ eval ac_res=\$$3
 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
 fi
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
 
 } # ac_fn_c_check_header_mongrel
 
@@ -1866,7 +1862,7 @@ ac_fn_c_check_func ()
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
 $as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
+if eval "test \"\${$3+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -1921,7 +1917,7 @@ fi
 eval ac_res=\$$3
 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
 
 } # ac_fn_c_check_func
 
@@ -1934,7 +1930,7 @@ ac_fn_c_check_type ()
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
 $as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
+if eval "test \"\${$3+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   eval "$3=no"
@@ -1975,7 +1971,7 @@ fi
 eval ac_res=\$$3
 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
 
 } # ac_fn_c_check_type
 
@@ -2152,7 +2148,7 @@ rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
 rm -f conftest.val
 
   fi
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
   as_fn_set_status $ac_retval
 
 } # ac_fn_c_compute_int
@@ -2166,7 +2162,7 @@ ac_fn_c_check_member ()
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2.$3" >&5
 $as_echo_n "checking for $2.$3... " >&6; }
-if eval \${$4+:} false; then :
+if eval "test \"\${$4+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -2210,7 +2206,7 @@ fi
 eval ac_res=\$$4
 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
 
 } # ac_fn_c_check_member
 cat >config.log <<_ACEOF
@@ -2218,7 +2214,7 @@ This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
 It was created by OpenSSH $as_me Portable, which was
-generated by GNU Autoconf 2.68.  Invocation command line was
+generated by GNU Autoconf 2.67.  Invocation command line was
 
   $ $0 $@
 
@@ -2476,7 +2472,7 @@ $as_echo "$as_me: loading site script $ac_site_file" >&6;}
       || { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
 as_fn_error $? "failed to load site script $ac_site_file
-See \`config.log' for more details" "$LINENO" 5; }
+See \`config.log' for more details" "$LINENO" 5 ; }
   fi
 done
 
@@ -2567,6 +2563,7 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
 
+
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
@@ -2586,7 +2583,7 @@ if test -n "$ac_tool_prefix"; then
 set dummy ${ac_tool_prefix}gcc; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
+if test "${ac_cv_prog_CC+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
@@ -2626,7 +2623,7 @@ if test -z "$ac_cv_prog_CC"; then
 set dummy gcc; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_CC+:} false; then :
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_CC"; then
@@ -2679,7 +2676,7 @@ if test -z "$CC"; then
 set dummy ${ac_tool_prefix}cc; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
+if test "${ac_cv_prog_CC+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
@@ -2719,7 +2716,7 @@ if test -z "$CC"; then
 set dummy cc; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
+if test "${ac_cv_prog_CC+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
@@ -2778,7 +2775,7 @@ if test -z "$CC"; then
 set dummy $ac_tool_prefix$ac_prog; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
+if test "${ac_cv_prog_CC+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
@@ -2822,7 +2819,7 @@ do
 set dummy $ac_prog; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_CC+:} false; then :
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_CC"; then
@@ -2877,7 +2874,7 @@ fi
 test -z "$CC" && { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
 as_fn_error $? "no acceptable C compiler found in \$PATH
-See \`config.log' for more details" "$LINENO" 5; }
+See \`config.log' for more details" "$LINENO" 5 ; }
 
 # Provide some information about the compiler.
 $as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
@@ -2992,7 +2989,7 @@ sed 's/^/| /' conftest.$ac_ext >&5
 { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
 as_fn_error 77 "C compiler cannot create executables
-See \`config.log' for more details" "$LINENO" 5; }
+See \`config.log' for more details" "$LINENO" 5 ; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
@@ -3035,7 +3032,7 @@ else
   { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
 as_fn_error $? "cannot compute suffix of executables: cannot compile and link
-See \`config.log' for more details" "$LINENO" 5; }
+See \`config.log' for more details" "$LINENO" 5 ; }
 fi
 rm -f conftest conftest$ac_cv_exeext
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext" >&5
@@ -3094,7 +3091,7 @@ $as_echo "$ac_try_echo"; } >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
 as_fn_error $? "cannot run C compiled programs.
 If you meant to cross compile, use \`--host'.
-See \`config.log' for more details" "$LINENO" 5; }
+See \`config.log' for more details" "$LINENO" 5 ; }
     fi
   fi
 fi
@@ -3105,7 +3102,7 @@ rm -f conftest.$ac_ext conftest$ac_cv_exeext conftest.out
 ac_clean_files=$ac_clean_files_save
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of object files" >&5
 $as_echo_n "checking for suffix of object files... " >&6; }
-if ${ac_cv_objext+:} false; then :
+if test "${ac_cv_objext+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -3146,7 +3143,7 @@ sed 's/^/| /' conftest.$ac_ext >&5
 { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
 as_fn_error $? "cannot compute suffix of object files: cannot compile
-See \`config.log' for more details" "$LINENO" 5; }
+See \`config.log' for more details" "$LINENO" 5 ; }
 fi
 rm -f conftest.$ac_cv_objext conftest.$ac_ext
 fi
@@ -3156,7 +3153,7 @@ OBJEXT=$ac_cv_objext
 ac_objext=$OBJEXT
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler" >&5
 $as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
-if ${ac_cv_c_compiler_gnu+:} false; then :
+if test "${ac_cv_c_compiler_gnu+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -3193,7 +3190,7 @@ ac_test_CFLAGS=${CFLAGS+set}
 ac_save_CFLAGS=$CFLAGS
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
 $as_echo_n "checking whether $CC accepts -g... " >&6; }
-if ${ac_cv_prog_cc_g+:} false; then :
+if test "${ac_cv_prog_cc_g+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_save_c_werror_flag=$ac_c_werror_flag
@@ -3271,7 +3268,7 @@ else
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89" >&5
 $as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
-if ${ac_cv_prog_cc_c89+:} false; then :
+if test "${ac_cv_prog_cc_c89+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_cv_prog_cc_c89=no
@@ -3401,7 +3398,7 @@ $SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking build system type" >&5
 $as_echo_n "checking build system type... " >&6; }
-if ${ac_cv_build+:} false; then :
+if test "${ac_cv_build+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_build_alias=$build_alias
@@ -3417,7 +3414,7 @@ fi
 $as_echo "$ac_cv_build" >&6; }
 case $ac_cv_build in
 *-*-*) ;;
-*) as_fn_error $? "invalid value of canonical build" "$LINENO" 5;;
+*) as_fn_error $? "invalid value of canonical build" "$LINENO" 5 ;;
 esac
 build=$ac_cv_build
 ac_save_IFS=$IFS; IFS='-'
@@ -3435,7 +3432,7 @@ case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking host system type" >&5
 $as_echo_n "checking host system type... " >&6; }
-if ${ac_cv_host+:} false; then :
+if test "${ac_cv_host+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test "x$host_alias" = x; then
@@ -3450,7 +3447,7 @@ fi
 $as_echo "$ac_cv_host" >&6; }
 case $ac_cv_host in
 *-*-*) ;;
-*) as_fn_error $? "invalid value of canonical host" "$LINENO" 5;;
+*) as_fn_error $? "invalid value of canonical host" "$LINENO" 5 ;;
 esac
 host=$ac_cv_host
 ac_save_IFS=$IFS; IFS='-'
@@ -3479,7 +3476,7 @@ if test -n "$CPP" && test -d "$CPP"; then
   CPP=
 fi
 if test -z "$CPP"; then
-  if ${ac_cv_prog_CPP+:} false; then :
+  if test "${ac_cv_prog_CPP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
       # Double quotes because CPP needs to be expanded
@@ -3595,7 +3592,7 @@ else
   { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
 as_fn_error $? "C preprocessor \"$CPP\" fails sanity check
-See \`config.log' for more details" "$LINENO" 5; }
+See \`config.log' for more details" "$LINENO" 5 ; }
 fi
 
 ac_ext=c
@@ -3607,7 +3604,7 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
 $as_echo_n "checking for grep that handles long lines and -e... " >&6; }
-if ${ac_cv_path_GREP+:} false; then :
+if test "${ac_cv_path_GREP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -z "$GREP"; then
@@ -3670,7 +3667,7 @@ $as_echo "$ac_cv_path_GREP" >&6; }
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for egrep" >&5
 $as_echo_n "checking for egrep... " >&6; }
-if ${ac_cv_path_EGREP+:} false; then :
+if test "${ac_cv_path_EGREP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
@@ -3737,7 +3734,7 @@ $as_echo "$ac_cv_path_EGREP" >&6; }
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
 $as_echo_n "checking for ANSI C header files... " >&6; }
-if ${ac_cv_header_stdc+:} false; then :
+if test "${ac_cv_header_stdc+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -3866,7 +3863,7 @@ done
 
  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether byte ordering is bigendian" >&5
 $as_echo_n "checking whether byte ordering is bigendian... " >&6; }
-if ${ac_cv_c_bigendian+:} false; then :
+if test "${ac_cv_c_bigendian+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_cv_c_bigendian=unknown
@@ -4085,7 +4082,7 @@ $as_echo "#define AC_APPLE_UNIVERSAL_BUILD 1" >>confdefs.h
      ;; #(
    *)
      as_fn_error $? "unknown endianness
- presetting ac_cv_c_bigendian=no (or yes) will help" "$LINENO" 5 ;;
+ presetting ac_cv_c_bigendian=no (or yes) will help" "$LINENO" 5  ;;
  esac
 
 
@@ -4096,7 +4093,7 @@ do
 set dummy $ac_prog; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_AWK+:} false; then :
+if test "${ac_cv_prog_AWK+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$AWK"; then
@@ -4144,7 +4141,7 @@ if test -n "$CPP" && test -d "$CPP"; then
   CPP=
 fi
 if test -z "$CPP"; then
-  if ${ac_cv_prog_CPP+:} false; then :
+  if test "${ac_cv_prog_CPP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
       # Double quotes because CPP needs to be expanded
@@ -4260,7 +4257,7 @@ else
   { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
 as_fn_error $? "C preprocessor \"$CPP\" fails sanity check
-See \`config.log' for more details" "$LINENO" 5; }
+See \`config.log' for more details" "$LINENO" 5 ; }
 fi
 
 ac_ext=c
@@ -4274,7 +4271,7 @@ if test -n "$ac_tool_prefix"; then
 set dummy ${ac_tool_prefix}ranlib; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_RANLIB+:} false; then :
+if test "${ac_cv_prog_RANLIB+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$RANLIB"; then
@@ -4314,7 +4311,7 @@ if test -z "$ac_cv_prog_RANLIB"; then
 set dummy ranlib; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_RANLIB+:} false; then :
+if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_RANLIB"; then
@@ -4378,7 +4375,7 @@ fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for a BSD-compatible install" >&5
 $as_echo_n "checking for a BSD-compatible install... " >&6; }
 if test -z "$INSTALL"; then
-if ${ac_cv_path_install+:} false; then :
+if test "${ac_cv_path_install+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
@@ -4456,7 +4453,7 @@ test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for egrep" >&5
 $as_echo_n "checking for egrep... " >&6; }
-if ${ac_cv_path_EGREP+:} false; then :
+if test "${ac_cv_path_EGREP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
@@ -4525,7 +4522,7 @@ $as_echo "$ac_cv_path_EGREP" >&6; }
 set dummy ar; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_AR+:} false; then :
+if test "${ac_cv_path_AR+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $AR in
@@ -4565,7 +4562,7 @@ fi
 set dummy cat; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_CAT+:} false; then :
+if test "${ac_cv_path_CAT+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $CAT in
@@ -4605,7 +4602,7 @@ fi
 set dummy kill; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_KILL+:} false; then :
+if test "${ac_cv_path_KILL+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $KILL in
@@ -4647,7 +4644,7 @@ do
 set dummy $ac_prog; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_PERL+:} false; then :
+if test "${ac_cv_path_PERL+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $PERL in
@@ -4690,7 +4687,7 @@ done
 set dummy sed; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_SED+:} false; then :
+if test "${ac_cv_path_SED+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $SED in
@@ -4731,7 +4728,7 @@ fi
 set dummy ent; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_ENT+:} false; then :
+if test "${ac_cv_path_ENT+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $ENT in
@@ -4772,7 +4769,7 @@ fi
 set dummy bash; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_TEST_MINUS_S_SH+:} false; then :
+if test "${ac_cv_path_TEST_MINUS_S_SH+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $TEST_MINUS_S_SH in
@@ -4812,7 +4809,7 @@ fi
 set dummy ksh; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_TEST_MINUS_S_SH+:} false; then :
+if test "${ac_cv_path_TEST_MINUS_S_SH+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $TEST_MINUS_S_SH in
@@ -4852,7 +4849,7 @@ fi
 set dummy sh; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_TEST_MINUS_S_SH+:} false; then :
+if test "${ac_cv_path_TEST_MINUS_S_SH+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $TEST_MINUS_S_SH in
@@ -4892,7 +4889,7 @@ fi
 set dummy sh; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_SH+:} false; then :
+if test "${ac_cv_path_SH+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $SH in
@@ -4932,7 +4929,7 @@ fi
 set dummy groff; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_GROFF+:} false; then :
+if test "${ac_cv_path_GROFF+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $GROFF in
@@ -4972,7 +4969,7 @@ fi
 set dummy nroff; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_NROFF+:} false; then :
+if test "${ac_cv_path_NROFF+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $NROFF in
@@ -5012,7 +5009,7 @@ fi
 set dummy mandoc; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_MANDOC+:} false; then :
+if test "${ac_cv_path_MANDOC+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $MANDOC in
@@ -5068,7 +5065,7 @@ fi
 set dummy groupadd; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_PATH_GROUPADD_PROG+:} false; then :
+if test "${ac_cv_path_PATH_GROUPADD_PROG+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $PATH_GROUPADD_PROG in
@@ -5109,7 +5106,7 @@ fi
 set dummy useradd; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_PATH_USERADD_PROG+:} false; then :
+if test "${ac_cv_path_PATH_USERADD_PROG+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $PATH_USERADD_PROG in
@@ -5150,7 +5147,7 @@ fi
 set dummy pkgmk; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_MAKE_PACKAGE_SUPPORTED+:} false; then :
+if test "${ac_cv_prog_MAKE_PACKAGE_SUPPORTED+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$MAKE_PACKAGE_SUPPORTED"; then
@@ -5202,7 +5199,7 @@ if test "$enable_largefile" != no; then
 
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for special C compiler options needed for large files" >&5
 $as_echo_n "checking for special C compiler options needed for large files... " >&6; }
-if ${ac_cv_sys_largefile_CC+:} false; then :
+if test "${ac_cv_sys_largefile_CC+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_cv_sys_largefile_CC=no
@@ -5253,7 +5250,7 @@ $as_echo "$ac_cv_sys_largefile_CC" >&6; }
 
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for _FILE_OFFSET_BITS value needed for large files" >&5
 $as_echo_n "checking for _FILE_OFFSET_BITS value needed for large files... " >&6; }
-if ${ac_cv_sys_file_offset_bits+:} false; then :
+if test "${ac_cv_sys_file_offset_bits+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   while :; do
@@ -5322,7 +5319,7 @@ rm -rf conftest*
   if test $ac_cv_sys_file_offset_bits = unknown; then
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for _LARGE_FILES value needed for large files" >&5
 $as_echo_n "checking for _LARGE_FILES value needed for large files... " >&6; }
-if ${ac_cv_sys_large_files+:} false; then :
+if test "${ac_cv_sys_large_files+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   while :; do
@@ -5409,7 +5406,7 @@ else
 set dummy login; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_LOGIN_PROGRAM_FALLBACK+:} false; then :
+if test "${ac_cv_path_LOGIN_PROGRAM_FALLBACK+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $LOGIN_PROGRAM_FALLBACK in
@@ -5457,7 +5454,7 @@ fi
 set dummy passwd; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_PATH_PASSWD_PROG+:} false; then :
+if test "${ac_cv_path_PATH_PASSWD_PROG+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $PATH_PASSWD_PROG in
@@ -5508,7 +5505,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for inline" >&5
 $as_echo_n "checking for inline... " >&6; }
-if ${ac_cv_c_inline+:} false; then :
+if test "${ac_cv_c_inline+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_cv_c_inline=no
@@ -5551,7 +5548,7 @@ esac
 
 ac_fn_c_check_decl "$LINENO" "LLONG_MAX" "ac_cv_have_decl_LLONG_MAX" "#include <limits.h>
 "
-if test "x$ac_cv_have_decl_LLONG_MAX" = xyes; then :
+if test "x$ac_cv_have_decl_LLONG_MAX" = x""yes; then :
   have_llong_max=1
 fi
 
@@ -5561,7 +5558,7 @@ ac_fn_c_check_decl "$LINENO" "SYSTR_POLICY_KILL" "ac_cv_have_decl_SYSTR_POLICY_K
 	#include <dev/systrace.h>
 
 "
-if test "x$ac_cv_have_decl_SYSTR_POLICY_KILL" = xyes; then :
+if test "x$ac_cv_have_decl_SYSTR_POLICY_KILL" = x""yes; then :
   have_systr_policy_kill=1
 fi
 
@@ -5570,7 +5567,7 @@ ac_fn_c_check_decl "$LINENO" "RLIMIT_NPROC" "ac_cv_have_decl_RLIMIT_NPROC" "
 	#include <sys/resource.h>
 
 "
-if test "x$ac_cv_have_decl_RLIMIT_NPROC" = xyes; then :
+if test "x$ac_cv_have_decl_RLIMIT_NPROC" = x""yes; then :
 
 $as_echo "#define HAVE_RLIMIT_NPROC /**/" >>confdefs.h
 
@@ -5900,7 +5897,7 @@ rm -f core conftest.err conftest.$ac_objext \
 		ac_fn_c_check_decl "$LINENO" "LLONG_MAX" "ac_cv_have_decl_LLONG_MAX" "#include <limits.h>
 
 "
-if test "x$ac_cv_have_decl_LLONG_MAX" = xyes; then :
+if test "x$ac_cv_have_decl_LLONG_MAX" = x""yes; then :
   have_llong_max=1
 else
   CFLAGS="$saved_CFLAGS"
@@ -6081,7 +6078,7 @@ do :
 #endif
 
 "
-if test "x$ac_cv_header_lastlog_h" = xyes; then :
+if test "x$ac_cv_header_lastlog_h" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LASTLOG_H 1
 _ACEOF
@@ -6100,7 +6097,7 @@ do :
 #endif
 
 "
-if test "x$ac_cv_header_sys_ptms_h" = xyes; then :
+if test "x$ac_cv_header_sys_ptms_h" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_SYS_PTMS_H 1
 _ACEOF
@@ -6117,7 +6114,7 @@ do :
 #include <sys/types.h>
 
 "
-if test "x$ac_cv_header_login_cap_h" = xyes; then :
+if test "x$ac_cv_header_login_cap_h" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LOGIN_CAP_H 1
 _ACEOF
@@ -6134,7 +6131,7 @@ do :
 #include <sys/param.h>
 
 "
-if test "x$ac_cv_header_sys_mount_h" = xyes; then :
+if test "x$ac_cv_header_sys_mount_h" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_SYS_MOUNT_H 1
 _ACEOF
@@ -6229,14 +6226,14 @@ $as_echo "$blibflags" >&6; }
 	fi
 	LDFLAGS="$saved_LDFLAGS"
 		ac_fn_c_check_func "$LINENO" "authenticate" "ac_cv_func_authenticate"
-if test "x$ac_cv_func_authenticate" = xyes; then :
+if test "x$ac_cv_func_authenticate" = x""yes; then :
 
 $as_echo "#define WITH_AIXAUTHENTICATE 1" >>confdefs.h
 
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for authenticate in -ls" >&5
 $as_echo_n "checking for authenticate in -ls... " >&6; }
-if ${ac_cv_lib_s_authenticate+:} false; then :
+if test "${ac_cv_lib_s_authenticate+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -6270,7 +6267,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_s_authenticate" >&5
 $as_echo "$ac_cv_lib_s_authenticate" >&6; }
-if test "x$ac_cv_lib_s_authenticate" = xyes; then :
+if test "x$ac_cv_lib_s_authenticate" = x""yes; then :
    $as_echo "#define WITH_AIXAUTHENTICATE 1" >>confdefs.h
 
 				LIBS="$LIBS -ls"
@@ -6282,7 +6279,7 @@ fi
 
 		ac_fn_c_check_decl "$LINENO" "authenticate" "ac_cv_have_decl_authenticate" "#include <usersec.h>
 "
-if test "x$ac_cv_have_decl_authenticate" = xyes; then :
+if test "x$ac_cv_have_decl_authenticate" = x""yes; then :
   ac_have_decl=1
 else
   ac_have_decl=0
@@ -6293,7 +6290,7 @@ cat >>confdefs.h <<_ACEOF
 _ACEOF
 ac_fn_c_check_decl "$LINENO" "loginrestrictions" "ac_cv_have_decl_loginrestrictions" "#include <usersec.h>
 "
-if test "x$ac_cv_have_decl_loginrestrictions" = xyes; then :
+if test "x$ac_cv_have_decl_loginrestrictions" = x""yes; then :
   ac_have_decl=1
 else
   ac_have_decl=0
@@ -6304,7 +6301,7 @@ cat >>confdefs.h <<_ACEOF
 _ACEOF
 ac_fn_c_check_decl "$LINENO" "loginsuccess" "ac_cv_have_decl_loginsuccess" "#include <usersec.h>
 "
-if test "x$ac_cv_have_decl_loginsuccess" = xyes; then :
+if test "x$ac_cv_have_decl_loginsuccess" = x""yes; then :
   ac_have_decl=1
 else
   ac_have_decl=0
@@ -6315,7 +6312,7 @@ cat >>confdefs.h <<_ACEOF
 _ACEOF
 ac_fn_c_check_decl "$LINENO" "passwdexpired" "ac_cv_have_decl_passwdexpired" "#include <usersec.h>
 "
-if test "x$ac_cv_have_decl_passwdexpired" = xyes; then :
+if test "x$ac_cv_have_decl_passwdexpired" = x""yes; then :
   ac_have_decl=1
 else
   ac_have_decl=0
@@ -6326,7 +6323,7 @@ cat >>confdefs.h <<_ACEOF
 _ACEOF
 ac_fn_c_check_decl "$LINENO" "setauthdb" "ac_cv_have_decl_setauthdb" "#include <usersec.h>
 "
-if test "x$ac_cv_have_decl_setauthdb" = xyes; then :
+if test "x$ac_cv_have_decl_setauthdb" = x""yes; then :
   ac_have_decl=1
 else
   ac_have_decl=0
@@ -6339,7 +6336,7 @@ _ACEOF
 		ac_fn_c_check_decl "$LINENO" "loginfailed" "ac_cv_have_decl_loginfailed" "#include <usersec.h>
 
 "
-if test "x$ac_cv_have_decl_loginfailed" = xyes; then :
+if test "x$ac_cv_have_decl_loginfailed" = x""yes; then :
   ac_have_decl=1
 else
   ac_have_decl=0
@@ -6392,7 +6389,7 @@ done
 	      #include <fcntl.h>
 
 "
-if test "x$ac_cv_have_decl_F_CLOSEM" = xyes; then :
+if test "x$ac_cv_have_decl_F_CLOSEM" = x""yes; then :
 
 $as_echo "#define HAVE_FCNTL_CLOSEM 1" >>confdefs.h
 
@@ -6466,6 +6463,47 @@ $as_echo "#define IP_TOS_IS_BROKEN 1" >>confdefs.h
 	$as_echo "#define BROKEN_SETREGID 1" >>confdefs.h
 
 	;;
+*-*-mingw32*)
+       LIBS="$LIBS -lws2_32 -lgdi32 -lNetAPI32 -luserenv -lsecur32 -lshlwapi"
+       CFLAGS="$CFLAGS -mno-cygwin -I$PWD/contrib/win32/win32compat/includes"
+       LDFLAGS="$LDFLAGS -mno-cygwin"
+
+
+$as_echo "#define USE_PIPES 1" >>confdefs.h
+
+
+$as_echo "#define DISABLE_SHADOW 1" >>confdefs.h
+
+
+$as_echo "#define IP_TOS_IS_BROKEN 1" >>confdefs.h
+
+
+$as_echo "#define NO_X11_UNIX_SOCKETS 1" >>confdefs.h
+
+
+$as_echo "#define NO_IPPORT_RESERVED_CONCEPT 1" >>confdefs.h
+
+
+$as_echo "#define DISABLE_FD_PASSING 1" >>confdefs.h
+
+
+$as_echo "#define DISABLE_UTMP 1" >>confdefs.h
+
+
+$as_echo "#define DISABLE_UTMPX 1" >>confdefs.h
+
+
+$as_echo "#define ENABLE_PKCS11 1" >>confdefs.h
+
+
+       #
+       # We have no krb5-config tool and we don't want
+       # linking to -lkrb5 on Windows.
+       #
+
+       SkipGssapiLibsCheck=1
+
+       ;;
 *-*-darwin*)
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if we have working getaddrinfo" >&5
 $as_echo_n "checking if we have working getaddrinfo... " >&6; }
@@ -6523,7 +6561,7 @@ $as_echo "#define SSH_TUN_PREPEND_AF 1" >>confdefs.h
 
 
 	ac_fn_c_check_decl "$LINENO" "AU_IPv4" "ac_cv_have_decl_AU_IPv4" "$ac_includes_default"
-if test "x$ac_cv_have_decl_AU_IPv4" = xyes; then :
+if test "x$ac_cv_have_decl_AU_IPv4" = x""yes; then :
 
 else
 
@@ -6542,7 +6580,7 @@ $as_echo "#define SPT_TYPE SPT_REUSEARGV" >>confdefs.h
 	for ac_func in sandbox_init
 do :
   ac_fn_c_check_func "$LINENO" "sandbox_init" "ac_cv_func_sandbox_init"
-if test "x$ac_cv_func_sandbox_init" = xyes; then :
+if test "x$ac_cv_func_sandbox_init" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_SANDBOX_INIT 1
 _ACEOF
@@ -6553,7 +6591,7 @@ done
 	for ac_header in sandbox.h
 do :
   ac_fn_c_check_header_mongrel "$LINENO" "sandbox.h" "ac_cv_header_sandbox_h" "$ac_includes_default"
-if test "x$ac_cv_header_sandbox_h" = xyes; then :
+if test "x$ac_cv_header_sandbox_h" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_SANDBOX_H 1
 _ACEOF
@@ -6570,7 +6608,7 @@ done
     LIBS="$LIBS -lbsd "
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for socket in -lnetwork" >&5
 $as_echo_n "checking for socket in -lnetwork... " >&6; }
-if ${ac_cv_lib_network_socket+:} false; then :
+if test "${ac_cv_lib_network_socket+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -6604,7 +6642,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_network_socket" >&5
 $as_echo "$ac_cv_lib_network_socket" >&6; }
-if test "x$ac_cv_lib_network_socket" = xyes; then :
+if test "x$ac_cv_lib_network_socket" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBNETWORK 1
 _ACEOF
@@ -6637,7 +6675,7 @@ $as_echo "#define LOCKED_PASSWD_STRING \"*\"" >>confdefs.h
 	LIBS="$LIBS -lsec"
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for t_error in -lxnet" >&5
 $as_echo_n "checking for t_error in -lxnet... " >&6; }
-if ${ac_cv_lib_xnet_t_error+:} false; then :
+if test "${ac_cv_lib_xnet_t_error+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -6671,7 +6709,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_xnet_t_error" >&5
 $as_echo "$ac_cv_lib_xnet_t_error" >&6; }
-if test "x$ac_cv_lib_xnet_t_error" = xyes; then :
+if test "x$ac_cv_lib_xnet_t_error" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBXNET 1
 _ACEOF
@@ -6745,7 +6783,7 @@ $as_echo "#define WITH_IRIX_PROJECT 1" >>confdefs.h
 $as_echo "#define WITH_IRIX_AUDIT 1" >>confdefs.h
 
 	ac_fn_c_check_func "$LINENO" "jlimit_startjob" "ac_cv_func_jlimit_startjob"
-if test "x$ac_cv_func_jlimit_startjob" = xyes; then :
+if test "x$ac_cv_func_jlimit_startjob" = x""yes; then :
 
 $as_echo "#define WITH_IRIX_JOBS 1" >>confdefs.h
 
@@ -6817,7 +6855,7 @@ $as_echo "#define BROKEN_CMSG_TYPE 1" >>confdefs.h
 	for ac_header in linux/if_tun.h
 do :
   ac_fn_c_check_header_mongrel "$LINENO" "linux/if_tun.h" "ac_cv_header_linux_if_tun_h" "$ac_includes_default"
-if test "x$ac_cv_header_linux_if_tun_h" = xyes; then :
+if test "x$ac_cv_header_linux_if_tun_h" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LINUX_IF_TUN_H 1
 _ACEOF
@@ -6853,7 +6891,7 @@ $as_echo "#define NEED_SETPGRP 1" >>confdefs.h
 $as_echo "#define SSH_TUN_FREEBSD 1" >>confdefs.h
 
 	ac_fn_c_check_header_mongrel "$LINENO" "net/if_tap.h" "ac_cv_header_net_if_tap_h" "$ac_includes_default"
-if test "x$ac_cv_header_net_if_tap_h" = xyes; then :
+if test "x$ac_cv_header_net_if_tap_h" = x""yes; then :
 
 else
 
@@ -6875,7 +6913,7 @@ $as_echo "#define LOCKED_PASSWD_PREFIX \"*LOCKED*\"" >>confdefs.h
 $as_echo "#define SSH_TUN_FREEBSD 1" >>confdefs.h
 
 	ac_fn_c_check_header_mongrel "$LINENO" "net/if_tap.h" "ac_cv_header_net_if_tap_h" "$ac_includes_default"
-if test "x$ac_cv_header_net_if_tap_h" = xyes; then :
+if test "x$ac_cv_header_net_if_tap_h" = x""yes; then :
 
 else
 
@@ -6978,7 +7016,7 @@ if test "${with_solaris_contracts+set}" = set; then :
   withval=$with_solaris_contracts;
 		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ct_tmpl_activate in -lcontract" >&5
 $as_echo_n "checking for ct_tmpl_activate in -lcontract... " >&6; }
-if ${ac_cv_lib_contract_ct_tmpl_activate+:} false; then :
+if test "${ac_cv_lib_contract_ct_tmpl_activate+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -7012,7 +7050,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_contract_ct_tmpl_activate" >&5
 $as_echo "$ac_cv_lib_contract_ct_tmpl_activate" >&6; }
-if test "x$ac_cv_lib_contract_ct_tmpl_activate" = xyes; then :
+if test "x$ac_cv_lib_contract_ct_tmpl_activate" = x""yes; then :
 
 $as_echo "#define USE_SOLARIS_PROCESS_CONTRACTS 1" >>confdefs.h
 
@@ -7029,7 +7067,7 @@ if test "${with_solaris_projects+set}" = set; then :
   withval=$with_solaris_projects;
 		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for setproject in -lproject" >&5
 $as_echo_n "checking for setproject in -lproject... " >&6; }
-if ${ac_cv_lib_project_setproject+:} false; then :
+if test "${ac_cv_lib_project_setproject+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -7063,7 +7101,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_project_setproject" >&5
 $as_echo "$ac_cv_lib_project_setproject" >&6; }
-if test "x$ac_cv_lib_project_setproject" = xyes; then :
+if test "x$ac_cv_lib_project_setproject" = x""yes; then :
 
 $as_echo "#define USE_SOLARIS_PROJECTS 1" >>confdefs.h
 
@@ -7080,7 +7118,7 @@ fi
 	for ac_func in getpwanam
 do :
   ac_fn_c_check_func "$LINENO" "getpwanam" "ac_cv_func_getpwanam"
-if test "x$ac_cv_func_getpwanam" = xyes; then :
+if test "x$ac_cv_func_getpwanam" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_GETPWANAM 1
 _ACEOF
@@ -7113,7 +7151,7 @@ done
 	# /usr/ucblib MUST NOT be searched on ReliantUNIX
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlsym in -ldl" >&5
 $as_echo_n "checking for dlsym in -ldl... " >&6; }
-if ${ac_cv_lib_dl_dlsym+:} false; then :
+if test "${ac_cv_lib_dl_dlsym+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -7147,7 +7185,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlsym" >&5
 $as_echo "$ac_cv_lib_dl_dlsym" >&6; }
-if test "x$ac_cv_lib_dl_dlsym" = xyes; then :
+if test "x$ac_cv_lib_dl_dlsym" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBDL 1
 _ACEOF
@@ -7159,7 +7197,7 @@ fi
 	# -lresolv needs to be at the end of LIBS or DNS lookups break
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for res_query in -lresolv" >&5
 $as_echo_n "checking for res_query in -lresolv... " >&6; }
-if ${ac_cv_lib_resolv_res_query+:} false; then :
+if test "${ac_cv_lib_resolv_res_query+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -7193,7 +7231,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_resolv_res_query" >&5
 $as_echo "$ac_cv_lib_resolv_res_query" >&6; }
-if test "x$ac_cv_lib_resolv_res_query" = xyes; then :
+if test "x$ac_cv_lib_resolv_res_query" = x""yes; then :
    LIBS="$LIBS -lresolv"
 fi
 
@@ -7260,7 +7298,7 @@ $as_echo "#define BROKEN_LIBIAF 1" >>confdefs.h
 
 		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for getluid in -lprot" >&5
 $as_echo_n "checking for getluid in -lprot... " >&6; }
-if ${ac_cv_lib_prot_getluid+:} false; then :
+if test "${ac_cv_lib_prot_getluid+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -7294,7 +7332,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_prot_getluid" >&5
 $as_echo "$ac_cv_lib_prot_getluid" >&6; }
-if test "x$ac_cv_lib_prot_getluid" = xyes; then :
+if test "x$ac_cv_lib_prot_getluid" = x""yes; then :
    LIBS="$LIBS -lprot"
 			for ac_func in getluid setluid
 do :
@@ -7564,12 +7602,12 @@ fi
 
 # Checks for libraries.
 ac_fn_c_check_func "$LINENO" "yp_match" "ac_cv_func_yp_match"
-if test "x$ac_cv_func_yp_match" = xyes; then :
+if test "x$ac_cv_func_yp_match" = x""yes; then :
 
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for yp_match in -lnsl" >&5
 $as_echo_n "checking for yp_match in -lnsl... " >&6; }
-if ${ac_cv_lib_nsl_yp_match+:} false; then :
+if test "${ac_cv_lib_nsl_yp_match+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -7603,7 +7641,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_nsl_yp_match" >&5
 $as_echo "$ac_cv_lib_nsl_yp_match" >&6; }
-if test "x$ac_cv_lib_nsl_yp_match" = xyes; then :
+if test "x$ac_cv_lib_nsl_yp_match" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBNSL 1
 _ACEOF
@@ -7615,12 +7653,12 @@ fi
 fi
 
 ac_fn_c_check_func "$LINENO" "setsockopt" "ac_cv_func_setsockopt"
-if test "x$ac_cv_func_setsockopt" = xyes; then :
+if test "x$ac_cv_func_setsockopt" = x""yes; then :
 
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for setsockopt in -lsocket" >&5
 $as_echo_n "checking for setsockopt in -lsocket... " >&6; }
-if ${ac_cv_lib_socket_setsockopt+:} false; then :
+if test "${ac_cv_lib_socket_setsockopt+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -7654,7 +7692,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_socket_setsockopt" >&5
 $as_echo "$ac_cv_lib_socket_setsockopt" >&6; }
-if test "x$ac_cv_lib_socket_setsockopt" = xyes; then :
+if test "x$ac_cv_lib_socket_setsockopt" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBSOCKET 1
 _ACEOF
@@ -7669,14 +7707,14 @@ fi
 for ac_func in dirname
 do :
   ac_fn_c_check_func "$LINENO" "dirname" "ac_cv_func_dirname"
-if test "x$ac_cv_func_dirname" = xyes; then :
+if test "x$ac_cv_func_dirname" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_DIRNAME 1
 _ACEOF
  for ac_header in libgen.h
 do :
   ac_fn_c_check_header_mongrel "$LINENO" "libgen.h" "ac_cv_header_libgen_h" "$ac_includes_default"
-if test "x$ac_cv_header_libgen_h" = xyes; then :
+if test "x$ac_cv_header_libgen_h" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBGEN_H 1
 _ACEOF
@@ -7689,7 +7727,7 @@ else
 
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for dirname in -lgen" >&5
 $as_echo_n "checking for dirname in -lgen... " >&6; }
-if ${ac_cv_lib_gen_dirname+:} false; then :
+if test "${ac_cv_lib_gen_dirname+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -7723,11 +7761,11 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gen_dirname" >&5
 $as_echo "$ac_cv_lib_gen_dirname" >&6; }
-if test "x$ac_cv_lib_gen_dirname" = xyes; then :
+if test "x$ac_cv_lib_gen_dirname" = x""yes; then :
 
 		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for broken dirname" >&5
 $as_echo_n "checking for broken dirname... " >&6; }
-if ${ac_cv_have_broken_dirname+:} false; then :
+if test "${ac_cv_have_broken_dirname+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -7776,7 +7814,7 @@ $as_echo "$ac_cv_have_broken_dirname" >&6; }
 			for ac_header in libgen.h
 do :
   ac_fn_c_check_header_mongrel "$LINENO" "libgen.h" "ac_cv_header_libgen_h" "$ac_includes_default"
-if test "x$ac_cv_header_libgen_h" = xyes; then :
+if test "x$ac_cv_header_libgen_h" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBGEN_H 1
 _ACEOF
@@ -7795,12 +7833,12 @@ done
 
 
 ac_fn_c_check_func "$LINENO" "getspnam" "ac_cv_func_getspnam"
-if test "x$ac_cv_func_getspnam" = xyes; then :
+if test "x$ac_cv_func_getspnam" = x""yes; then :
 
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for getspnam in -lgen" >&5
 $as_echo_n "checking for getspnam in -lgen... " >&6; }
-if ${ac_cv_lib_gen_getspnam+:} false; then :
+if test "${ac_cv_lib_gen_getspnam+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -7834,7 +7872,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gen_getspnam" >&5
 $as_echo "$ac_cv_lib_gen_getspnam" >&6; }
-if test "x$ac_cv_lib_gen_getspnam" = xyes; then :
+if test "x$ac_cv_lib_gen_getspnam" = x""yes; then :
   LIBS="$LIBS -lgen"
 fi
 
@@ -7842,7 +7880,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing basename" >&5
 $as_echo_n "checking for library containing basename... " >&6; }
-if ${ac_cv_search_basename+:} false; then :
+if test "${ac_cv_search_basename+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_func_search_save_LIBS=$LIBS
@@ -7876,11 +7914,11 @@ for ac_lib in '' gen; do
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext
-  if ${ac_cv_search_basename+:} false; then :
+  if test "${ac_cv_search_basename+set}" = set; then :
   break
 fi
 done
-if ${ac_cv_search_basename+:} false; then :
+if test "${ac_cv_search_basename+set}" = set; then :
 
 else
   ac_cv_search_basename=no
@@ -7929,7 +7967,7 @@ fi
 
 
 ac_fn_c_check_header_mongrel "$LINENO" "zlib.h" "ac_cv_header_zlib_h" "$ac_includes_default"
-if test "x$ac_cv_header_zlib_h" = xyes; then :
+if test "x$ac_cv_header_zlib_h" = x""yes; then :
 
 else
   as_fn_error $? "*** zlib.h missing - please install first or check config.log ***" "$LINENO" 5
@@ -7938,7 +7976,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for deflate in -lz" >&5
 $as_echo_n "checking for deflate in -lz... " >&6; }
-if ${ac_cv_lib_z_deflate+:} false; then :
+if test "${ac_cv_lib_z_deflate+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -7972,7 +8010,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_z_deflate" >&5
 $as_echo "$ac_cv_lib_z_deflate" >&6; }
-if test "x$ac_cv_lib_z_deflate" = xyes; then :
+if test "x$ac_cv_lib_z_deflate" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBZ 1
 _ACEOF
@@ -8100,12 +8138,12 @@ fi
 
 
 ac_fn_c_check_func "$LINENO" "strcasecmp" "ac_cv_func_strcasecmp"
-if test "x$ac_cv_func_strcasecmp" = xyes; then :
+if test "x$ac_cv_func_strcasecmp" = x""yes; then :
 
 else
    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for strcasecmp in -lresolv" >&5
 $as_echo_n "checking for strcasecmp in -lresolv... " >&6; }
-if ${ac_cv_lib_resolv_strcasecmp+:} false; then :
+if test "${ac_cv_lib_resolv_strcasecmp+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -8139,7 +8177,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_resolv_strcasecmp" >&5
 $as_echo "$ac_cv_lib_resolv_strcasecmp" >&6; }
-if test "x$ac_cv_lib_resolv_strcasecmp" = xyes; then :
+if test "x$ac_cv_lib_resolv_strcasecmp" = x""yes; then :
   LIBS="$LIBS -lresolv"
 fi
 
@@ -8149,7 +8187,7 @@ fi
 for ac_func in utimes
 do :
   ac_fn_c_check_func "$LINENO" "utimes" "ac_cv_func_utimes"
-if test "x$ac_cv_func_utimes" = xyes; then :
+if test "x$ac_cv_func_utimes" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_UTIMES 1
 _ACEOF
@@ -8157,7 +8195,7 @@ _ACEOF
 else
    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for utimes in -lc89" >&5
 $as_echo_n "checking for utimes in -lc89... " >&6; }
-if ${ac_cv_lib_c89_utimes+:} false; then :
+if test "${ac_cv_lib_c89_utimes+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -8191,7 +8229,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_c89_utimes" >&5
 $as_echo "$ac_cv_lib_c89_utimes" >&6; }
-if test "x$ac_cv_lib_c89_utimes" = xyes; then :
+if test "x$ac_cv_lib_c89_utimes" = x""yes; then :
   $as_echo "#define HAVE_UTIMES 1" >>confdefs.h
 
 					LIBS="$LIBS -lc89"
@@ -8202,10 +8240,19 @@ fi
 done
 
 
-for ac_header in libutil.h
+
+ #
+ # NX_WIN32_FIXME
+ #
+
+ case "$host" in
+ *-*-mingw32*)
+       ;;
+ *)
+       for ac_header in libutil.h
 do :
   ac_fn_c_check_header_mongrel "$LINENO" "libutil.h" "ac_cv_header_libutil_h" "$ac_includes_default"
-if test "x$ac_cv_header_libutil_h" = xyes; then :
+if test "x$ac_cv_header_libutil_h" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBUTIL_H 1
 _ACEOF
@@ -8214,9 +8261,9 @@ fi
 
 done
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing login" >&5
+       { $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing login" >&5
 $as_echo_n "checking for library containing login... " >&6; }
-if ${ac_cv_search_login+:} false; then :
+if test "${ac_cv_search_login+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_func_search_save_LIBS=$LIBS
@@ -8250,11 +8297,11 @@ for ac_lib in '' util bsd; do
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext
-  if ${ac_cv_search_login+:} false; then :
+  if test "${ac_cv_search_login+set}" = set; then :
   break
 fi
 done
-if ${ac_cv_search_login+:} false; then :
+if test "${ac_cv_search_login+set}" = set; then :
 
 else
   ac_cv_search_login=no
@@ -8272,7 +8319,7 @@ $as_echo "#define HAVE_LOGIN 1" >>confdefs.h
 
 fi
 
-for ac_func in fmt_scaled logout updwtmp logwtmp
+       for ac_func in fmt_scaled logout updwtmp logwtmp
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
@@ -8284,11 +8331,17 @@ _ACEOF
 fi
 done
 
+       ;;
+ esac
+
+ #
+ # END FIXME
+ #
 
 for ac_func in strftime
 do :
   ac_fn_c_check_func "$LINENO" "strftime" "ac_cv_func_strftime"
-if test "x$ac_cv_func_strftime" = xyes; then :
+if test "x$ac_cv_func_strftime" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_STRFTIME 1
 _ACEOF
@@ -8297,7 +8350,7 @@ else
   # strftime is in -lintl on SCO UNIX.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for strftime in -lintl" >&5
 $as_echo_n "checking for strftime in -lintl... " >&6; }
-if ${ac_cv_lib_intl_strftime+:} false; then :
+if test "${ac_cv_lib_intl_strftime+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -8331,7 +8384,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_intl_strftime" >&5
 $as_echo "$ac_cv_lib_intl_strftime" >&6; }
-if test "x$ac_cv_lib_intl_strftime" = xyes; then :
+if test "x$ac_cv_lib_intl_strftime" = x""yes; then :
   $as_echo "#define HAVE_STRFTIME 1" >>confdefs.h
 
 LIBS="-lintl $LIBS"
@@ -8441,7 +8494,7 @@ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
 ac_fn_c_check_decl "$LINENO" "GLOB_NOMATCH" "ac_cv_have_decl_GLOB_NOMATCH" "#include <glob.h>
 "
-if test "x$ac_cv_have_decl_GLOB_NOMATCH" = xyes; then :
+if test "x$ac_cv_have_decl_GLOB_NOMATCH" = x""yes; then :
   ac_have_decl=1
 else
   ac_have_decl=0
@@ -8686,7 +8739,7 @@ if test "${with_libedit+set}" = set; then :
 set dummy pkg-config; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_PKGCONFIG+:} false; then :
+if test "${ac_cv_path_PKGCONFIG+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $PKGCONFIG in
@@ -8752,7 +8805,7 @@ $as_echo "no" >&6; }
 		OTHERLIBS=`echo $LIBEDIT | sed 's/-ledit//'`
 		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for el_init in -ledit" >&5
 $as_echo_n "checking for el_init in -ledit... " >&6; }
-if ${ac_cv_lib_edit_el_init+:} false; then :
+if test "${ac_cv_lib_edit_el_init+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -8787,7 +8840,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_edit_el_init" >&5
 $as_echo "$ac_cv_lib_edit_el_init" >&6; }
-if test "x$ac_cv_lib_edit_el_init" = xyes; then :
+if test "x$ac_cv_lib_edit_el_init" = x""yes; then :
 
 $as_echo "#define USE_LIBEDIT 1" >>confdefs.h
 
@@ -8851,7 +8904,7 @@ do :
 
 
 "
-if test "x$ac_cv_header_bsm_audit_h" = xyes; then :
+if test "x$ac_cv_header_bsm_audit_h" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_BSM_AUDIT_H 1
 _ACEOF
@@ -8864,7 +8917,7 @@ done
 
 		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for getaudit in -lbsm" >&5
 $as_echo_n "checking for getaudit in -lbsm... " >&6; }
-if ${ac_cv_lib_bsm_getaudit+:} false; then :
+if test "${ac_cv_lib_bsm_getaudit+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -8898,7 +8951,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_bsm_getaudit" >&5
 $as_echo "$ac_cv_lib_bsm_getaudit" >&6; }
-if test "x$ac_cv_lib_bsm_getaudit" = xyes; then :
+if test "x$ac_cv_lib_bsm_getaudit" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBBSM 1
 _ACEOF
@@ -8912,7 +8965,7 @@ fi
 		for ac_func in getaudit
 do :
   ac_fn_c_check_func "$LINENO" "getaudit" "ac_cv_func_getaudit"
-if test "x$ac_cv_func_getaudit" = xyes; then :
+if test "x$ac_cv_func_getaudit" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_GETAUDIT 1
 _ACEOF
@@ -8946,7 +8999,7 @@ $as_echo "linux" >&6; }
 				for ac_header in libaudit.h
 do :
   ac_fn_c_check_header_mongrel "$LINENO" "libaudit.h" "ac_cv_header_libaudit_h" "$ac_includes_default"
-if test "x$ac_cv_header_libaudit_h" = xyes; then :
+if test "x$ac_cv_header_libaudit_h" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBAUDIT_H 1
 _ACEOF
@@ -9112,7 +9165,7 @@ rm -f core conftest.err conftest.$ac_objext \
 # PKCS#11 support requires dlopen() and co
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing dlopen" >&5
 $as_echo_n "checking for library containing dlopen... " >&6; }
-if ${ac_cv_search_dlopen+:} false; then :
+if test "${ac_cv_search_dlopen+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_func_search_save_LIBS=$LIBS
@@ -9146,11 +9199,11 @@ for ac_lib in '' dl; do
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext
-  if ${ac_cv_search_dlopen+:} false; then :
+  if test "${ac_cv_search_dlopen+set}" = set; then :
   break
 fi
 done
-if ${ac_cv_search_dlopen+:} false; then :
+if test "${ac_cv_search_dlopen+set}" = set; then :
 
 else
   ac_cv_search_dlopen=no
@@ -9174,7 +9227,7 @@ fi
 for ac_func in gai_strerror
 do :
   ac_fn_c_check_func "$LINENO" "gai_strerror" "ac_cv_func_gai_strerror"
-if test "x$ac_cv_func_gai_strerror" = xyes; then :
+if test "x$ac_cv_func_gai_strerror" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_GAI_STRERROR 1
 _ACEOF
@@ -9214,7 +9267,7 @@ done
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing nanosleep" >&5
 $as_echo_n "checking for library containing nanosleep... " >&6; }
-if ${ac_cv_search_nanosleep+:} false; then :
+if test "${ac_cv_search_nanosleep+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_func_search_save_LIBS=$LIBS
@@ -9248,11 +9301,11 @@ for ac_lib in '' rt posix4; do
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext
-  if ${ac_cv_search_nanosleep+:} false; then :
+  if test "${ac_cv_search_nanosleep+set}" = set; then :
   break
 fi
 done
-if ${ac_cv_search_nanosleep+:} false; then :
+if test "${ac_cv_search_nanosleep+set}" = set; then :
 
 else
   ac_cv_search_nanosleep=no
@@ -9272,11 +9325,11 @@ fi
 
 
 ac_fn_c_check_decl "$LINENO" "getrusage" "ac_cv_have_decl_getrusage" "$ac_includes_default"
-if test "x$ac_cv_have_decl_getrusage" = xyes; then :
+if test "x$ac_cv_have_decl_getrusage" = x""yes; then :
   for ac_func in getrusage
 do :
   ac_fn_c_check_func "$LINENO" "getrusage" "ac_cv_func_getrusage"
-if test "x$ac_cv_func_getrusage" = xyes; then :
+if test "x$ac_cv_func_getrusage" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_GETRUSAGE 1
 _ACEOF
@@ -9292,11 +9345,11 @@ ac_fn_c_check_decl "$LINENO" "strsep" "ac_cv_have_decl_strsep" "
 #endif
 
 "
-if test "x$ac_cv_have_decl_strsep" = xyes; then :
+if test "x$ac_cv_have_decl_strsep" = x""yes; then :
   for ac_func in strsep
 do :
   ac_fn_c_check_func "$LINENO" "strsep" "ac_cv_func_strsep"
-if test "x$ac_cv_func_strsep" = xyes; then :
+if test "x$ac_cv_func_strsep" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_STRSEP 1
 _ACEOF
@@ -9310,14 +9363,14 @@ fi
 ac_fn_c_check_decl "$LINENO" "tcsendbreak" "ac_cv_have_decl_tcsendbreak" "#include <termios.h>
 
 "
-if test "x$ac_cv_have_decl_tcsendbreak" = xyes; then :
+if test "x$ac_cv_have_decl_tcsendbreak" = x""yes; then :
   $as_echo "#define HAVE_TCSENDBREAK 1" >>confdefs.h
 
 else
   for ac_func in tcsendbreak
 do :
   ac_fn_c_check_func "$LINENO" "tcsendbreak" "ac_cv_func_tcsendbreak"
-if test "x$ac_cv_func_tcsendbreak" = xyes; then :
+if test "x$ac_cv_func_tcsendbreak" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_TCSENDBREAK 1
 _ACEOF
@@ -9330,7 +9383,7 @@ fi
 
 ac_fn_c_check_decl "$LINENO" "h_errno" "ac_cv_have_decl_h_errno" "#include <netdb.h>
 "
-if test "x$ac_cv_have_decl_h_errno" = xyes; then :
+if test "x$ac_cv_have_decl_h_errno" = x""yes; then :
   ac_have_decl=1
 else
   ac_have_decl=0
@@ -9346,7 +9399,7 @@ ac_fn_c_check_decl "$LINENO" "SHUT_RD" "ac_cv_have_decl_SHUT_RD" "
 #include <sys/socket.h>
 
 "
-if test "x$ac_cv_have_decl_SHUT_RD" = xyes; then :
+if test "x$ac_cv_have_decl_SHUT_RD" = x""yes; then :
   ac_have_decl=1
 else
   ac_have_decl=0
@@ -9367,7 +9420,7 @@ ac_fn_c_check_decl "$LINENO" "O_NONBLOCK" "ac_cv_have_decl_O_NONBLOCK" "
 #endif
 
 "
-if test "x$ac_cv_have_decl_O_NONBLOCK" = xyes; then :
+if test "x$ac_cv_have_decl_O_NONBLOCK" = x""yes; then :
   ac_have_decl=1
 else
   ac_have_decl=0
@@ -9384,7 +9437,7 @@ ac_fn_c_check_decl "$LINENO" "writev" "ac_cv_have_decl_writev" "
 #include <unistd.h>
 
 "
-if test "x$ac_cv_have_decl_writev" = xyes; then :
+if test "x$ac_cv_have_decl_writev" = x""yes; then :
   ac_have_decl=1
 else
   ac_have_decl=0
@@ -9399,7 +9452,7 @@ ac_fn_c_check_decl "$LINENO" "MAXSYMLINKS" "ac_cv_have_decl_MAXSYMLINKS" "
 #include <sys/param.h>
 
 "
-if test "x$ac_cv_have_decl_MAXSYMLINKS" = xyes; then :
+if test "x$ac_cv_have_decl_MAXSYMLINKS" = x""yes; then :
   ac_have_decl=1
 else
   ac_have_decl=0
@@ -9414,7 +9467,7 @@ ac_fn_c_check_decl "$LINENO" "offsetof" "ac_cv_have_decl_offsetof" "
 #include <stddef.h>
 
 "
-if test "x$ac_cv_have_decl_offsetof" = xyes; then :
+if test "x$ac_cv_have_decl_offsetof" = x""yes; then :
   ac_have_decl=1
 else
   ac_have_decl=0
@@ -9428,7 +9481,7 @@ _ACEOF
 for ac_func in setresuid
 do :
   ac_fn_c_check_func "$LINENO" "setresuid" "ac_cv_func_setresuid"
-if test "x$ac_cv_func_setresuid" = xyes; then :
+if test "x$ac_cv_func_setresuid" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_SETRESUID 1
 _ACEOF
@@ -9483,7 +9536,7 @@ done
 for ac_func in setresgid
 do :
   ac_fn_c_check_func "$LINENO" "setresgid" "ac_cv_func_setresgid"
-if test "x$ac_cv_func_setresgid" = xyes; then :
+if test "x$ac_cv_func_setresgid" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_SETRESGID 1
 _ACEOF
@@ -9562,7 +9615,7 @@ done
 for ac_func in utmpname
 do :
   ac_fn_c_check_func "$LINENO" "utmpname" "ac_cv_func_utmpname"
-if test "x$ac_cv_func_utmpname" = xyes; then :
+if test "x$ac_cv_func_utmpname" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_UTMPNAME 1
 _ACEOF
@@ -9597,7 +9650,7 @@ done
 for ac_func in getlastlogxbyname
 do :
   ac_fn_c_check_func "$LINENO" "getlastlogxbyname" "ac_cv_func_getlastlogxbyname"
-if test "x$ac_cv_func_getlastlogxbyname" = xyes; then :
+if test "x$ac_cv_func_getlastlogxbyname" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_GETLASTLOGXBYNAME 1
 _ACEOF
@@ -9607,14 +9660,14 @@ done
 
 
 ac_fn_c_check_func "$LINENO" "daemon" "ac_cv_func_daemon"
-if test "x$ac_cv_func_daemon" = xyes; then :
+if test "x$ac_cv_func_daemon" = x""yes; then :
 
 $as_echo "#define HAVE_DAEMON 1" >>confdefs.h
 
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for daemon in -lbsd" >&5
 $as_echo_n "checking for daemon in -lbsd... " >&6; }
-if ${ac_cv_lib_bsd_daemon+:} false; then :
+if test "${ac_cv_lib_bsd_daemon+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -9648,7 +9701,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_bsd_daemon" >&5
 $as_echo "$ac_cv_lib_bsd_daemon" >&6; }
-if test "x$ac_cv_lib_bsd_daemon" = xyes; then :
+if test "x$ac_cv_lib_bsd_daemon" = x""yes; then :
   LIBS="$LIBS -lbsd"; $as_echo "#define HAVE_DAEMON 1" >>confdefs.h
 
 fi
@@ -9658,14 +9711,14 @@ fi
 
 
 ac_fn_c_check_func "$LINENO" "getpagesize" "ac_cv_func_getpagesize"
-if test "x$ac_cv_func_getpagesize" = xyes; then :
+if test "x$ac_cv_func_getpagesize" = x""yes; then :
 
 $as_echo "#define HAVE_GETPAGESIZE 1" >>confdefs.h
 
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for getpagesize in -lucb" >&5
 $as_echo_n "checking for getpagesize in -lucb... " >&6; }
-if ${ac_cv_lib_ucb_getpagesize+:} false; then :
+if test "${ac_cv_lib_ucb_getpagesize+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -9699,7 +9752,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_ucb_getpagesize" >&5
 $as_echo "$ac_cv_lib_ucb_getpagesize" >&6; }
-if test "x$ac_cv_lib_ucb_getpagesize" = xyes; then :
+if test "x$ac_cv_lib_ucb_getpagesize" = x""yes; then :
   LIBS="$LIBS -lucb"; $as_echo "#define HAVE_GETPAGESIZE 1" >>confdefs.h
 
 fi
@@ -10204,7 +10257,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether getpgrp requires zero arguments" >&5
 $as_echo_n "checking whether getpgrp requires zero arguments... " >&6; }
-if ${ac_cv_func_getpgrp_void+:} false; then :
+if test "${ac_cv_func_getpgrp_void+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   # Use it with a single arg.
@@ -10309,7 +10362,7 @@ else
 		fi
 		CPPFLAGS="-I/usr/local/ssl/include ${saved_CPPFLAGS}"
 		ac_fn_c_check_header_mongrel "$LINENO" "openssl/opensslv.h" "ac_cv_header_openssl_opensslv_h" "$ac_includes_default"
-if test "x$ac_cv_header_openssl_opensslv_h" = xyes; then :
+if test "x$ac_cv_header_openssl_opensslv_h" = x""yes; then :
 
 else
   as_fn_error $? "*** OpenSSL headers missing - please install first or check config.log ***" "$LINENO" 5
@@ -10721,7 +10774,7 @@ rm -f core conftest.err conftest.$ac_objext \
 if test "x$check_for_libcrypt_before" = "x1"; then
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for crypt in -lcrypt" >&5
 $as_echo_n "checking for crypt in -lcrypt... " >&6; }
-if ${ac_cv_lib_crypt_crypt+:} false; then :
+if test "${ac_cv_lib_crypt_crypt+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -10755,7 +10808,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_crypt_crypt" >&5
 $as_echo "$ac_cv_lib_crypt_crypt" >&6; }
-if test "x$ac_cv_lib_crypt_crypt" = xyes; then :
+if test "x$ac_cv_lib_crypt_crypt" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBCRYPT 1
 _ACEOF
@@ -10771,7 +10824,7 @@ fi
 if test "x$check_for_libcrypt_later" = "x1"; then
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for crypt in -lcrypt" >&5
 $as_echo_n "checking for crypt in -lcrypt... " >&6; }
-if ${ac_cv_lib_crypt_crypt+:} false; then :
+if test "${ac_cv_lib_crypt_crypt+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -10805,7 +10858,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_crypt_crypt" >&5
 $as_echo "$ac_cv_lib_crypt_crypt" >&6; }
-if test "x$ac_cv_lib_crypt_crypt" = xyes; then :
+if test "x$ac_cv_lib_crypt_crypt" = x""yes; then :
   LIBS="$LIBS -lcrypt"
 fi
 
@@ -10882,7 +10935,7 @@ rm -f core conftest.err conftest.$ac_objext \
 saved_LIBS="$LIBS"
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ia_openinfo in -liaf" >&5
 $as_echo_n "checking for ia_openinfo in -liaf... " >&6; }
-if ${ac_cv_lib_iaf_ia_openinfo+:} false; then :
+if test "${ac_cv_lib_iaf_ia_openinfo+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -10916,13 +10969,13 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_iaf_ia_openinfo" >&5
 $as_echo "$ac_cv_lib_iaf_ia_openinfo" >&6; }
-if test "x$ac_cv_lib_iaf_ia_openinfo" = xyes; then :
+if test "x$ac_cv_lib_iaf_ia_openinfo" = x""yes; then :
 
 	LIBS="$LIBS -liaf"
 	for ac_func in set_id
 do :
   ac_fn_c_check_func "$LINENO" "set_id" "ac_cv_func_set_id"
-if test "x$ac_cv_func_set_id" = xyes; then :
+if test "x$ac_cv_func_set_id" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_SET_ID 1
 _ACEOF
@@ -11109,7 +11162,7 @@ if test "${with_pam+set}" = set; then :
 			saved_LIBS="$LIBS"
 			{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
 $as_echo_n "checking for dlopen in -ldl... " >&6; }
-if ${ac_cv_lib_dl_dlopen+:} false; then :
+if test "${ac_cv_lib_dl_dlopen+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -11143,7 +11196,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
 $as_echo "$ac_cv_lib_dl_dlopen" >&6; }
-if test "x$ac_cv_lib_dl_dlopen" = xyes; then :
+if test "x$ac_cv_lib_dl_dlopen" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBDL 1
 _ACEOF
@@ -11154,7 +11207,7 @@ fi
 
 			{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for pam_set_item in -lpam" >&5
 $as_echo_n "checking for pam_set_item in -lpam... " >&6; }
-if ${ac_cv_lib_pam_pam_set_item+:} false; then :
+if test "${ac_cv_lib_pam_pam_set_item+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -11188,7 +11241,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pam_pam_set_item" >&5
 $as_echo "$ac_cv_lib_pam_pam_set_item" >&6; }
-if test "x$ac_cv_lib_pam_pam_set_item" = xyes; then :
+if test "x$ac_cv_lib_pam_pam_set_item" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBPAM 1
 _ACEOF
@@ -11202,7 +11255,7 @@ fi
 			for ac_func in pam_getenvlist
 do :
   ac_fn_c_check_func "$LINENO" "pam_getenvlist" "ac_cv_func_pam_getenvlist"
-if test "x$ac_cv_func_pam_getenvlist" = xyes; then :
+if test "x$ac_cv_func_pam_getenvlist" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_PAM_GETENVLIST 1
 _ACEOF
@@ -11213,7 +11266,7 @@ done
 			for ac_func in pam_putenv
 do :
   ac_fn_c_check_func "$LINENO" "pam_putenv" "ac_cv_func_pam_putenv"
-if test "x$ac_cv_func_pam_putenv" = xyes; then :
+if test "x$ac_cv_func_pam_putenv" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_PAM_PUTENV 1
 _ACEOF
@@ -11366,7 +11419,7 @@ fi
 
 # Check for  long long datatypes
 ac_fn_c_check_type "$LINENO" "long long" "ac_cv_type_long_long" "$ac_includes_default"
-if test "x$ac_cv_type_long_long" = xyes; then :
+if test "x$ac_cv_type_long_long" = x""yes; then :
 
 cat >>confdefs.h <<_ACEOF
 #define HAVE_LONG_LONG 1
@@ -11375,7 +11428,7 @@ _ACEOF
 
 fi
 ac_fn_c_check_type "$LINENO" "unsigned long long" "ac_cv_type_unsigned_long_long" "$ac_includes_default"
-if test "x$ac_cv_type_unsigned_long_long" = xyes; then :
+if test "x$ac_cv_type_unsigned_long_long" = x""yes; then :
 
 cat >>confdefs.h <<_ACEOF
 #define HAVE_UNSIGNED_LONG_LONG 1
@@ -11384,7 +11437,7 @@ _ACEOF
 
 fi
 ac_fn_c_check_type "$LINENO" "long double" "ac_cv_type_long_double" "$ac_includes_default"
-if test "x$ac_cv_type_long_double" = xyes; then :
+if test "x$ac_cv_type_long_double" = x""yes; then :
 
 cat >>confdefs.h <<_ACEOF
 #define HAVE_LONG_DOUBLE 1
@@ -11401,7 +11454,7 @@ fi
 # This bug is HP SR number 8606223364.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking size of char" >&5
 $as_echo_n "checking size of char... " >&6; }
-if ${ac_cv_sizeof_char+:} false; then :
+if test "${ac_cv_sizeof_char+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (char))" "ac_cv_sizeof_char"        "$ac_includes_default"; then :
@@ -11411,7 +11464,7 @@ else
      { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
 as_fn_error 77 "cannot compute sizeof (char)
-See \`config.log' for more details" "$LINENO" 5; }
+See \`config.log' for more details" "$LINENO" 5 ; }
    else
      ac_cv_sizeof_char=0
    fi
@@ -11434,7 +11487,7 @@ _ACEOF
 # This bug is HP SR number 8606223364.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking size of short int" >&5
 $as_echo_n "checking size of short int... " >&6; }
-if ${ac_cv_sizeof_short_int+:} false; then :
+if test "${ac_cv_sizeof_short_int+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (short int))" "ac_cv_sizeof_short_int"        "$ac_includes_default"; then :
@@ -11444,7 +11497,7 @@ else
      { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
 as_fn_error 77 "cannot compute sizeof (short int)
-See \`config.log' for more details" "$LINENO" 5; }
+See \`config.log' for more details" "$LINENO" 5 ; }
    else
      ac_cv_sizeof_short_int=0
    fi
@@ -11467,7 +11520,7 @@ _ACEOF
 # This bug is HP SR number 8606223364.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking size of int" >&5
 $as_echo_n "checking size of int... " >&6; }
-if ${ac_cv_sizeof_int+:} false; then :
+if test "${ac_cv_sizeof_int+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (int))" "ac_cv_sizeof_int"        "$ac_includes_default"; then :
@@ -11477,7 +11530,7 @@ else
      { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
 as_fn_error 77 "cannot compute sizeof (int)
-See \`config.log' for more details" "$LINENO" 5; }
+See \`config.log' for more details" "$LINENO" 5 ; }
    else
      ac_cv_sizeof_int=0
    fi
@@ -11500,7 +11553,7 @@ _ACEOF
 # This bug is HP SR number 8606223364.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking size of long int" >&5
 $as_echo_n "checking size of long int... " >&6; }
-if ${ac_cv_sizeof_long_int+:} false; then :
+if test "${ac_cv_sizeof_long_int+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (long int))" "ac_cv_sizeof_long_int"        "$ac_includes_default"; then :
@@ -11510,7 +11563,7 @@ else
      { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
 as_fn_error 77 "cannot compute sizeof (long int)
-See \`config.log' for more details" "$LINENO" 5; }
+See \`config.log' for more details" "$LINENO" 5 ; }
    else
      ac_cv_sizeof_long_int=0
    fi
@@ -11533,7 +11586,7 @@ _ACEOF
 # This bug is HP SR number 8606223364.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking size of long long int" >&5
 $as_echo_n "checking size of long long int... " >&6; }
-if ${ac_cv_sizeof_long_long_int+:} false; then :
+if test "${ac_cv_sizeof_long_long_int+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (long long int))" "ac_cv_sizeof_long_long_int"        "$ac_includes_default"; then :
@@ -11543,7 +11596,7 @@ else
      { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
 as_fn_error 77 "cannot compute sizeof (long long int)
-See \`config.log' for more details" "$LINENO" 5; }
+See \`config.log' for more details" "$LINENO" 5 ; }
    else
      ac_cv_sizeof_long_long_int=0
    fi
@@ -11696,7 +11749,7 @@ fi
 # More checks for data types
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for u_int type" >&5
 $as_echo_n "checking for u_int type... " >&6; }
-if ${ac_cv_have_u_int+:} false; then :
+if test "${ac_cv_have_u_int+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -11731,7 +11784,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for intXX_t types" >&5
 $as_echo_n "checking for intXX_t types... " >&6; }
-if ${ac_cv_have_intxx_t+:} false; then :
+if test "${ac_cv_have_intxx_t+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -11797,7 +11850,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for int64_t type" >&5
 $as_echo_n "checking for int64_t type... " >&6; }
-if ${ac_cv_have_int64_t+:} false; then :
+if test "${ac_cv_have_int64_t+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -11842,7 +11895,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for u_intXX_t types" >&5
 $as_echo_n "checking for u_intXX_t types... " >&6; }
-if ${ac_cv_have_u_intxx_t+:} false; then :
+if test "${ac_cv_have_u_intxx_t+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -11906,7 +11959,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for u_int64_t types" >&5
 $as_echo_n "checking for u_int64_t types... " >&6; }
-if ${ac_cv_have_u_int64_t+:} false; then :
+if test "${ac_cv_have_u_int64_t+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -11971,7 +12024,7 @@ fi
 if test -z "$have_u_intxx_t" ; then
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for uintXX_t types" >&5
 $as_echo_n "checking for uintXX_t types... " >&6; }
-if ${ac_cv_have_uintxx_t+:} false; then :
+if test "${ac_cv_have_uintxx_t+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -12082,7 +12135,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for u_char" >&5
 $as_echo_n "checking for u_char... " >&6; }
-if ${ac_cv_have_u_char+:} false; then :
+if test "${ac_cv_have_u_char+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -12114,17 +12167,25 @@ $as_echo "#define HAVE_U_CHAR 1" >>confdefs.h
 
 fi
 
+#
+# NX_WIN32_FIXME
+#
+
+case "$host" in
+*-*-mingw32*)
+      ;;
+*)
 
    ac_fn_c_check_type "$LINENO" "socklen_t" "ac_cv_type_socklen_t" "#include <sys/types.h>
 #include <sys/socket.h>
 "
-if test "x$ac_cv_type_socklen_t" = xyes; then :
+if test "x$ac_cv_type_socklen_t" = x""yes; then :
 
 else
 
       { $as_echo "$as_me:${as_lineno-$LINENO}: checking for socklen_t equivalent" >&5
 $as_echo_n "checking for socklen_t equivalent... " >&6; }
-      if ${curl_cv_socklen_t_equiv+:} false; then :
+      if test "${curl_cv_socklen_t_equiv+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -12178,10 +12239,16 @@ _ACEOF
 fi
 
 
+      ;;
+esac
+
+#
+# END FIXME
+#
 
 ac_fn_c_check_type "$LINENO" "sig_atomic_t" "ac_cv_type_sig_atomic_t" "#include <signal.h>
 "
-if test "x$ac_cv_type_sig_atomic_t" = xyes; then :
+if test "x$ac_cv_type_sig_atomic_t" = x""yes; then :
 
 cat >>confdefs.h <<_ACEOF
 #define HAVE_SIG_ATOMIC_T 1
@@ -12203,7 +12270,7 @@ ac_fn_c_check_type "$LINENO" "fsblkcnt_t" "ac_cv_type_fsblkcnt_t" "
 #endif
 
 "
-if test "x$ac_cv_type_fsblkcnt_t" = xyes; then :
+if test "x$ac_cv_type_fsblkcnt_t" = x""yes; then :
 
 cat >>confdefs.h <<_ACEOF
 #define HAVE_FSBLKCNT_T 1
@@ -12224,7 +12291,7 @@ ac_fn_c_check_type "$LINENO" "fsfilcnt_t" "ac_cv_type_fsfilcnt_t" "
 #endif
 
 "
-if test "x$ac_cv_type_fsfilcnt_t" = xyes; then :
+if test "x$ac_cv_type_fsfilcnt_t" = x""yes; then :
 
 cat >>confdefs.h <<_ACEOF
 #define HAVE_FSFILCNT_T 1
@@ -12237,7 +12304,7 @@ fi
 ac_fn_c_check_type "$LINENO" "in_addr_t" "ac_cv_type_in_addr_t" "#include <sys/types.h>
 #include <netinet/in.h>
 "
-if test "x$ac_cv_type_in_addr_t" = xyes; then :
+if test "x$ac_cv_type_in_addr_t" = x""yes; then :
 
 cat >>confdefs.h <<_ACEOF
 #define HAVE_IN_ADDR_T 1
@@ -12248,7 +12315,7 @@ fi
 ac_fn_c_check_type "$LINENO" "in_port_t" "ac_cv_type_in_port_t" "#include <sys/types.h>
 #include <netinet/in.h>
 "
-if test "x$ac_cv_type_in_port_t" = xyes; then :
+if test "x$ac_cv_type_in_port_t" = x""yes; then :
 
 cat >>confdefs.h <<_ACEOF
 #define HAVE_IN_PORT_T 1
@@ -12260,7 +12327,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for size_t" >&5
 $as_echo_n "checking for size_t... " >&6; }
-if ${ac_cv_have_size_t+:} false; then :
+if test "${ac_cv_have_size_t+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -12294,7 +12361,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ssize_t" >&5
 $as_echo_n "checking for ssize_t... " >&6; }
-if ${ac_cv_have_ssize_t+:} false; then :
+if test "${ac_cv_have_ssize_t+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -12328,7 +12395,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for clock_t" >&5
 $as_echo_n "checking for clock_t... " >&6; }
-if ${ac_cv_have_clock_t+:} false; then :
+if test "${ac_cv_have_clock_t+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -12362,7 +12429,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for sa_family_t" >&5
 $as_echo_n "checking for sa_family_t... " >&6; }
-if ${ac_cv_have_sa_family_t+:} false; then :
+if test "${ac_cv_have_sa_family_t+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -12420,7 +12487,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pid_t" >&5
 $as_echo_n "checking for pid_t... " >&6; }
-if ${ac_cv_have_pid_t+:} false; then :
+if test "${ac_cv_have_pid_t+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -12454,7 +12521,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for mode_t" >&5
 $as_echo_n "checking for mode_t... " >&6; }
-if ${ac_cv_have_mode_t+:} false; then :
+if test "${ac_cv_have_mode_t+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -12489,7 +12556,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for struct sockaddr_storage" >&5
 $as_echo_n "checking for struct sockaddr_storage... " >&6; }
-if ${ac_cv_have_struct_sockaddr_storage+:} false; then :
+if test "${ac_cv_have_struct_sockaddr_storage+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -12526,7 +12593,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for struct sockaddr_in6" >&5
 $as_echo_n "checking for struct sockaddr_in6... " >&6; }
-if ${ac_cv_have_struct_sockaddr_in6+:} false; then :
+if test "${ac_cv_have_struct_sockaddr_in6+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -12563,7 +12630,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for struct in6_addr" >&5
 $as_echo_n "checking for struct in6_addr... " >&6; }
-if ${ac_cv_have_struct_in6_addr+:} false; then :
+if test "${ac_cv_have_struct_in6_addr+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -12604,7 +12671,7 @@ $as_echo "#define HAVE_STRUCT_IN6_ADDR 1" >>confdefs.h
 #include <netinet/in.h>
 
 "
-if test "x$ac_cv_member_struct_sockaddr_in6_sin6_scope_id" = xyes; then :
+if test "x$ac_cv_member_struct_sockaddr_in6_sin6_scope_id" = x""yes; then :
 
 cat >>confdefs.h <<_ACEOF
 #define HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID 1
@@ -12617,7 +12684,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for struct addrinfo" >&5
 $as_echo_n "checking for struct addrinfo... " >&6; }
-if ${ac_cv_have_struct_addrinfo+:} false; then :
+if test "${ac_cv_have_struct_addrinfo+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -12655,7 +12722,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for struct timeval" >&5
 $as_echo_n "checking for struct timeval... " >&6; }
-if ${ac_cv_have_struct_timeval+:} false; then :
+if test "${ac_cv_have_struct_timeval+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -12689,7 +12756,7 @@ $as_echo "#define HAVE_STRUCT_TIMEVAL 1" >>confdefs.h
 fi
 
 ac_fn_c_check_type "$LINENO" "struct timespec" "ac_cv_type_struct_timespec" "$ac_includes_default"
-if test "x$ac_cv_type_struct_timespec" = xyes; then :
+if test "x$ac_cv_type_struct_timespec" = x""yes; then :
 
 cat >>confdefs.h <<_ACEOF
 #define HAVE_STRUCT_TIMESPEC 1
@@ -12758,7 +12825,7 @@ fi
 		ossh_varname="ossh_cv_$ossh_safe""_has_"ut_host
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ut_host field in utmp.h" >&5
 $as_echo_n "checking for ut_host field in utmp.h... " >&6; }
-	if eval \${$ossh_varname+:} false; then :
+	if eval "test \"\${$ossh_varname+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -12797,7 +12864,7 @@ $as_echo "no" >&6; }
 		ossh_varname="ossh_cv_$ossh_safe""_has_"ut_host
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ut_host field in utmpx.h" >&5
 $as_echo_n "checking for ut_host field in utmpx.h... " >&6; }
-	if eval \${$ossh_varname+:} false; then :
+	if eval "test \"\${$ossh_varname+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -12836,7 +12903,7 @@ $as_echo "no" >&6; }
 		ossh_varname="ossh_cv_$ossh_safe""_has_"syslen
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for syslen field in utmpx.h" >&5
 $as_echo_n "checking for syslen field in utmpx.h... " >&6; }
-	if eval \${$ossh_varname+:} false; then :
+	if eval "test \"\${$ossh_varname+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -12875,7 +12942,7 @@ $as_echo "no" >&6; }
 		ossh_varname="ossh_cv_$ossh_safe""_has_"ut_pid
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ut_pid field in utmp.h" >&5
 $as_echo_n "checking for ut_pid field in utmp.h... " >&6; }
-	if eval \${$ossh_varname+:} false; then :
+	if eval "test \"\${$ossh_varname+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -12914,7 +12981,7 @@ $as_echo "no" >&6; }
 		ossh_varname="ossh_cv_$ossh_safe""_has_"ut_type
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ut_type field in utmp.h" >&5
 $as_echo_n "checking for ut_type field in utmp.h... " >&6; }
-	if eval \${$ossh_varname+:} false; then :
+	if eval "test \"\${$ossh_varname+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -12953,7 +13020,7 @@ $as_echo "no" >&6; }
 		ossh_varname="ossh_cv_$ossh_safe""_has_"ut_type
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ut_type field in utmpx.h" >&5
 $as_echo_n "checking for ut_type field in utmpx.h... " >&6; }
-	if eval \${$ossh_varname+:} false; then :
+	if eval "test \"\${$ossh_varname+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -12992,7 +13059,7 @@ $as_echo "no" >&6; }
 		ossh_varname="ossh_cv_$ossh_safe""_has_"ut_tv
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ut_tv field in utmp.h" >&5
 $as_echo_n "checking for ut_tv field in utmp.h... " >&6; }
-	if eval \${$ossh_varname+:} false; then :
+	if eval "test \"\${$ossh_varname+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -13031,7 +13098,7 @@ $as_echo "no" >&6; }
 		ossh_varname="ossh_cv_$ossh_safe""_has_"ut_id
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ut_id field in utmp.h" >&5
 $as_echo_n "checking for ut_id field in utmp.h... " >&6; }
-	if eval \${$ossh_varname+:} false; then :
+	if eval "test \"\${$ossh_varname+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -13070,7 +13137,7 @@ $as_echo "no" >&6; }
 		ossh_varname="ossh_cv_$ossh_safe""_has_"ut_id
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ut_id field in utmpx.h" >&5
 $as_echo_n "checking for ut_id field in utmpx.h... " >&6; }
-	if eval \${$ossh_varname+:} false; then :
+	if eval "test \"\${$ossh_varname+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -13109,7 +13176,7 @@ $as_echo "no" >&6; }
 		ossh_varname="ossh_cv_$ossh_safe""_has_"ut_addr
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ut_addr field in utmp.h" >&5
 $as_echo_n "checking for ut_addr field in utmp.h... " >&6; }
-	if eval \${$ossh_varname+:} false; then :
+	if eval "test \"\${$ossh_varname+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -13148,7 +13215,7 @@ $as_echo "no" >&6; }
 		ossh_varname="ossh_cv_$ossh_safe""_has_"ut_addr
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ut_addr field in utmpx.h" >&5
 $as_echo_n "checking for ut_addr field in utmpx.h... " >&6; }
-	if eval \${$ossh_varname+:} false; then :
+	if eval "test \"\${$ossh_varname+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -13187,7 +13254,7 @@ $as_echo "no" >&6; }
 		ossh_varname="ossh_cv_$ossh_safe""_has_"ut_addr_v6
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ut_addr_v6 field in utmp.h" >&5
 $as_echo_n "checking for ut_addr_v6 field in utmp.h... " >&6; }
-	if eval \${$ossh_varname+:} false; then :
+	if eval "test \"\${$ossh_varname+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -13226,7 +13293,7 @@ $as_echo "no" >&6; }
 		ossh_varname="ossh_cv_$ossh_safe""_has_"ut_addr_v6
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ut_addr_v6 field in utmpx.h" >&5
 $as_echo_n "checking for ut_addr_v6 field in utmpx.h... " >&6; }
-	if eval \${$ossh_varname+:} false; then :
+	if eval "test \"\${$ossh_varname+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -13265,7 +13332,7 @@ $as_echo "no" >&6; }
 		ossh_varname="ossh_cv_$ossh_safe""_has_"ut_exit
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ut_exit field in utmp.h" >&5
 $as_echo_n "checking for ut_exit field in utmp.h... " >&6; }
-	if eval \${$ossh_varname+:} false; then :
+	if eval "test \"\${$ossh_varname+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -13304,7 +13371,7 @@ $as_echo "no" >&6; }
 		ossh_varname="ossh_cv_$ossh_safe""_has_"ut_time
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ut_time field in utmp.h" >&5
 $as_echo_n "checking for ut_time field in utmp.h... " >&6; }
-	if eval \${$ossh_varname+:} false; then :
+	if eval "test \"\${$ossh_varname+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -13343,7 +13410,7 @@ $as_echo "no" >&6; }
 		ossh_varname="ossh_cv_$ossh_safe""_has_"ut_time
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ut_time field in utmpx.h" >&5
 $as_echo_n "checking for ut_time field in utmpx.h... " >&6; }
-	if eval \${$ossh_varname+:} false; then :
+	if eval "test \"\${$ossh_varname+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -13382,7 +13449,7 @@ $as_echo "no" >&6; }
 		ossh_varname="ossh_cv_$ossh_safe""_has_"ut_tv
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ut_tv field in utmpx.h" >&5
 $as_echo_n "checking for ut_tv field in utmpx.h... " >&6; }
-	if eval \${$ossh_varname+:} false; then :
+	if eval "test \"\${$ossh_varname+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -13417,7 +13484,7 @@ $as_echo "no" >&6; }
 
 
 ac_fn_c_check_member "$LINENO" "struct stat" "st_blksize" "ac_cv_member_struct_stat_st_blksize" "$ac_includes_default"
-if test "x$ac_cv_member_struct_stat_st_blksize" = xyes; then :
+if test "x$ac_cv_member_struct_stat_st_blksize" = x""yes; then :
 
 cat >>confdefs.h <<_ACEOF
 #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
@@ -13436,7 +13503,7 @@ ac_fn_c_check_member "$LINENO" "struct __res_state" "retrans" "ac_cv_member_stru
 #include <resolv.h>
 
 "
-if test "x$ac_cv_member_struct___res_state_retrans" = xyes; then :
+if test "x$ac_cv_member_struct___res_state_retrans" = x""yes; then :
 
 else
 
@@ -13447,7 +13514,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ss_family field in struct sockaddr_storage" >&5
 $as_echo_n "checking for ss_family field in struct sockaddr_storage... " >&6; }
-if ${ac_cv_have_ss_family_in_struct_ss+:} false; then :
+if test "${ac_cv_have_ss_family_in_struct_ss+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -13483,7 +13550,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for __ss_family field in struct sockaddr_storage" >&5
 $as_echo_n "checking for __ss_family field in struct sockaddr_storage... " >&6; }
-if ${ac_cv_have___ss_family_in_struct_ss+:} false; then :
+if test "${ac_cv_have___ss_family_in_struct_ss+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -13520,7 +13587,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pw_class field in struct passwd" >&5
 $as_echo_n "checking for pw_class field in struct passwd... " >&6; }
-if ${ac_cv_have_pw_class_in_struct_passwd+:} false; then :
+if test "${ac_cv_have_pw_class_in_struct_passwd+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -13554,7 +13621,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pw_expire field in struct passwd" >&5
 $as_echo_n "checking for pw_expire field in struct passwd... " >&6; }
-if ${ac_cv_have_pw_expire_in_struct_passwd+:} false; then :
+if test "${ac_cv_have_pw_expire_in_struct_passwd+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -13588,7 +13655,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pw_change field in struct passwd" >&5
 $as_echo_n "checking for pw_change field in struct passwd... " >&6; }
-if ${ac_cv_have_pw_change_in_struct_passwd+:} false; then :
+if test "${ac_cv_have_pw_change_in_struct_passwd+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -13622,7 +13689,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for msg_accrights field in struct msghdr" >&5
 $as_echo_n "checking for msg_accrights field in struct msghdr... " >&6; }
-if ${ac_cv_have_accrights_in_msghdr+:} false; then :
+if test "${ac_cv_have_accrights_in_msghdr+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -13759,7 +13826,7 @@ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for msg_control field in struct msghdr" >&5
 $as_echo_n "checking for msg_control field in struct msghdr... " >&6; }
-if ${ac_cv_have_control_in_msghdr+:} false; then :
+if test "${ac_cv_have_control_in_msghdr+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -13805,7 +13872,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking if libc defines __progname" >&5
 $as_echo_n "checking if libc defines __progname... " >&6; }
-if ${ac_cv_libc_defines___progname+:} false; then :
+if test "${ac_cv_libc_defines___progname+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -13840,7 +13907,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC implements __FUNCTION__" >&5
 $as_echo_n "checking whether $CC implements __FUNCTION__... " >&6; }
-if ${ac_cv_cc_implements___FUNCTION__+:} false; then :
+if test "${ac_cv_cc_implements___FUNCTION__+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -13875,7 +13942,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC implements __func__" >&5
 $as_echo_n "checking whether $CC implements __func__... " >&6; }
-if ${ac_cv_cc_implements___func__+:} false; then :
+if test "${ac_cv_cc_implements___func__+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -13910,7 +13977,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether va_copy exists" >&5
 $as_echo_n "checking whether va_copy exists... " >&6; }
-if ${ac_cv_have_va_copy+:} false; then :
+if test "${ac_cv_have_va_copy+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -13948,7 +14015,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether __va_copy exists" >&5
 $as_echo_n "checking whether __va_copy exists... " >&6; }
-if ${ac_cv_have___va_copy+:} false; then :
+if test "${ac_cv_have___va_copy+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -13986,7 +14053,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether getopt has optreset support" >&5
 $as_echo_n "checking whether getopt has optreset support... " >&6; }
-if ${ac_cv_have_getopt_optreset+:} false; then :
+if test "${ac_cv_have_getopt_optreset+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -14021,7 +14088,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking if libc defines sys_errlist" >&5
 $as_echo_n "checking if libc defines sys_errlist... " >&6; }
-if ${ac_cv_libc_defines_sys_errlist+:} false; then :
+if test "${ac_cv_libc_defines_sys_errlist+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -14057,7 +14124,7 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking if libc defines sys_nerr" >&5
 $as_echo_n "checking if libc defines sys_nerr... " >&6; }
-if ${ac_cv_libc_defines_sys_nerr+:} false; then :
+if test "${ac_cv_libc_defines_sys_nerr+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -14090,10 +14157,18 @@ $as_echo "#define HAVE_SYS_NERR 1" >>confdefs.h
 
 fi
 
+#
+# NX_WIN32_FIXME
+#
+
 # Check libraries needed by DNS fingerprint support
+case "$host" in
+*-*-mingw32*)
+      ;;
+*)
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing getrrsetbyname" >&5
 $as_echo_n "checking for library containing getrrsetbyname... " >&6; }
-if ${ac_cv_search_getrrsetbyname+:} false; then :
+if test "${ac_cv_search_getrrsetbyname+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_func_search_save_LIBS=$LIBS
@@ -14127,11 +14202,11 @@ for ac_lib in '' resolv; do
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext
-  if ${ac_cv_search_getrrsetbyname+:} false; then :
+  if test "${ac_cv_search_getrrsetbyname+set}" = set; then :
   break
 fi
 done
-if ${ac_cv_search_getrrsetbyname+:} false; then :
+if test "${ac_cv_search_getrrsetbyname+set}" = set; then :
 
 else
   ac_cv_search_getrrsetbyname=no
@@ -14152,7 +14227,7 @@ else
 		# Needed by our getrrsetbyname()
 		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing res_query" >&5
 $as_echo_n "checking for library containing res_query... " >&6; }
-if ${ac_cv_search_res_query+:} false; then :
+if test "${ac_cv_search_res_query+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_func_search_save_LIBS=$LIBS
@@ -14186,11 +14261,11 @@ for ac_lib in '' resolv; do
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext
-  if ${ac_cv_search_res_query+:} false; then :
+  if test "${ac_cv_search_res_query+set}" = set; then :
   break
 fi
 done
-if ${ac_cv_search_res_query+:} false; then :
+if test "${ac_cv_search_res_query+set}" = set; then :
 
 else
   ac_cv_search_res_query=no
@@ -14208,7 +14283,7 @@ fi
 
 		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing dn_expand" >&5
 $as_echo_n "checking for library containing dn_expand... " >&6; }
-if ${ac_cv_search_dn_expand+:} false; then :
+if test "${ac_cv_search_dn_expand+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_func_search_save_LIBS=$LIBS
@@ -14242,11 +14317,11 @@ for ac_lib in '' resolv; do
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext
-  if ${ac_cv_search_dn_expand+:} false; then :
+  if test "${ac_cv_search_dn_expand+set}" = set; then :
   break
 fi
 done
-if ${ac_cv_search_dn_expand+:} false; then :
+if test "${ac_cv_search_dn_expand+set}" = set; then :
 
 else
   ac_cv_search_dn_expand=no
@@ -14341,7 +14416,7 @@ done
 		ac_fn_c_check_decl "$LINENO" "_getshort" "ac_cv_have_decl__getshort" "#include <sys/types.h>
 		    #include <arpa/nameser.h>
 "
-if test "x$ac_cv_have_decl__getshort" = xyes; then :
+if test "x$ac_cv_have_decl__getshort" = x""yes; then :
   ac_have_decl=1
 else
   ac_have_decl=0
@@ -14353,7 +14428,7 @@ _ACEOF
 ac_fn_c_check_decl "$LINENO" "_getlong" "ac_cv_have_decl__getlong" "#include <sys/types.h>
 		    #include <arpa/nameser.h>
 "
-if test "x$ac_cv_have_decl__getlong" = xyes; then :
+if test "x$ac_cv_have_decl__getlong" = x""yes; then :
   ac_have_decl=1
 else
   ac_have_decl=0
@@ -14365,7 +14440,7 @@ _ACEOF
 
 		ac_fn_c_check_member "$LINENO" "HEADER" "ad" "ac_cv_member_HEADER_ad" "#include <arpa/nameser.h>
 "
-if test "x$ac_cv_member_HEADER_ad" = xyes; then :
+if test "x$ac_cv_member_HEADER_ad" = x""yes; then :
 
 $as_echo "#define HAVE_HEADER_AD 1" >>confdefs.h
 
@@ -14374,6 +14449,12 @@ fi
 
 fi
 
+  ;;
+esac
+
+#
+# END FIXME
+#
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking if struct __res_state _res is an extern" >&5
 $as_echo_n "checking if struct __res_state _res is an extern... " >&6; }
@@ -14425,7 +14506,7 @@ $as_echo "#define WITH_SELINUX 1" >>confdefs.h
 
 		SELINUX_MSG="yes"
 		ac_fn_c_check_header_mongrel "$LINENO" "selinux/selinux.h" "ac_cv_header_selinux_selinux_h" "$ac_includes_default"
-if test "x$ac_cv_header_selinux_selinux_h" = xyes; then :
+if test "x$ac_cv_header_selinux_selinux_h" = x""yes; then :
 
 else
   as_fn_error $? "SELinux support requires selinux.h header" "$LINENO" 5
@@ -14434,7 +14515,7 @@ fi
 
 		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for setexeccon in -lselinux" >&5
 $as_echo_n "checking for setexeccon in -lselinux... " >&6; }
-if ${ac_cv_lib_selinux_setexeccon+:} false; then :
+if test "${ac_cv_lib_selinux_setexeccon+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -14468,7 +14549,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_selinux_setexeccon" >&5
 $as_echo "$ac_cv_lib_selinux_setexeccon" >&6; }
-if test "x$ac_cv_lib_selinux_setexeccon" = xyes; then :
+if test "x$ac_cv_lib_selinux_setexeccon" = x""yes; then :
    LIBSELINUX="-lselinux"
 			  LIBS="$LIBS -lselinux"
 
@@ -14515,11 +14596,32 @@ $as_echo "#define KRB5 1" >>confdefs.h
 
 		KRB5_MSG="yes"
 
+
+#
+# NX_WIN32_FIXME
+#
+
+#
+# We have no krb5-config on Windows.
+# Dont link to kerberos libs, becouse we loads
+# them in runtime.
+#
+
+if test "$SkipGssapiLibsCheck" = "1" ; then
+
+
+$as_echo "#define GSSAPI 1" >>confdefs.h
+
+
+  CFLAGS="$CFLAGS -I$KRB5ROOT"
+
+else
+
 		# Extract the first word of "krb5-config", so it can be a program name with args.
 set dummy krb5-config; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_KRB5CONF+:} false; then :
+if test "${ac_cv_path_KRB5CONF+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $KRB5CONF in
@@ -14628,7 +14730,7 @@ $as_echo "yes" >&6; }
 					 K5LIBS="$K5LIBS -lcom_err -lasn1"
 					 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for net_write in -lroken" >&5
 $as_echo_n "checking for net_write in -lroken... " >&6; }
-if ${ac_cv_lib_roken_net_write+:} false; then :
+if test "${ac_cv_lib_roken_net_write+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -14662,13 +14764,13 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_roken_net_write" >&5
 $as_echo "$ac_cv_lib_roken_net_write" >&6; }
-if test "x$ac_cv_lib_roken_net_write" = xyes; then :
+if test "x$ac_cv_lib_roken_net_write" = x""yes; then :
   K5LIBS="$K5LIBS -lroken"
 fi
 
 					 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for des_cbc_encrypt in -ldes" >&5
 $as_echo_n "checking for des_cbc_encrypt in -ldes... " >&6; }
-if ${ac_cv_lib_des_des_cbc_encrypt+:} false; then :
+if test "${ac_cv_lib_des_des_cbc_encrypt+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -14702,7 +14804,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_des_des_cbc_encrypt" >&5
 $as_echo "$ac_cv_lib_des_des_cbc_encrypt" >&6; }
-if test "x$ac_cv_lib_des_des_cbc_encrypt" = xyes; then :
+if test "x$ac_cv_lib_des_des_cbc_encrypt" = x""yes; then :
   K5LIBS="$K5LIBS -ldes"
 fi
 
@@ -14717,7 +14819,7 @@ fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 			{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing dn_expand" >&5
 $as_echo_n "checking for library containing dn_expand... " >&6; }
-if ${ac_cv_search_dn_expand+:} false; then :
+if test "${ac_cv_search_dn_expand+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_func_search_save_LIBS=$LIBS
@@ -14751,11 +14853,11 @@ for ac_lib in '' resolv; do
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext
-  if ${ac_cv_search_dn_expand+:} false; then :
+  if test "${ac_cv_search_dn_expand+set}" = set; then :
   break
 fi
 done
-if ${ac_cv_search_dn_expand+:} false; then :
+if test "${ac_cv_search_dn_expand+set}" = set; then :
 
 else
   ac_cv_search_dn_expand=no
@@ -14774,7 +14876,7 @@ fi
 
 			{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for gss_init_sec_context in -lgssapi_krb5" >&5
 $as_echo_n "checking for gss_init_sec_context in -lgssapi_krb5... " >&6; }
-if ${ac_cv_lib_gssapi_krb5_gss_init_sec_context+:} false; then :
+if test "${ac_cv_lib_gssapi_krb5_gss_init_sec_context+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -14808,14 +14910,14 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gssapi_krb5_gss_init_sec_context" >&5
 $as_echo "$ac_cv_lib_gssapi_krb5_gss_init_sec_context" >&6; }
-if test "x$ac_cv_lib_gssapi_krb5_gss_init_sec_context" = xyes; then :
+if test "x$ac_cv_lib_gssapi_krb5_gss_init_sec_context" = x""yes; then :
    $as_echo "#define GSSAPI 1" >>confdefs.h
 
 				  K5LIBS="-lgssapi_krb5 $K5LIBS"
 else
    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for gss_init_sec_context in -lgssapi" >&5
 $as_echo_n "checking for gss_init_sec_context in -lgssapi... " >&6; }
-if ${ac_cv_lib_gssapi_gss_init_sec_context+:} false; then :
+if test "${ac_cv_lib_gssapi_gss_init_sec_context+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -14849,7 +14951,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gssapi_gss_init_sec_context" >&5
 $as_echo "$ac_cv_lib_gssapi_gss_init_sec_context" >&6; }
-if test "x$ac_cv_lib_gssapi_gss_init_sec_context" = xyes; then :
+if test "x$ac_cv_lib_gssapi_gss_init_sec_context" = x""yes; then :
    $as_echo "#define GSSAPI 1" >>confdefs.h
 
 					  K5LIBS="-lgssapi $K5LIBS"
@@ -14862,8 +14964,14 @@ fi
 fi
 
 
+fi
+
+#
+# END FIXME
+#
+
 			ac_fn_c_check_header_mongrel "$LINENO" "gssapi.h" "ac_cv_header_gssapi_h" "$ac_includes_default"
-if test "x$ac_cv_header_gssapi_h" = xyes; then :
+if test "x$ac_cv_header_gssapi_h" = x""yes; then :
 
 else
    unset ac_cv_header_gssapi_h
@@ -14871,7 +14979,7 @@ else
 				  for ac_header in gssapi.h
 do :
   ac_fn_c_check_header_mongrel "$LINENO" "gssapi.h" "ac_cv_header_gssapi_h" "$ac_includes_default"
-if test "x$ac_cv_header_gssapi_h" = xyes; then :
+if test "x$ac_cv_header_gssapi_h" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_GSSAPI_H 1
 _ACEOF
@@ -14893,7 +15001,7 @@ fi
 			oldCPP="$CPPFLAGS"
 			CPPFLAGS="$CPPFLAGS -I${KRB5ROOT}/include/gssapi"
 			ac_fn_c_check_header_mongrel "$LINENO" "gssapi_krb5.h" "ac_cv_header_gssapi_krb5_h" "$ac_includes_default"
-if test "x$ac_cv_header_gssapi_krb5_h" = xyes; then :
+if test "x$ac_cv_header_gssapi_krb5_h" = x""yes; then :
 
 else
    CPPFLAGS="$oldCPP"
@@ -14909,6 +15017,59 @@ fi
 			blibpath="$blibpath:${KRB5ROOT}/lib"
 		fi
 
+#
+# Fix header found, but not usable on MinGW.
+#
+
+ case "$host" in
+ *-*-mingw32*)
+
+    for ac_header in gssapi.h gssapi/gssapi.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" " #define _W64 long long
+"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+    for ac_header in gssapi_krb5.h gssapi/gssapi_krb5.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" " #define _W64 long long
+"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+    for ac_header in gssapi_generic.h gssapi/gssapi_generic.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" " #define _W64 long long
+"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+       ;;
+ *)
+
 		for ac_header in gssapi.h gssapi/gssapi.h
 do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
@@ -14922,7 +15083,7 @@ fi
 
 done
 
-		for ac_header in gssapi_krb5.h gssapi/gssapi_krb5.h
+	for ac_header in gssapi_krb5.h gssapi/gssapi_krb5.h
 do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
@@ -14949,10 +15110,15 @@ fi
 done
 
 
+       ;;
+ esac
+
+
+
 		LIBS="$LIBS $K5LIBS"
 		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing k_hasafs" >&5
 $as_echo_n "checking for library containing k_hasafs... " >&6; }
-if ${ac_cv_search_k_hasafs+:} false; then :
+if test "${ac_cv_search_k_hasafs+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_func_search_save_LIBS=$LIBS
@@ -14986,11 +15152,11 @@ for ac_lib in '' kafs; do
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext
-  if ${ac_cv_search_k_hasafs+:} false; then :
+  if test "${ac_cv_search_k_hasafs+set}" = set; then :
   break
 fi
 done
-if ${ac_cv_search_k_hasafs+:} false; then :
+if test "${ac_cv_search_k_hasafs+set}" = set; then :
 
 else
   ac_cv_search_k_hasafs=no
@@ -15051,7 +15217,7 @@ else
 set dummy xauth; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_xauth_path+:} false; then :
+if test "${ac_cv_path_xauth_path+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $xauth_path in
@@ -15245,7 +15411,7 @@ if test -z "$no_dev_ptmx" ; then
 		as_ac_File=`$as_echo "ac_cv_file_"/dev/ptmx"" | $as_tr_sh`
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for \"/dev/ptmx\"" >&5
 $as_echo_n "checking for \"/dev/ptmx\"... " >&6; }
-if eval \${$as_ac_File+:} false; then :
+if eval "test \"\${$as_ac_File+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   test "$cross_compiling" = yes &&
@@ -15278,7 +15444,7 @@ if test ! -z "$cross_compiling" && test "x$cross_compiling" != "xyes"; then
 	as_ac_File=`$as_echo "ac_cv_file_"/dev/ptc"" | $as_tr_sh`
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for \"/dev/ptc\"" >&5
 $as_echo_n "checking for \"/dev/ptc\"... " >&6; }
-if eval \${$as_ac_File+:} false; then :
+if eval "test \"\${$as_ac_File+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   test "$cross_compiling" = yes &&
@@ -15334,7 +15500,7 @@ do
 set dummy $ac_prog; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_NROFF+:} false; then :
+if test "${ac_cv_path_NROFF+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $NROFF in
@@ -15507,7 +15673,7 @@ if test "x$etc_default_login" != "xno"; then
 	as_ac_File=`$as_echo "ac_cv_file_"/etc/default/login"" | $as_tr_sh`
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for \"/etc/default/login\"" >&5
 $as_echo_n "checking for \"/etc/default/login\"... " >&6; }
-if eval \${$as_ac_File+:} false; then :
+if eval "test \"\${$as_ac_File+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   test "$cross_compiling" = yes &&
@@ -16120,13 +16286,52 @@ fi
 
 CFLAGS="$CFLAGS $werror_flags"
 
+#
+# NX_WIN3_FIXME
+#
+
+case "$host" in
+*-*-mingw32*)
+	;;
+*)
+
+$as_echo "#define HAVE_TTY 1" >>confdefs.h
+
+
+$as_echo "#define HAVE_PRIV_CONCEPT 1" >>confdefs.h
+
+
+$as_echo "#define USE_SANITISE_STDFD 1" >>confdefs.h
+
+	;;
+esac
+
+
+
+
+
+case "$host" in
+*-*-mingw32*)
+	LINKWIN32COMPAT="-lwin32compat"
+	LIBWIN32COMPAT="libwin32compat.a"
+	LIBWIN32COMPATDEPEND="contrib/win32/win32compat/libwin32compat.a"
+	WIN32COMPAT="win32compat"
+	;;
+*)
+	;;
+esac
+
+#
+# End of NX_WIN32_FIXME.
+#
+
 if test "x$ac_cv_func_getaddrinfo" != "xyes" ; then
 	TEST_SSH_IPV6=no
 else
 	TEST_SSH_IPV6=yes
 fi
 ac_fn_c_check_decl "$LINENO" "BROKEN_GETADDRINFO" "ac_cv_have_decl_BROKEN_GETADDRINFO" "$ac_includes_default"
-if test "x$ac_cv_have_decl_BROKEN_GETADDRINFO" = xyes; then :
+if test "x$ac_cv_have_decl_BROKEN_GETADDRINFO" = x""yes; then :
   TEST_SSH_IPV6=no
 fi
 
@@ -16134,7 +16339,29 @@ TEST_SSH_IPV6=$TEST_SSH_IPV6
 
 
 
-ac_config_files="$ac_config_files Makefile buildpkg.sh opensshd.init openssh.xml openbsd-compat/Makefile openbsd-compat/regress/Makefile survey.sh"
+
+#
+# NX_WIN32_FIXME
+#
+
+files="Makefile buildpkg.sh opensshd.init openssh.xml \
+       openbsd-compat/Makefile openbsd-compat/regress/Makefile \
+       survey.sh"
+
+case "$host" in
+*-*-mingw32*)
+      files="$files contrib/win32/win32compat/Makefile"
+      ;;
+*)
+      ;;
+esac
+
+ac_config_files="$ac_config_files $files"
+
+
+#
+# END FIXME
+#
 
 cat >confcache <<\_ACEOF
 # This file is a shell script that caches the results of configure
@@ -16200,21 +16427,10 @@ $as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
      :end' >>confcache
 if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
   if test -w "$cache_file"; then
-    if test "x$cache_file" != "x/dev/null"; then
+    test "x$cache_file" != "x/dev/null" &&
       { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
 $as_echo "$as_me: updating cache $cache_file" >&6;}
-      if test ! -f "$cache_file" || test -h "$cache_file"; then
-	cat confcache >"$cache_file"
-      else
-        case $cache_file in #(
-        */* | ?:*)
-	  mv -f confcache "$cache_file"$$ &&
-	  mv -f "$cache_file"$$ "$cache_file" ;; #(
-        *)
-	  mv -f confcache "$cache_file" ;;
-	esac
-      fi
-    fi
+    cat confcache >$cache_file
   else
     { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
 $as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
@@ -16247,7 +16463,7 @@ LTLIBOBJS=$ac_ltlibobjs
 
 
 
-: "${CONFIG_STATUS=./config.status}"
+: ${CONFIG_STATUS=./config.status}
 ac_write_fail=0
 ac_clean_files_save=$ac_clean_files
 ac_clean_files="$ac_clean_files $CONFIG_STATUS"
@@ -16348,7 +16564,6 @@ fi
 IFS=" ""	$as_nl"
 
 # Find who we are.  Look in the path if we contain no directory separator.
-as_myself=
 case $0 in #((
   *[\\/]* ) as_myself=$0 ;;
   *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
@@ -16656,7 +16871,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # values after options handling.
 ac_log="
 This file was extended by OpenSSH $as_me Portable, which was
-generated by GNU Autoconf 2.68.  Invocation command line was
+generated by GNU Autoconf 2.67.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
@@ -16718,7 +16933,7 @@ cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
 OpenSSH config.status Portable
-configured by $0, generated by GNU Autoconf 2.68,
+configured by $0, generated by GNU Autoconf 2.67,
   with options \\"\$ac_cs_config\\"
 
 Copyright (C) 2010 Free Software Foundation, Inc.
@@ -16841,15 +17056,9 @@ for ac_config_target in $ac_config_targets
 do
   case $ac_config_target in
     "config.h") CONFIG_HEADERS="$CONFIG_HEADERS config.h" ;;
-    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
-    "buildpkg.sh") CONFIG_FILES="$CONFIG_FILES buildpkg.sh" ;;
-    "opensshd.init") CONFIG_FILES="$CONFIG_FILES opensshd.init" ;;
-    "openssh.xml") CONFIG_FILES="$CONFIG_FILES openssh.xml" ;;
-    "openbsd-compat/Makefile") CONFIG_FILES="$CONFIG_FILES openbsd-compat/Makefile" ;;
-    "openbsd-compat/regress/Makefile") CONFIG_FILES="$CONFIG_FILES openbsd-compat/regress/Makefile" ;;
-    "survey.sh") CONFIG_FILES="$CONFIG_FILES survey.sh" ;;
-
-  *) as_fn_error $? "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
+    "$files") CONFIG_FILES="$CONFIG_FILES $files" ;;
+
+  *) as_fn_error $? "invalid argument: \`$ac_config_target'" "$LINENO" 5 ;;
   esac
 done
 
@@ -16871,10 +17080,9 @@ fi
 # after its creation but before its name has been assigned to `$tmp'.
 $debug ||
 {
-  tmp= ac_tmp=
+  tmp=
   trap 'exit_status=$?
-  : "${ac_tmp:=$tmp}"
-  { test ! -d "$ac_tmp" || rm -fr "$ac_tmp"; } && exit $exit_status
+  { test -z "$tmp" || test ! -d "$tmp" || rm -fr "$tmp"; } && exit $exit_status
 ' 0
   trap 'as_fn_exit 1' 1 2 13 15
 }
@@ -16882,13 +17090,12 @@ $debug ||
 
 {
   tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
-  test -d "$tmp"
+  test -n "$tmp" && test -d "$tmp"
 }  ||
 {
   tmp=./conf$$-$RANDOM
   (umask 077 && mkdir "$tmp")
 } || as_fn_error $? "cannot create a temporary directory in ." "$LINENO" 5
-ac_tmp=$tmp
 
 # Set up the scripts for CONFIG_FILES section.
 # No need to generate them if there are no CONFIG_FILES.
@@ -16910,7 +17117,7 @@ else
   ac_cs_awk_cr=$ac_cr
 fi
 
-echo 'BEGIN {' >"$ac_tmp/subs1.awk" &&
+echo 'BEGIN {' >"$tmp/subs1.awk" &&
 _ACEOF
 
 
@@ -16938,7 +17145,7 @@ done
 rm -f conf$$subs.sh
 
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-cat >>"\$ac_tmp/subs1.awk" <<\\_ACAWK &&
+cat >>"\$tmp/subs1.awk" <<\\_ACAWK &&
 _ACEOF
 sed -n '
 h
@@ -16986,7 +17193,7 @@ t delim
 rm -f conf$$subs.awk
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 _ACAWK
-cat >>"\$ac_tmp/subs1.awk" <<_ACAWK &&
+cat >>"\$tmp/subs1.awk" <<_ACAWK &&
   for (key in S) S_is_set[key] = 1
   FS = ""
 
@@ -17018,7 +17225,7 @@ if sed "s/$ac_cr//" < /dev/null > /dev/null 2>&1; then
   sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
 else
   cat
-fi < "$ac_tmp/subs1.awk" > "$ac_tmp/subs.awk" \
+fi < "$tmp/subs1.awk" > "$tmp/subs.awk" \
   || as_fn_error $? "could not setup config files machinery" "$LINENO" 5
 _ACEOF
 
@@ -17052,7 +17259,7 @@ fi # test -n "$CONFIG_FILES"
 # No need to generate them if there are no CONFIG_HEADERS.
 # This happens for instance with `./config.status Makefile'.
 if test -n "$CONFIG_HEADERS"; then
-cat >"$ac_tmp/defines.awk" <<\_ACAWK ||
+cat >"$tmp/defines.awk" <<\_ACAWK ||
 BEGIN {
 _ACEOF
 
@@ -17064,8 +17271,8 @@ _ACEOF
 # handling of long lines.
 ac_delim='%!_!# '
 for ac_last_try in false false :; do
-  ac_tt=`sed -n "/$ac_delim/p" confdefs.h`
-  if test -z "$ac_tt"; then
+  ac_t=`sed -n "/$ac_delim/p" confdefs.h`
+  if test -z "$ac_t"; then
     break
   elif $ac_last_try; then
     as_fn_error $? "could not make $CONFIG_HEADERS" "$LINENO" 5
@@ -17166,7 +17373,7 @@ do
   esac
   case $ac_mode$ac_tag in
   :[FHL]*:*);;
-  :L* | :C*:*) as_fn_error $? "invalid tag \`$ac_tag'" "$LINENO" 5;;
+  :L* | :C*:*) as_fn_error $? "invalid tag \`$ac_tag'" "$LINENO" 5 ;;
   :[FH]-) ac_tag=-:-;;
   :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
   esac
@@ -17185,7 +17392,7 @@ do
     for ac_f
     do
       case $ac_f in
-      -) ac_f="$ac_tmp/stdin";;
+      -) ac_f="$tmp/stdin";;
       *) # Look for the file first in the build tree, then in the source tree
 	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
 	 # because $ac_f cannot contain `:'.
@@ -17194,7 +17401,7 @@ do
 	   [\\/$]*) false;;
 	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
 	   esac ||
-	   as_fn_error 1 "cannot find input file: \`$ac_f'" "$LINENO" 5;;
+	   as_fn_error 1 "cannot find input file: \`$ac_f'" "$LINENO" 5 ;;
       esac
       case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
       as_fn_append ac_file_inputs " '$ac_f'"
@@ -17220,8 +17427,8 @@ $as_echo "$as_me: creating $ac_file" >&6;}
     esac
 
     case $ac_tag in
-    *:-:* | *:-) cat >"$ac_tmp/stdin" \
-      || as_fn_error $? "could not create $ac_file" "$LINENO" 5 ;;
+    *:-:* | *:-) cat >"$tmp/stdin" \
+      || as_fn_error $? "could not create $ac_file" "$LINENO" 5  ;;
     esac
     ;;
   esac
@@ -17351,22 +17558,21 @@ s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
 s&@INSTALL@&$ac_INSTALL&;t t
 $ac_datarootdir_hack
 "
-eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$ac_tmp/subs.awk" \
-  >$ac_tmp/out || as_fn_error $? "could not create $ac_file" "$LINENO" 5
+eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$tmp/subs.awk" >$tmp/out \
+  || as_fn_error $? "could not create $ac_file" "$LINENO" 5
 
 test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
-  { ac_out=`sed -n '/\${datarootdir}/p' "$ac_tmp/out"`; test -n "$ac_out"; } &&
-  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' \
-      "$ac_tmp/out"`; test -z "$ac_out"; } &&
+  { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
+  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
   { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
 which seems to be undefined.  Please make sure it is defined" >&5
 $as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
 which seems to be undefined.  Please make sure it is defined" >&2;}
 
-  rm -f "$ac_tmp/stdin"
+  rm -f "$tmp/stdin"
   case $ac_file in
-  -) cat "$ac_tmp/out" && rm -f "$ac_tmp/out";;
-  *) rm -f "$ac_file" && mv "$ac_tmp/out" "$ac_file";;
+  -) cat "$tmp/out" && rm -f "$tmp/out";;
+  *) rm -f "$ac_file" && mv "$tmp/out" "$ac_file";;
   esac \
   || as_fn_error $? "could not create $ac_file" "$LINENO" 5
  ;;
@@ -17377,20 +17583,20 @@ which seems to be undefined.  Please make sure it is defined" >&2;}
   if test x"$ac_file" != x-; then
     {
       $as_echo "/* $configure_input  */" \
-      && eval '$AWK -f "$ac_tmp/defines.awk"' "$ac_file_inputs"
-    } >"$ac_tmp/config.h" \
+      && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs"
+    } >"$tmp/config.h" \
       || as_fn_error $? "could not create $ac_file" "$LINENO" 5
-    if diff "$ac_file" "$ac_tmp/config.h" >/dev/null 2>&1; then
+    if diff "$ac_file" "$tmp/config.h" >/dev/null 2>&1; then
       { $as_echo "$as_me:${as_lineno-$LINENO}: $ac_file is unchanged" >&5
 $as_echo "$as_me: $ac_file is unchanged" >&6;}
     else
       rm -f "$ac_file"
-      mv "$ac_tmp/config.h" "$ac_file" \
+      mv "$tmp/config.h" "$ac_file" \
 	|| as_fn_error $? "could not create $ac_file" "$LINENO" 5
     fi
   else
     $as_echo "/* $configure_input  */" \
-      && eval '$AWK -f "$ac_tmp/defines.awk"' "$ac_file_inputs" \
+      && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs" \
       || as_fn_error $? "could not create -" "$LINENO" 5
   fi
  ;;
diff --git a/configure.ac b/configure.ac
index 7a91527..2cd985e 100644
--- a/configure.ac
+++ b/configure.ac
@@ -15,6 +15,7 @@
 # OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
 AC_INIT([OpenSSH], [Portable], [openssh-unix-dev@mindrot.org])
+
 AC_REVISION($Revision: 1.480 $)
 AC_CONFIG_SRCDIR([ssh.c])
 AC_LANG([C])
@@ -489,6 +490,39 @@ case "$host" in
 	AC_DEFINE([BROKEN_SETREUID])
 	AC_DEFINE([BROKEN_SETREGID])
 	;;
+*-*-mingw32*)
+       LIBS="$LIBS -lws2_32 -lgdi32 -lNetAPI32 -luserenv -lsecur32 -lshlwapi"
+       CFLAGS="$CFLAGS -mno-cygwin -I$PWD/contrib/win32/win32compat/includes"
+       LDFLAGS="$LDFLAGS -mno-cygwin"
+       
+       AC_DEFINE(USE_PIPES, 1, [Use PIPES instead of a socketpair()])
+       AC_DEFINE(DISABLE_SHADOW, 1,
+               [Define if you want to disable shadow passwords])
+       AC_DEFINE(IP_TOS_IS_BROKEN, 1,
+               [Define if your system choked on IP TOS setting])
+       AC_DEFINE(NO_X11_UNIX_SOCKETS, 1,
+               [Define if X11 doesn't support AF_UNIX sockets on that system])
+       AC_DEFINE(NO_IPPORT_RESERVED_CONCEPT, 1,
+               [Define if the concept of ports only accessible to
+               superusers isn't known])
+       AC_DEFINE(DISABLE_FD_PASSING, 1,
+               [Define if your platform needs to skip post auth
+               file descriptor passing])
+       AC_DEFINE([DISABLE_UTMP], [1],
+               [Define if you don't want to use utmp])        
+       AC_DEFINE([DISABLE_UTMPX], [1],
+               [Define if you don't want to use utmpx])
+       AC_DEFINE([ENABLE_PKCS11], [1],
+               [Enable for PKCS#11, smart card support])
+
+       #
+       # We have no krb5-config tool and we don't want
+       # linking to -lkrb5 on Windows.
+       #
+       
+       SkipGssapiLibsCheck=1
+       
+       ;;
 *-*-darwin*)
 	AC_MSG_CHECKING([if we have working getaddrinfo])
 	AC_RUN_IFELSE([AC_LANG_SOURCE([[ #include <mach-o/dyld.h>
@@ -1123,11 +1157,26 @@ AC_CHECK_FUNCS([utimes],
 )
 
 dnl    Checks for libutil functions
-AC_CHECK_HEADERS([libutil.h])
-AC_SEARCH_LIBS([login], [util bsd], [AC_DEFINE([HAVE_LOGIN], [1],
-	[Define if your libraries define login()])])
-AC_CHECK_FUNCS([fmt_scaled logout updwtmp logwtmp])
 
+ #
+ # NX_WIN32_FIXME
+ #
+ 
+ case "$host" in
+ *-*-mingw32*)
+       ;;
+ *)
+       AC_CHECK_HEADERS([libutil.h])
+       AC_SEARCH_LIBS([login], [util bsd], [AC_DEFINE([HAVE_LOGIN], [1],
+               [Define if your libraries define login()])])
+       AC_CHECK_FUNCS([fmt_scaled logout updwtmp logwtmp])
+       ;;
+ esac
+ 
+ #
+ # END FIXME
+ #
+ 
 AC_FUNC_STRFTIME
 
 # Check for ALTDIRFUNC glob() extension
@@ -2790,7 +2839,21 @@ if test "x$ac_cv_have_u_char" = "xyes" ; then
 	AC_DEFINE([HAVE_U_CHAR], [1], [define if you have u_char data type])
 fi
 
-TYPE_SOCKLEN_T
+#
+# NX_WIN32_FIXME
+#
+
+case "$host" in
+*-*-mingw32*)
+      ;;
+*)
+      TYPE_SOCKLEN_T
+      ;;
+esac
+
+#
+# END FIXME
+#
 
 AC_CHECK_TYPES([sig_atomic_t], , , [#include <signal.h>])
 AC_CHECK_TYPES([fsblkcnt_t, fsfilcnt_t], , , [
@@ -3283,7 +3346,15 @@ if test "x$ac_cv_libc_defines_sys_nerr" = "xyes" ; then
 	AC_DEFINE([HAVE_SYS_NERR], [1], [Define if your system defines sys_nerr])
 fi
 
+#
+# NX_WIN32_FIXME
+#
+
 # Check libraries needed by DNS fingerprint support
+case "$host" in
+*-*-mingw32*)
+      ;;
+*)
 AC_SEARCH_LIBS([getrrsetbyname], [resolv],
 	[AC_DEFINE([HAVE_GETRRSETBYNAME], [1],
 		[Define if getrrsetbyname() exists])],
@@ -3328,6 +3399,12 @@ AC_SEARCH_LIBS([getrrsetbyname], [resolv],
 			    [Define if HEADER.ad exists in arpa/nameser.h])], ,
 			[#include <arpa/nameser.h>])
 	])
+  ;;
+esac  
+
+#
+# END FIXME
+#
 
 AC_MSG_CHECKING([if struct __res_state _res is an extern])
 AC_LINK_IFELSE([AC_LANG_PROGRAM([[
@@ -3387,6 +3464,25 @@ AC_ARG_WITH([kerberos5],
 		AC_DEFINE([KRB5], [1], [Define if you want Kerberos 5 support])
 		KRB5_MSG="yes"
 
+
+#
+# NX_WIN32_FIXME
+#
+
+#
+# We have no krb5-config on Windows.
+# Dont link to kerberos libs, becouse we loads
+# them in runtime.
+#
+
+if test "$SkipGssapiLibsCheck" = "1" ; then
+
+  AC_DEFINE(GSSAPI, 1, [Define this if you want GSSAPI support in the version 2 protocol])
+
+  CFLAGS="$CFLAGS -I$KRB5ROOT"
+
+else
+
 		AC_PATH_PROG([KRB5CONF], [krb5-config],
 			     [$KRB5ROOT/bin/krb5-config],
 			     [$KRB5ROOT/bin:$PATH])
@@ -3446,6 +3542,12 @@ AC_ARG_WITH([kerberos5],
 				],
 				$K5LIBS)
 
+fi
+
+#
+# END FIXME
+#
+
 			AC_CHECK_HEADER([gssapi.h], ,
 				[ unset ac_cv_header_gssapi_h
 				  CPPFLAGS="$CPPFLAGS -I${KRB5ROOT}/include/gssapi"
@@ -3468,10 +3570,28 @@ AC_ARG_WITH([kerberos5],
 			blibpath="$blibpath:${KRB5ROOT}/lib"
 		fi
 
+#
+# Fix header found, but not usable on MinGW.
+#
+
+ case "$host" in
+ *-*-mingw32*)
+
+    AC_CHECK_HEADERS([gssapi.h gssapi/gssapi.h], [], [], [ #define _W64 long long ] )
+    AC_CHECK_HEADERS([gssapi_krb5.h gssapi/gssapi_krb5.h], [], [], [ #define _W64 long long ] )
+    AC_CHECK_HEADERS([gssapi_generic.h gssapi/gssapi_generic.h], [], [], [ #define _W64 long long ] )
+
+       ;;
+ *)
+
 		AC_CHECK_HEADERS([gssapi.h gssapi/gssapi.h])
-		AC_CHECK_HEADERS([gssapi_krb5.h gssapi/gssapi_krb5.h])
+	AC_CHECK_HEADERS([gssapi_krb5.h gssapi/gssapi_krb5.h])
 		AC_CHECK_HEADERS([gssapi_generic.h gssapi/gssapi_generic.h])
 
+       ;;
+ esac
+
+
 		LIBS="$LIBS $K5LIBS"
 		AC_SEARCH_LIBS([k_hasafs], [kafs], [AC_DEFINE([USE_AFS], [1],
 			[Define this if you want to use libkafs' AFS support])])
@@ -4177,6 +4297,41 @@ dnl Adding -Werror to CFLAGS early prevents configure tests from running.
 dnl Add now.
 CFLAGS="$CFLAGS $werror_flags"
 
+#
+# NX_WIN3_FIXME
+#
+
+dnl Add new defines for NX build
+case "$host" in
+*-*-mingw32*)
+	;;
+*)
+	AC_DEFINE(HAVE_TTY, 1, [Define to 1 if you have tty support])
+	AC_DEFINE(HAVE_PRIV_CONCEPT, 1, [Define to 1 if you have priveleged-port concept])
+	AC_DEFINE(USE_SANITISE_STDFD, 1, [Define if you want to sanitize fds])
+	;;
+esac
+
+dnl Add any needed compatibility library.
+AC_SUBST(LINKWIN32COMPAT)
+AC_SUBST(LIBWIN32COMPAT)
+AC_SUBST(LIBWIN32COMPATDEPEND)
+AC_SUBST(WIN32COMPAT)
+case "$host" in
+*-*-mingw32*)
+	LINKWIN32COMPAT="-lwin32compat"
+	LIBWIN32COMPAT="libwin32compat.a"
+	LIBWIN32COMPATDEPEND="contrib/win32/win32compat/libwin32compat.a"
+	WIN32COMPAT="win32compat"
+	;;
+*)
+	;;
+esac
+
+#
+# End of NX_WIN32_FIXME.
+#
+
 if test "x$ac_cv_func_getaddrinfo" != "xyes" ; then
 	TEST_SSH_IPV6=no
 else
@@ -4186,9 +4341,29 @@ AC_CHECK_DECL([BROKEN_GETADDRINFO],  [TEST_SSH_IPV6=no])
 AC_SUBST([TEST_SSH_IPV6], [$TEST_SSH_IPV6])
 
 AC_EXEEXT
-AC_CONFIG_FILES([Makefile buildpkg.sh opensshd.init openssh.xml \
-	openbsd-compat/Makefile openbsd-compat/regress/Makefile \
-	survey.sh])
+
+#
+# NX_WIN32_FIXME
+#
+
+files="Makefile buildpkg.sh opensshd.init openssh.xml \
+       openbsd-compat/Makefile openbsd-compat/regress/Makefile \
+       survey.sh"
+
+case "$host" in
+*-*-mingw32*)
+      files="$files contrib/win32/win32compat/Makefile"
+      ;;
+*)
+      ;;
+esac
+
+AC_CONFIG_FILES([ $files ])
+
+#
+# END FIXME
+#
+
 AC_OUTPUT
 
 # Print summary of options
diff --git a/contrib/win32/openssh/libopenbsdcompat/libopenbsdcompat.vcproj b/contrib/win32/openssh/libopenbsdcompat/libopenbsdcompat.vcproj
new file mode 100644
index 0000000..ee214dc
--- /dev/null
+++ b/contrib/win32/openssh/libopenbsdcompat/libopenbsdcompat.vcproj
@@ -0,0 +1,311 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8.00"
+	Name="libopenbsdcompat"
+	ProjectGUID="{E9A9CF62-16DA-409A-AB65-0B98507C4761}"
+	RootNamespace="libopenbsdcompat"
+	Keyword="Win32Proj"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..;..\..\..\..;..\..\win32compat\includes;..\..\..\..\..\openssl-0.9.8e\build\include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="2"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="..\..;..\..\..\..;..\..\win32compat\includes;..\..\..\..\..\openssl-0.9.8e\build\include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath="..\..\..\..\openbsd-compat\base64.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\openbsd-compat\bindresvport.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\openbsd-compat\bsd-arc4random.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\openbsd-compat\bsd-asprintf.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\openbsd-compat\bsd-misc.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\openbsd-compat\getopt.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\openbsd-compat\inet_ntop.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\openbsd-compat\rresvport.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\openbsd-compat\setproctitle.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\openbsd-compat\strlcat.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\openbsd-compat\strlcpy.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\openbsd-compat\strsep.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\openbsd-compat\strtoll.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\openbsd-compat\strtonum.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\openbsd-compat\vis.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\openbsd-compat\xmmap.c"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath="..\..\..\..\openbsd-compat\base64.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\openbsd-compat\bsd-misc.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\config.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\openbsd-compat\getrrsetbyname.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\openbsd-compat\glob.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\includes.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\openbsd-compat\openbsd-compat.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\openbsd-compat\readpassphrase.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\openbsd-compat\sigact.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\openbsd-compat\vis.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+		</Filter>
+		<File
+			RelativePath="..\..\..\..\openbsd-compat\Makefile"
+			>
+			<FileConfiguration
+				Name="Debug|Win32"
+				ExcludedFromBuild="true"
+				>
+				<Tool
+					Name="VCCustomBuildTool"
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Release|Win32"
+				ExcludedFromBuild="true"
+				>
+				<Tool
+					Name="VCCustomBuildTool"
+				/>
+			</FileConfiguration>
+		</File>
+		<File
+			RelativePath="..\..\..\..\openbsd-compat\Makefile.in"
+			>
+			<FileConfiguration
+				Name="Debug|Win32"
+				ExcludedFromBuild="true"
+				>
+				<Tool
+					Name="VCCustomBuildTool"
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Release|Win32"
+				ExcludedFromBuild="true"
+				>
+				<Tool
+					Name="VCCustomBuildTool"
+				/>
+			</FileConfiguration>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff --git a/contrib/win32/openssh/libssh/libssh.vcproj b/contrib/win32/openssh/libssh/libssh.vcproj
new file mode 100644
index 0000000..f36b3d9
--- /dev/null
+++ b/contrib/win32/openssh/libssh/libssh.vcproj
@@ -0,0 +1,543 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8.00"
+	Name="libssh"
+	ProjectGUID="{EBDE90BD-BD30-4128-8E79-50224624628E}"
+	RootNamespace="libssh"
+	Keyword="Win32Proj"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..;..\..\win32compat\includes;..\..\..\..\..\openssl-0.9.8e\build\include;..\..\..\..\..\zlib\include;..\..\..\..\openbsd-compat"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="2"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="..\..;..\..\win32compat\includes;..\..\..\..\..\openssl-0.9.8e\build\include;..\..\..\..\..\zlib\include;..\..\..\..\openbsd-compat"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath="..\..\..\..\acss.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\atomicio.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\authfd.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\authfile.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\bufaux.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\bufbn.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\buffer.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\canohost.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\channels.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\cipher-3des1.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\cipher-acss.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\cipher-aes.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\cipher-bf1.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\cipher-ctr.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\cipher.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\cleanup.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\compat.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\compress.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\crc32.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\deattack.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\dh.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\dispatch.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\dns.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\entropy.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\fatal.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\gss-genr.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\hostfile.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\kex.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\kexdh.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\kexdhc.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\kexgex.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\kexgexc.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\key.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\log.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\mac.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\match.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\md-sha256.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\misc.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\moduli.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\monitor_fdpass.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\msg.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\nchan.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\packet.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\progressmeter.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\readpass.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\rijndael.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\rsa.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\scard-opensc.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\scard.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\ssh-dss.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\ssh-rsa.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\ttymodes.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\uidswap.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\umac.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\uuencode.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\xmalloc.c"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath="..\..\..\..\acss.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\atomicio.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\authfd.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\authfile.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\buffer.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\canohost.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\channels.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\cipher.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\compat.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\compress.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\config.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\crc32.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\deattack.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\defines.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\dh.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\dispatch.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\dns.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\entropy.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\hostfile.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\includes.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\kex.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\key.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\log.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\mac.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\match.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\misc.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\monitor_fdpass.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\msg.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\packet.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\progressmeter.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\rijndael.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\rsa.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\scard.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\ttymodes.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\uidswap.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\umac.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\uuencode.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\xmalloc.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff --git a/contrib/win32/openssh/openssh.sln b/contrib/win32/openssh/openssh.sln
new file mode 100644
index 0000000..ff0f19b
--- /dev/null
+++ b/contrib/win32/openssh/openssh.sln
@@ -0,0 +1,44 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual Studio 2005
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libssh", "libssh\libssh.vcproj", "{EBDE90BD-BD30-4128-8E79-50224624628E}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ssh", "ssh\ssh.vcproj", "{FFF4695D-9C03-456C-8DDB-60D9FF6C19FF}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libopenbsdcompat", "libopenbsdcompat\libopenbsdcompat.vcproj", "{E9A9CF62-16DA-409A-AB65-0B98507C4761}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "win32compat", "..\win32compat\win32compat.vcproj", "{8660C2FE-9874-432D-B047-E042BB41DBE0}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "sshd", "sshd\sshd.vcproj", "{9B3C8BD7-FDE8-410F-8541-E0E5720E1134}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{EBDE90BD-BD30-4128-8E79-50224624628E}.Debug|Win32.ActiveCfg = Debug|Win32
+		{EBDE90BD-BD30-4128-8E79-50224624628E}.Debug|Win32.Build.0 = Debug|Win32
+		{EBDE90BD-BD30-4128-8E79-50224624628E}.Release|Win32.ActiveCfg = Release|Win32
+		{EBDE90BD-BD30-4128-8E79-50224624628E}.Release|Win32.Build.0 = Release|Win32
+		{FFF4695D-9C03-456C-8DDB-60D9FF6C19FF}.Debug|Win32.ActiveCfg = Debug|Win32
+		{FFF4695D-9C03-456C-8DDB-60D9FF6C19FF}.Debug|Win32.Build.0 = Debug|Win32
+		{FFF4695D-9C03-456C-8DDB-60D9FF6C19FF}.Release|Win32.ActiveCfg = Release|Win32
+		{FFF4695D-9C03-456C-8DDB-60D9FF6C19FF}.Release|Win32.Build.0 = Release|Win32
+		{E9A9CF62-16DA-409A-AB65-0B98507C4761}.Debug|Win32.ActiveCfg = Debug|Win32
+		{E9A9CF62-16DA-409A-AB65-0B98507C4761}.Debug|Win32.Build.0 = Debug|Win32
+		{E9A9CF62-16DA-409A-AB65-0B98507C4761}.Release|Win32.ActiveCfg = Release|Win32
+		{E9A9CF62-16DA-409A-AB65-0B98507C4761}.Release|Win32.Build.0 = Release|Win32
+		{8660C2FE-9874-432D-B047-E042BB41DBE0}.Debug|Win32.ActiveCfg = Debug|Win32
+		{8660C2FE-9874-432D-B047-E042BB41DBE0}.Debug|Win32.Build.0 = Debug|Win32
+		{8660C2FE-9874-432D-B047-E042BB41DBE0}.Release|Win32.ActiveCfg = Release|Win32
+		{8660C2FE-9874-432D-B047-E042BB41DBE0}.Release|Win32.Build.0 = Release|Win32
+		{9B3C8BD7-FDE8-410F-8541-E0E5720E1134}.Debug|Win32.ActiveCfg = Debug|Win32
+		{9B3C8BD7-FDE8-410F-8541-E0E5720E1134}.Debug|Win32.Build.0 = Debug|Win32
+		{9B3C8BD7-FDE8-410F-8541-E0E5720E1134}.Release|Win32.ActiveCfg = Release|Win32
+		{9B3C8BD7-FDE8-410F-8541-E0E5720E1134}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff --git a/contrib/win32/openssh/ssh/ssh.vcproj b/contrib/win32/openssh/ssh/ssh.vcproj
new file mode 100644
index 0000000..0c07ff9
--- /dev/null
+++ b/contrib/win32/openssh/ssh/ssh.vcproj
@@ -0,0 +1,275 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8.00"
+	Name="ssh"
+	ProjectGUID="{FFF4695D-9C03-456C-8DDB-60D9FF6C19FF}"
+	RootNamespace="ssh"
+	Keyword="Win32Proj"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..;..\..\win32compat\includes;..\..\..\..\..\openssl-0.9.8e\build\include;..\..\..\..\..\zlib\include;..\..\..\..\openbsd-compat;..\..\..\..\..\nxcomp"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ws2_32.lib libeay32.lib zdll.lib"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="..\..\..\..\..\openssl-0.9.8e\build\lib;..\..\..\..\..\zlib\lib"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="2"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="..\..;..\..\win32compat\includes;..\..\..\..\..\openssl-0.9.8e\build\include;..\..\..\..\..\zlib\include;..\..\..\..\openbsd-compat;..\..\..\..\..\nxcomp"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ws2_32.lib libeay32.lib zdll.lib"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="..\..\..\..\..\openssl-0.9.8e\build\lib;..\..\..\..\..\zlib\lib"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+		<ProjectReference
+			ReferencedProjectIdentifier="{EBDE90BD-BD30-4128-8E79-50224624628E}"
+			RelativePathToProject=".\libssh\libssh.vcproj"
+		/>
+		<ProjectReference
+			ReferencedProjectIdentifier="{E9A9CF62-16DA-409A-AB65-0B98507C4761}"
+			RelativePathToProject=".\libopenbsdcompat\libopenbsdcompat.vcproj"
+		/>
+		<ProjectReference
+			ReferencedProjectIdentifier="{8660C2FE-9874-432D-B047-E042BB41DBE0}"
+			RelativePathToProject="..\win32compat\win32compat.vcproj"
+		/>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath="..\..\..\..\clientloop.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\readconf.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\ssh.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\sshconnect.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\sshconnect1.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\sshconnect2.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\sshtty.c"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath="..\..\..\..\clientloop.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\readconf.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\ssh.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\sshconnect.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+		</Filter>
+		<File
+			RelativePath="..\..\..\..\Makefile.in"
+			>
+			<FileConfiguration
+				Name="Debug|Win32"
+				ExcludedFromBuild="true"
+				>
+				<Tool
+					Name="VCCustomBuildTool"
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Release|Win32"
+				ExcludedFromBuild="true"
+				>
+				<Tool
+					Name="VCCustomBuildTool"
+				/>
+			</FileConfiguration>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff --git a/contrib/win32/openssh/sshd/sshd.vcproj b/contrib/win32/openssh/sshd/sshd.vcproj
new file mode 100644
index 0000000..f1cc4c3
--- /dev/null
+++ b/contrib/win32/openssh/sshd/sshd.vcproj
@@ -0,0 +1,443 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8.00"
+	Name="sshd"
+	ProjectGUID="{9B3C8BD7-FDE8-410F-8541-E0E5720E1134}"
+	RootNamespace="sshd"
+	Keyword="Win32Proj"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..;..\..\win32compat\includes;..\..\..\..\..\openssl-0.9.8e\build\include;..\..\..\..\..\zlib\include;..\..\..\..\openbsd-compat"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ws2_32.lib libeay32.lib zdll.lib"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="..\..\..\..\..\openssl-0.9.8e\build\lib;..\..\..\..\..\zlib\lib"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="2"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="..\..;..\..\win32compat\includes;..\..\..\..\..\openssl-0.9.8e\build\include;..\..\..\..\..\zlib\include;..\..\..\..\openbsd-compat"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ws2_32.lib libeay32.lib zdll.lib"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="..\..\..\..\..\openssl-0.9.8e\build\lib;..\..\..\..\..\zlib\lib"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+		<ProjectReference
+			ReferencedProjectIdentifier="{E9A9CF62-16DA-409A-AB65-0B98507C4761}"
+			RelativePathToProject=".\libopenbsdcompat\libopenbsdcompat.vcproj"
+		/>
+		<ProjectReference
+			ReferencedProjectIdentifier="{EBDE90BD-BD30-4128-8E79-50224624628E}"
+			RelativePathToProject=".\libssh\libssh.vcproj"
+		/>
+		<ProjectReference
+			ReferencedProjectIdentifier="{8660C2FE-9874-432D-B047-E042BB41DBE0}"
+			RelativePathToProject="..\win32compat\win32compat.vcproj"
+		/>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath="..\..\..\..\audit-bsm.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\audit.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\auth-bsdauth.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\auth-chall.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\auth-krb5.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\auth-options.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\auth-pam.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\auth-passwd.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\auth-rh-rsa.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\auth-rhosts.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\auth-rsa.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\auth-shadow.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\auth-sia.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\auth-skey.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\auth.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\auth1.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\auth2-chall.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\auth2-gss.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\auth2-hostbased.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\auth2-kbdint.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\auth2-none.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\auth2-passwd.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\auth2-pubkey.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\auth2.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\groupaccess.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\gss-serv-krb5.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\gss-serv.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\kexdhs.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\kexgexs.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\loginrec.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\md5crypt.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\monitor.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\monitor_mm.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\monitor_wrap.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\platform.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\servconf.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\serverloop.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\session.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\sshd.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\sshlogin.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\sshpty.c"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath="..\..\..\..\audit.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\auth-options.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\auth-pam.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\auth-sia.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\auth.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\groupaccess.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\loginrec.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\md5crypt.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\monitor.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\monitor_mm.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\monitor_wrap.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\platform.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\servconf.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\serverloop.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\session.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\sshlogin.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\sshpty.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff --git a/contrib/win32/win32compat/Debug.h b/contrib/win32/win32compat/Debug.h
new file mode 100644
index 0000000..8da03fa
--- /dev/null
+++ b/contrib/win32/win32compat/Debug.h
@@ -0,0 +1,39 @@
+/*
+ * Author: NoMachine <developers@nomachine.com>
+ *
+ * Copyright (c) 2009, 2011 NoMachine
+ * All rights reserved
+ *
+ * Support functions and system calls' replacements needed to let the
+ * software run on Win32 based operating systems.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef Debug_H
+#define Debug_H
+
+#define FAIL(CONDITION) if (CONDITION) goto fail
+
+#define NTFAIL(NTFUNC) if((ntStat = (NTFUNC))) goto fail
+
+#endif
diff --git a/contrib/win32/win32compat/Makefile.in b/contrib/win32/win32compat/Makefile.in
new file mode 100644
index 0000000..027f868
--- /dev/null
+++ b/contrib/win32/win32compat/Makefile.in
@@ -0,0 +1,42 @@
+# $Id $
+
+sysconfdir=@sysconfdir@
+piddir=@piddir@
+srcdir=@srcdir@
+top_srcdir=@top_srcdir@
+
+VPATH=@srcdir@
+CC=@CC@
+LD=@LD@
+CFLAGS=@CFLAGS@
+CPPFLAGS=-I. -I../../.. -I$(srcdir) -I$(top_srcdir) -I$(srcdir)/includes @CPPFLAGS@ @DEFS@
+LIBS=@LIBS@
+AR=@AR@
+RANLIB=@RANLIB@
+INSTALL=@INSTALL@
+LDFLAGS=-L. @LDFLAGS@
+
+WIN32COMPATFILES = daemon.o gettimeofday.o homedirhelp.o pwd.o sfds.o \
+	socket.o startupneeds.o strcasecmp.o syslog.o lsalogon.o lsastring.o \
+	stringhelp.o deskright.o win32auth.o kerberos.o
+
+WIN32COMPATLIB=@LIBWIN32COMPAT@
+
+.c.o:
+	$(CC) $(CFLAGS) $(CPPFLAGS) -c $<
+
+all: $(WIN32COMPATLIB)
+
+install:
+
+clean:
+	rm -f *.o *.a core
+
+distclean: clean
+	rm -f Makefile *~
+
+$(WIN32COMPATFILES): ../../../config.h
+
+$(WIN32COMPATLIB): $(WIN32COMPATFILES)
+	$(AR) rv $@ $(WIN32COMPATFILES)
+	$(RANLIB) $@
diff --git a/contrib/win32/win32compat/daemon.c b/contrib/win32/win32compat/daemon.c
new file mode 100644
index 0000000..c7ce8e2
--- /dev/null
+++ b/contrib/win32/win32compat/daemon.c
@@ -0,0 +1,37 @@
+/*
+ * Author: NoMachine <developers@nomachine.com>
+ *
+ * Copyright (c) 2009, 2010 NoMachine
+ * All rights reserved
+ *
+ * Support functions and system calls' replacements needed to let the
+ * software run on Win32 based operating systems.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "includes.h"
+
+int daemon(int nochdir, int noclose)
+{
+  return 0;
+}
diff --git a/contrib/win32/win32compat/deskright.c b/contrib/win32/win32compat/deskright.c
new file mode 100644
index 0000000..870a5b8
--- /dev/null
+++ b/contrib/win32/win32compat/deskright.c
@@ -0,0 +1,781 @@
+/*
+ * Author: NoMachine <developers@nomachine.com>
+ *
+ * Copyright (c) 2009, 2011 NoMachine
+ * All rights reserved
+ *
+ * Support functions and system calls' replacements needed to let the
+ * software run on Win32 based operating systems.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "deskright.h"
+
+/*
+ * Retrieve SID from access token.
+ *
+ * hToken - access token (IN)
+ * psid   - user's SID (OUT)
+ *
+ * RETURNS: TRUE if OK.
+ */
+
+BOOL ObtainSid(HANDLE hToken, PSID *psid)
+{
+  debug2("-> ObtainSid()...");
+  
+  BOOL bSuccess = FALSE;
+  
+  DWORD dwIndex;
+  
+  DWORD dwLength = 0;
+
+  TOKEN_INFORMATION_CLASS tic = TokenGroups;
+
+  PTOKEN_GROUPS ptg = NULL;
+
+  /* 
+   * determine the size of the buffer
+   */
+  
+  if (!GetTokenInformation(hToken, tic, (LPVOID) ptg, 0, &dwLength))
+  {
+    FAIL(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
+
+    ptg = (PTOKEN_GROUPS) HeapAlloc(GetProcessHeap(), 
+                                        HEAP_ZERO_MEMORY, dwLength);
+
+    FAIL(ptg == NULL);  
+  }
+
+  /*
+   * obtain the groups the access token belongs to
+   */
+
+  FAIL(GetTokenInformation(hToken, tic, (LPVOID) ptg, 
+                               dwLength, &dwLength) == FALSE);
+
+  /*
+   * determine which group is the logon sid
+   */
+
+  for (dwIndex = 0; dwIndex < ptg -> GroupCount; dwIndex++)
+  {
+    if ((ptg -> Groups[dwIndex].Attributes & SE_GROUP_LOGON_ID) ==  SE_GROUP_LOGON_ID)
+    {
+      /*
+       * determine the length of the sid
+       */
+      
+      dwLength = GetLengthSid(ptg -> Groups[dwIndex].Sid);
+
+      /*
+       * allocate a buffer for the logon sid
+       */
+  
+      *psid = (PSID) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwLength);
+      
+       FAIL(*psid == NULL);
+
+       /*
+        * obtain a copy of the logon sid
+        */
+  
+       FAIL(CopySid(dwLength, *psid, ptg -> Groups[dwIndex].Sid) == FALSE);
+
+       /*
+        * Break out of the loop because the logon sid has been
+        * found.
+        */
+  
+       break;
+     }
+   }
+
+   /*
+    * Indicate success.
+    */
+   
+   bSuccess = TRUE;
+
+ fail:
+
+ /*
+  * Free the buffer for the token group.
+  */
+ 
+ if (ptg != NULL)
+ {
+   HeapFree(GetProcessHeap(), 0, (LPVOID)ptg);
+ }
+
+  return bSuccess;
+}
+
+/*
+ * Gives user rights to use given WinStation object.
+ *
+ * WARNING. This rights is given only for login session, i.e,
+ *          acount's properties are not be changed.
+ *
+ * hwinsta - handle to WindowsStation object (IN)
+ * psid    - pointer to user's SID (IN)
+ *
+ * RETURNS: TRUE if OK.
+ */
+   
+BOOL AddTheAceWindowStation(HWINSTA hwinsta, PSID psid)
+{
+  debug2("-> AddTheAceWindowStation()...");
+  
+  ACCESS_ALLOWED_ACE *pace;
+  
+  ACL_SIZE_INFORMATION aclSizeInfo;
+  
+  BOOL bDaclExist;
+  BOOL bDaclPresent;
+  BOOL bSuccess = FALSE;
+                        
+  DWORD dwNewAclSize;
+  DWORD dwSidSize = 0;
+  DWORD dwSdSizeNeeded;
+  
+  PACL pacl;
+  PACL pNewAcl;
+  
+  PSECURITY_DESCRIPTOR psd    = NULL;
+  PSECURITY_DESCRIPTOR psdNew = NULL;
+  
+  PVOID pTempAce;
+  
+  SECURITY_INFORMATION si = DACL_SECURITY_INFORMATION;
+  
+  unsigned int i;
+  
+  /*
+   * is input SID valid?
+   */
+  
+  debug3("Testing is SID valid...");
+
+  FAIL(psid == NULL);
+  
+  FAIL(IsValidSid(psid) == FALSE);
+
+  /*
+   * obtain the dacl for the windowstation
+   */
+
+  debug3("GetUserObjectSecurity()...");
+  
+  if (!GetUserObjectSecurity(hwinsta, &si, psd, dwSidSize, &dwSdSizeNeeded))
+  {
+    FAIL(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
+
+    psd = (PSECURITY_DESCRIPTOR) HeapAlloc(GetProcessHeap(), 
+                                               HEAP_ZERO_MEMORY, 
+                                                   dwSdSizeNeeded);
+
+    FAIL(psd == NULL);
+
+    psdNew = (PSECURITY_DESCRIPTOR) HeapAlloc(GetProcessHeap(), 
+                                                  HEAP_ZERO_MEMORY, 
+                                                      dwSdSizeNeeded);
+      
+    FAIL(psdNew == NULL);
+
+    dwSidSize = dwSdSizeNeeded;
+
+    FAIL(GetUserObjectSecurity(hwinsta, &si, psd, 
+                                   dwSidSize, &dwSdSizeNeeded) == FALSE);
+  }
+
+  /*
+   * Create a new dacl.
+   */
+  
+  debug3("InitializeSecurityDescriptor()...");
+  
+  FAIL(InitializeSecurityDescriptor(psdNew, SECURITY_DESCRIPTOR_REVISION) == FALSE);
+
+  /*
+   * get dacl from the security descriptor.
+   */
+ 
+  debug3("GetSecurityDescriptorDacl()...");
+  
+  FAIL(GetSecurityDescriptorDacl(psd, &bDaclPresent, &pacl, &bDaclExist) == FALSE);
+
+  /*
+   * Initialize.
+   */
+ 
+  ZeroMemory(&aclSizeInfo, sizeof(ACL_SIZE_INFORMATION));
+  aclSizeInfo.AclBytesInUse = sizeof(ACL);
+
+  /*
+   * Call only if the dacl is not NULL.
+   */
+
+  if (pacl != NULL)
+  {
+    /*
+     * Get the file ACL size info.
+     */
+ 
+    debug3("GetAclInformation()...");
+    
+    FAIL(GetAclInformation(pacl, (LPVOID) &aclSizeInfo,
+                               sizeof(ACL_SIZE_INFORMATION), 
+                                   AclSizeInformation) == FALSE);
+  }
+
+  /*
+   * Compute the size of the new acl.
+   */
+  
+  debug3("Calculating dwNewAclSize...");
+    
+  dwNewAclSize = aclSizeInfo.AclBytesInUse + (2 * sizeof(ACCESS_ALLOWED_ACE)) 
+                   + (2 * GetLengthSid(psid)) - (2 * sizeof(DWORD));
+                   
+  debug3("dwNewAclSize = %d", dwNewAclSize);
+
+  /*
+   * Allocate memory for the new acl.
+   */
+
+  debug3("HeapAlloc()...");
+  
+  pNewAcl = (PACL) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwNewAclSize);
+
+  FAIL(pNewAcl == NULL);
+
+  /*
+   * Initialize the new dacl.
+   */
+
+  debug3("InitializeAcl()...");
+  
+  FAIL(InitializeAcl(pNewAcl, dwNewAclSize, ACL_REVISION) == FALSE);
+
+  /*
+   * If DACL is present, copy it to a new DACL.
+   */
+ 
+  if (bDaclPresent) 
+  {
+    /*
+     * Copy the ACEs to our new ACL.
+     */
+    
+    if (aclSizeInfo.AceCount)
+    {
+
+      debug3("aclSizeInfo.AceCount = %d", aclSizeInfo.AceCount);
+       
+      for (i = 0; i < aclSizeInfo.AceCount; i++)
+      {
+        /*
+         * get an ACE.
+         */
+  
+        FAIL(GetAce(pacl, i, &pTempAce) == FALSE);
+
+        /*
+         * Add the ACE to the new ACL.
+         */
+
+        FAIL(AddAce(pNewAcl, ACL_REVISION, MAXDWORD, pTempAce, 
+                        ((PACE_HEADER) pTempAce) -> AceSize) == FALSE);
+      }
+    }
+  }
+
+  /*
+   * add the first ACE to the windowstation.
+   */
+  
+  pace = (ACCESS_ALLOWED_ACE *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 
+                                              sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psid) - sizeof(DWORD));
+
+  FAIL(pace == NULL);
+
+  pace -> Header.AceType  = ACCESS_ALLOWED_ACE_TYPE;
+  pace -> Header.AceFlags = CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE;
+  pace -> Header.AceSize  = sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psid) - sizeof(DWORD);
+  pace -> Mask            = GENERIC_ACCESS;
+
+  debug3("CopySid()...");
+      
+  FAIL(CopySid(GetLengthSid(psid), &pace -> SidStart, psid) == FALSE);
+
+  debug3("AddAce()...");
+  
+  FAIL(AddAce(pNewAcl, ACL_REVISION, MAXDWORD, 
+                  (LPVOID)pace, pace -> Header.AceSize) == FALSE);
+
+  /*
+   * Add the second ACE to the windowstation.
+   */
+ 
+  pace -> Header.AceFlags = NO_PROPAGATE_INHERIT_ACE;
+  pace -> Mask = WINSTA_ALL;
+
+  debug3("AddAce()...");
+  
+  FAIL(AddAce(pNewAcl, ACL_REVISION, MAXDWORD, 
+                  (LPVOID)pace, pace -> Header.AceSize) == FALSE);
+
+  /*
+   * Set new dacl for the security descriptor.
+   */
+ 
+  debug3("SetSecurityDescriptorDacl()...");
+  
+  FAIL(SetSecurityDescriptorDacl(psdNew, TRUE, pNewAcl, FALSE) == FALSE);
+
+  /*
+   * set the new security descriptor for the windowstation.
+   */
+  
+  debug3("SetUserObjectSecurity()...");
+  
+  FAIL(SetUserObjectSecurity(hwinsta, &si, psdNew) == FALSE);
+
+  /*
+   * Indicate success.
+   */
+ 
+  bSuccess = TRUE;
+
+fail:
+
+  /*
+   * Free the allocated buffers.
+   */
+  
+  if (pace != NULL)
+  {
+    HeapFree(GetProcessHeap(), 0, (LPVOID)pace);
+  }
+
+  if (pNewAcl != NULL)
+  {
+    HeapFree(GetProcessHeap(), 0, (LPVOID)pNewAcl);
+  }
+
+  if (psd != NULL)
+  {
+    HeapFree(GetProcessHeap(), 0, (LPVOID)psd); 
+  }
+
+  if (psdNew != NULL)
+  {
+    HeapFree(GetProcessHeap(), 0, (LPVOID)psdNew);
+  }
+
+  return bSuccess;
+}
+
+/*
+ * Gives user right to use given desktop.
+ *
+ * WARNING. This right is given only for login session, i.e,
+ *          account's properties are not be changed.
+ *
+ * hdesk - handle to desktop (IN)
+ * psid  - pointer to user's SID (IN)
+ *
+ * RETURNS: TRUE if OK.
+ */
+
+BOOL AddTheAceDesktop(HDESK hdesk, PSID psid)
+{
+  debug2("-> AddTheAceDesktop()...");
+  
+  ACL_SIZE_INFORMATION aclSizeInfo;
+  
+  BOOL bDaclExist;
+  BOOL bDaclPresent;
+  BOOL bSuccess = FALSE;
+                                                
+  DWORD dwNewAclSize;
+  DWORD dwSidSize = 0;
+  DWORD dwSdSizeNeeded;
+
+  PACL pacl;
+  PACL pNewAcl;
+
+  PSECURITY_DESCRIPTOR psd    = NULL;
+  PSECURITY_DESCRIPTOR psdNew = NULL;
+  
+  HANDLE procHeap = NULL;
+  
+  PVOID pTempAce;
+
+  SECURITY_INFORMATION si = DACL_SECURITY_INFORMATION;
+
+  unsigned int i;
+
+  /*
+   * is input SID valid?
+   */
+  
+  debug3("Testing is SID valid...");
+
+  FAIL(psid == NULL);
+  
+  FAIL(IsValidSid(psid) == FALSE);
+
+  /*
+   * Obtain process heap. 
+   */
+  
+  procHeap = GetProcessHeap();
+  
+  /*
+   * Obtain the security descriptor for the desktop object.
+   */
+
+  debug3("GetUserObjectSecurity()...");
+  
+  if (!GetUserObjectSecurity(hdesk, &si, psd, 
+                                 dwSidSize, &dwSdSizeNeeded))
+  {
+    FAIL(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
+
+    psd = (PSECURITY_DESCRIPTOR) HeapAlloc(procHeap,
+                                               HEAP_ZERO_MEMORY, 
+                                                   dwSdSizeNeeded);
+      
+    FAIL(psd == NULL); 
+     
+    psdNew = (PSECURITY_DESCRIPTOR)HeapAlloc(procHeap, 
+                                                 HEAP_ZERO_MEMORY, 
+                                                     dwSdSizeNeeded);
+
+    FAIL(psdNew == NULL);
+      
+    dwSidSize = dwSdSizeNeeded;
+
+    FAIL(GetUserObjectSecurity(hdesk, &si, psd, dwSidSize, 
+                                   &dwSdSizeNeeded) == FALSE);
+  }
+  
+  /*
+   * create a new security descriptor.
+   */
+
+  debug3("InitializeSecurityDescriptor()...");
+  
+  FAIL(InitializeSecurityDescriptor(psdNew, 
+                                        SECURITY_DESCRIPTOR_REVISION) == FALSE);
+
+  /*
+   * obtain the dacl from the security descriptor.
+   */
+
+  debug3("GetSecurityDescriptorDacl()...");
+  
+  FAIL(GetSecurityDescriptorDacl(psd, &bDaclPresent, 
+                                     &pacl, &bDaclExist) == FALSE);
+
+  /*
+   * Initialize.
+   */
+
+  ZeroMemory(&aclSizeInfo, sizeof(ACL_SIZE_INFORMATION));
+ 
+  aclSizeInfo.AclBytesInUse = sizeof(ACL);
+
+  /*
+   * call only if NULL dacl.
+   */
+ 
+  if (pacl != NULL)
+  {
+    /*
+     * determine the size of the ACL info.
+     */
+
+    debug3("GetAclInformation()..");
+  
+    FAIL(GetAclInformation(pacl, (LPVOID)&aclSizeInfo, 
+                               sizeof(ACL_SIZE_INFORMATION), 
+                                   AclSizeInformation) == FALSE);
+  }
+
+  /*
+   * Compute the size of the new acl.
+   */
+ 
+  dwNewAclSize = aclSizeInfo.AclBytesInUse 
+                   + sizeof(ACCESS_ALLOWED_ACE) 
+                       + GetLengthSid(psid) - sizeof(DWORD);
+
+  /*
+   * Allocate buffer for the new acl.
+   */
+
+  pNewAcl = (PACL) HeapAlloc(procHeap, 
+                                 HEAP_ZERO_MEMORY, dwNewAclSize);
+
+  FAIL(pNewAcl == NULL);
+
+  /*
+   * Initialize the new acl.
+   */
+ 
+  debug3("InitializeAcl()..");
+    
+  FAIL(InitializeAcl(pNewAcl, dwNewAclSize, ACL_REVISION) == FALSE);
+
+  /*
+   * If DACL is present, copy it to a new DACL.
+   */
+
+  if (bDaclPresent) // only copy if DACL was present
+  {
+    /*
+     * Copy the ACEs to our new ACL.
+     */
+      
+    if (aclSizeInfo.AceCount)
+    {
+      for (i=0; i < aclSizeInfo.AceCount; i++)
+      {
+        /*
+         * Get an ACE.
+         */
+          
+        FAIL(GetAce(pacl, i, &pTempAce) == FALSE);
+
+        /*
+         * Add the ACE to the new ACL.
+         */
+
+        FAIL(AddAce(pNewAcl, ACL_REVISION, MAXDWORD, pTempAce, 
+                        ((PACE_HEADER)pTempAce) -> AceSize) == FALSE);
+      }
+    }
+  }
+
+  /*
+   * Add ace to the dacl.
+   */
+  
+  debug3("AddAccessAllowedAce()...");
+  
+  FAIL(AddAccessAllowedAce(pNewAcl, ACL_REVISION, 
+                               DESKTOP_ALL, psid) == FALSE);
+
+  /*
+   * Set new dacl to the new security descriptor.
+   */
+
+  debug3("AddSecurityDescriptiorDacl()..");
+  
+  FAIL(SetSecurityDescriptorDacl(psdNew, TRUE, pNewAcl, FALSE) == FALSE);
+
+  /*
+   * Set the new security descriptor for the desktop object.
+   */
+   
+  debug3("SetUserObjectSecurity()..");
+  
+  FAIL(SetUserObjectSecurity(hdesk, &si, psdNew) == FALSE);
+
+  /*
+   * Indicate success.
+   */
+
+  bSuccess = TRUE;
+
+fail:
+
+  /*
+   * Free buffers.
+   */
+
+  debug3("Freeing buffers...");
+  
+  if (pNewAcl != NULL)
+  {
+    HeapFree(procHeap, 0, (LPVOID) pNewAcl);
+  }
+
+  if (psd != NULL)
+  {
+    HeapFree(procHeap, 0, (LPVOID) psd);
+  }
+
+  if (psdNew != NULL)
+  {
+    HeapFree(procHeap, 0, (LPVOID) psdNew);
+  }
+
+  debug3("<- AddTheAceDesktop()...");
+  
+  return bSuccess;
+}
+
+void RemoveSid(PSID *psid)
+{
+  HeapFree(GetProcessHeap(), 0, (LPVOID) *psid);
+}
+
+/*
+ * Gives user rights to use 'WinStation0' and 'default' desktop.
+ *
+ * psid - pointer to SID for acount SID (IN)
+ *
+ * RETURNS: 0 if OK.
+ */
+
+int AddRightsToDesktopBySid(PSID psid)
+{
+  debug3("-> AddRightsToDesktopBySid()...");
+  
+  HDESK hdesk = NULL;
+
+  HWINSTA hwinsta = NULL;
+  
+  int exitCode = -1;
+    
+  /*
+   * obtain a handle to the interactive windowstation.
+   */
+  
+  debug3("OpenWindowStation()...");
+  
+  hwinsta = OpenWindowStation("winsta0", FALSE, READ_CONTROL | WRITE_DAC);
+  
+  FAIL(hwinsta == NULL);
+
+  debug3("GetProcessWindowStation()...");
+  
+  HWINSTA hwinstaold = GetProcessWindowStation();
+
+  /*
+   * Set the windowstation to winsta0 so that you obtain the
+   * correct default desktop.
+   */
+  
+  debug3("SetProcessWindowStation()...");
+  
+  FAIL(!SetProcessWindowStation(hwinsta));
+
+  /*
+   * Obtain a handle to the "default" desktop.
+   */
+
+  debug3("OpenDesktop()...");
+  
+  hdesk = OpenDesktop("default", 0, FALSE, READ_CONTROL | WRITE_DAC |
+                          DESKTOP_WRITEOBJECTS | DESKTOP_READOBJECTS);
+  
+  FAIL(hdesk == NULL);
+
+  /*
+   * Add the user to interactive windowstation.
+   */
+  
+  debug3("AddTheAceWindowStation()...");
+  
+  FAIL(!AddTheAceWindowStation(hwinsta, psid));
+
+  /*
+   * Add user to "default" desktop.
+   */
+  
+  debug3("AddTheAceDesktop()...");
+  
+  FAIL(!AddTheAceDesktop(hdesk, psid));
+
+  exitCode = 0;
+
+fail:
+
+  /*
+   * Close the handles to the interactive windowstation and desktop.
+   */
+  
+  debug3("CloseWindowStation()...");
+  
+  if (hwinsta)
+  {
+    CloseWindowStation(hwinsta);
+  }  
+
+  debug3("CloseDesktop()...");
+  
+  if (hdesk)
+  {
+    CloseDesktop(hdesk);
+  }
+  
+  debug3("<- AddRightsToDesktopBySid()...");
+  
+  return exitCode;
+}
+
+/*
+ * Gives user rights to use 'WinStation0' and 'default' desktop.
+ *
+ * hToken - logged user's token (IN)
+ *
+ * RETURNS: 0 if OK.
+ */
+
+int AddRightsToDesktop(HANDLE hToken)
+{
+  debug2("-> AddRightsToDesktop()...");
+  
+  PSID psid = NULL;
+  
+  int exitCode = -1;
+  
+  /*
+   * Obtain the logon sid of the user fester.
+   */
+  
+  debug3("ObtainSid()...");
+  
+  FAIL(!ObtainSid(hToken, &psid));
+  
+  FAIL(AddRightsToDesktopBySid(psid));
+  
+  if (psid)
+  {
+    RemoveSid(&psid);
+  }
+  
+  exitCode = 0;
+  
+fail:
+
+  debug2("<- AddRightsToDesktop()...");
+
+  return exitCode;
+}
diff --git a/contrib/win32/win32compat/deskright.h b/contrib/win32/win32compat/deskright.h
new file mode 100644
index 0000000..2ddfcca
--- /dev/null
+++ b/contrib/win32/win32compat/deskright.h
@@ -0,0 +1,60 @@
+/*
+ * Author: NoMachine <developers@nomachine.com>
+ *
+ * Copyright (c) 2009, 2011 NoMachine
+ * All rights reserved
+ *
+ * Support functions and system calls' replacements needed to let the
+ * software run on Win32 based operating systems.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef DeskRight_H
+#define DeskRight_H
+
+#include "includes.h"
+#include "Debug.h"
+#include <windows.h>
+
+#define WINSTA_ALL (WINSTA_ACCESSCLIPBOARD  | WINSTA_ACCESSGLOBALATOMS | \ 
+                    WINSTA_CREATEDESKTOP    | WINSTA_ENUMDESKTOPS      | \
+                    WINSTA_ENUMERATE        | WINSTA_EXITWINDOWS       | \
+                    WINSTA_READATTRIBUTES   | WINSTA_READSCREEN        | \
+                    WINSTA_WRITEATTRIBUTES  | DELETE                   | \
+                    READ_CONTROL            | WRITE_DAC                | \
+                    WRITE_OWNER)
+
+#define DESKTOP_ALL (DESKTOP_CREATEMENU      | DESKTOP_CREATEWINDOW  | \
+                     DESKTOP_ENUMERATE       | DESKTOP_HOOKCONTROL   | \
+                     DESKTOP_JOURNALPLAYBACK | DESKTOP_JOURNALRECORD | \
+                     DESKTOP_READOBJECTS     | DESKTOP_SWITCHDESKTOP | \
+                     DESKTOP_WRITEOBJECTS    | DELETE                | \
+                     READ_CONTROL            | WRITE_DAC             | \
+                     WRITE_OWNER)
+
+#define GENERIC_ACCESS (GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL)
+
+int AddRightsToDesktop(HANDLE hToken);
+int AddRightsToDesktopBySid(PSID psid);
+
+#endif
diff --git a/contrib/win32/win32compat/gettimeofday.c b/contrib/win32/win32compat/gettimeofday.c
new file mode 100644
index 0000000..5050bca
--- /dev/null
+++ b/contrib/win32/win32compat/gettimeofday.c
@@ -0,0 +1,63 @@
+/*
+ * Author: NoMachine <developers@nomachine.com>
+ *
+ * Copyright (c) 2009, 2010 NoMachine
+ * All rights reserved
+ *
+ * Support functions and system calls' replacements needed to let the
+ * software run on Win32 based operating systems.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "includes.h"
+
+#include <windows.h>
+
+/* Difference in us between UNIX Epoch and Win32 Epoch */
+#define EPOCH_DELTA_US  11644473600000000ULL
+
+int
+gettimeofday (struct timeval *tv, void *tz)
+{
+	union
+	{
+		FILETIME ft;
+		unsigned long long ns;
+	} timehelper;
+	unsigned long long us;
+
+	/* Fetch time since Jan 1, 1601 in 100ns increments */
+	GetSystemTimeAsFileTime(&timehelper.ft);
+
+	/* Convert to microseconds from 100 ns units */
+	us = timehelper.ns / 10;
+
+	/* Remove the epoch difference */
+	us -= EPOCH_DELTA_US;
+
+	/* Stuff result into the timeval */
+	tv->tv_sec = (long) (us / 1000000ULL);
+	tv->tv_usec = (long) (us % 1000000ULL);
+
+	return 0;
+}
diff --git a/contrib/win32/win32compat/homedirhelp.c b/contrib/win32/win32compat/homedirhelp.c
new file mode 100644
index 0000000..4957d46
--- /dev/null
+++ b/contrib/win32/win32compat/homedirhelp.c
@@ -0,0 +1,187 @@
+/*
+ * Author: NoMachine <developers@nomachine.com>
+ *
+ * Copyright (c) 2009, 2011 NoMachine
+ * All rights reserved
+ *
+ * Support functions and system calls' replacements needed to let the
+ * software run on Win32 based operating systems.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <windows.h>
+#include <Lmcons.h>
+#include <Lm.h>
+#include <Userenv.h>
+#include <shlobj.h>
+#include <Shlwapi.h>
+
+#include "win32auth.h"
+
+char HomeDirLsa[MAX_PATH] = {'\0'};
+
+char *gethomedir(char *pUserName, char *pDomainName)
+{
+  HANDLE token;
+
+  PROFILEINFO profileInfo;
+  
+  char szPath[MAX_PATH];
+  
+  static char username[UNLEN + 1];
+  
+  DWORD usernamelen = UNLEN + 1;
+  
+  char *userprofile;
+
+  /*
+   * If there is home dir from lsa return it.
+   */
+  
+  if (HomeDirLsa[0] != '\0')
+  {
+    debug("Using LSA HomeDir.");
+    
+    return strdup(HomeDirLsa);
+  }
+
+  szPath[0] = '\0';
+
+  debug3("gethomedir: pUserName [%s]", pUserName);
+
+  GetUserName(username, &usernamelen);
+
+  debug3("gethomedir: username [%s]", username);
+
+  if (strcmp(pUserName, username) == 0)
+  {
+    /*
+     * User query his own home dir, we can take it from env.
+     */
+    
+    debug3("gethomedir: getenv");
+  
+    userprofile = getenv("USERPROFILE");
+    
+    if (userprofile)
+    {
+      debug3("gethomedir: userprofile [%s]", userprofile);
+      
+      /*
+       * We have a %USERPROFILE% and we can return it
+       */
+      
+      return strdup(userprofile);
+    }
+    
+    /*
+     * Env not set, let's try to take it from token
+     */
+  }
+
+  /*
+   * If all above fail try to create user token manually
+   * and get homedir using this token.
+   */
+  
+  #ifdef NX_USE_NTCREATETOKEN
+  
+  token = CreateUserToken(pUserName, pDomainName, "sshd");
+  
+  if (token == NULL)
+  {
+    debug("gethomedir: create token failed");
+
+    return NULL;
+  }
+
+  debug2("setting up profile info...");
+  
+  /*
+   * Become the user
+   */
+  
+  memset(&profileInfo, 0, sizeof(profileInfo));
+
+  profileInfo.dwSize = sizeof(profileInfo);
+  profileInfo.lpUserName = pUserName;
+  profileInfo.lpServerName = pDomainName;
+
+  debug2("LoadUserProfile()...");
+  
+  if (!LoadUserProfile(token, &profileInfo))
+  {
+    DWORD dwLast = GetLastError();
+  
+    debug("gethomedir: load profile failed [%d]", dwLast);
+    
+    return NULL;
+  }
+
+  /*
+   * Get user's home directory
+   */
+  
+  //if (!SUCCEEDED(SHGetFolderPath(NULL, CSIDL_APPDATA, token, 0, szPath)))
+  
+  debug2("SGGetFolderPath()...");
+  
+  if (!SUCCEEDED(SHGetFolderPath(NULL, CSIDL_PROFILE, token, 0, szPath)))
+  {
+    debug("gethomedir: get folder failed");
+
+    /*
+     * Become self again.
+     */
+
+    UnloadUserProfile(token, profileInfo.hProfile);
+
+    RevertToSelf();
+
+    CloseHandle(token);
+
+    return NULL;
+  }
+
+  debug3("gethomedir: szPath [%s]", szPath);
+
+  /*
+   * Become self again.
+   */
+  
+  UnloadUserProfile(token, profileInfo.hProfile);
+
+  RevertToSelf();
+  
+  CloseHandle(token);
+
+  debug2("<- gethomedir()...");
+  
+  return strdup(szPath);
+  
+  #else
+  
+  return NULL;
+  
+  #endif
+}
diff --git a/contrib/win32/win32compat/homedirhelp.h b/contrib/win32/win32compat/homedirhelp.h
new file mode 100644
index 0000000..d7c32d2
--- /dev/null
+++ b/contrib/win32/win32compat/homedirhelp.h
@@ -0,0 +1,45 @@
+/*
+ * Author: NoMachine <developers@nomachine.com>
+ *
+ * Copyright (c) 2009, 2010 NoMachine
+ * All rights reserved
+ *
+ * Support functions and system calls' replacements needed to let the
+ * software run on Win32 based operating systems.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef HOMEDIRHELP_H
+#define HOMEDIRHELP_H 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+char *gethomedir(const char *pUserName, const char *pDomainName);
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif
diff --git a/contrib/win32/win32compat/includes/arpa/inet.h b/contrib/win32/win32compat/includes/arpa/inet.h
new file mode 100644
index 0000000..315a52f
--- /dev/null
+++ b/contrib/win32/win32compat/includes/arpa/inet.h
@@ -0,0 +1,7 @@
+#ifndef COMPAT_INET_H
+#define COMPAT_INET_H 1
+
+/* NX */
+/* Compatibility header to avoid lots of #ifdef _WIN32's in includes.h */
+
+#endif
diff --git a/contrib/win32/win32compat/includes/arpa/nameser.h b/contrib/win32/win32compat/includes/arpa/nameser.h
new file mode 100644
index 0000000..98b9ef2
--- /dev/null
+++ b/contrib/win32/win32compat/includes/arpa/nameser.h
@@ -0,0 +1,7 @@
+#ifndef COMPAT_NAMESER_H
+#define COMPAT_NAMESER_H 1
+
+/* NX */
+/* Compatibility header to avoid lots of #ifdef _WIN32's in includes.h */
+
+#endif
diff --git a/contrib/win32/win32compat/includes/grp.h b/contrib/win32/win32compat/includes/grp.h
new file mode 100644
index 0000000..70ef71c
--- /dev/null
+++ b/contrib/win32/win32compat/includes/grp.h
@@ -0,0 +1,7 @@
+#ifndef COMPAT_GRP_H
+#define COMPAT_GRP_H 1
+
+/* NX */
+/* Compatibility header to avoid lots of #ifdef _WIN32's in includes.h */
+
+#endif
diff --git a/contrib/win32/win32compat/includes/kfwfix.h b/contrib/win32/win32compat/includes/kfwfix.h
new file mode 100644
index 0000000..7709087
--- /dev/null
+++ b/contrib/win32/win32compat/includes/kfwfix.h
@@ -0,0 +1,44 @@
+/*
+ * Author: NoMachine <developers@nomachine.com>
+ *
+ * Copyright (c) 2009, 2011 NoMachine
+ * All rights reserved
+ *
+ * Support functions and system calls' replacements needed to let the
+ * software run on Win32 based operating systems.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef KfwFix_H
+#define KfwFix_H
+
+#undef HAVE_STRING_H
+#undef HAVE_STRDUP
+#undef HAVE_GETADDRINFO
+#undef HAVE_GETNAMEINFO
+#undef HAVE_SYS_TYPES_H
+#undef HAVE_STDLIB_H
+
+#define SSIZE_T_DEFINED
+
+#endif
diff --git a/contrib/win32/win32compat/includes/netdb.h b/contrib/win32/win32compat/includes/netdb.h
new file mode 100644
index 0000000..cd71434
--- /dev/null
+++ b/contrib/win32/win32compat/includes/netdb.h
@@ -0,0 +1,7 @@
+#ifndef COMPAT_NETDB_H
+#define COMPAT_NETDB_H 1
+
+/* NX */
+/* Compatibility header to avoid lots of #ifdef _WIN32's in includes.h */
+
+#endif
diff --git a/contrib/win32/win32compat/includes/netinet/in.h b/contrib/win32/win32compat/includes/netinet/in.h
new file mode 100644
index 0000000..57a2661
--- /dev/null
+++ b/contrib/win32/win32compat/includes/netinet/in.h
@@ -0,0 +1,7 @@
+#ifndef COMPAT_IN_H
+#define COMPAT_IN_H 1
+
+/* NX */
+/* Compatibility header to avoid lots of #ifdef _WIN32's in includes.h */
+
+#endif
diff --git a/contrib/win32/win32compat/includes/netinet/in_systm.h b/contrib/win32/win32compat/includes/netinet/in_systm.h
new file mode 100644
index 0000000..eacbeac
--- /dev/null
+++ b/contrib/win32/win32compat/includes/netinet/in_systm.h
@@ -0,0 +1,7 @@
+#ifndef COMPAT_IN_SYSTM_H
+#define COMPAT_IN_SYSTM_H 1
+
+/* NX */
+/* Compatibility header to avoid lots of #ifdef _WIN32's in includes.h */
+
+#endif
diff --git a/contrib/win32/win32compat/includes/netinet/ip.h b/contrib/win32/win32compat/includes/netinet/ip.h
new file mode 100644
index 0000000..3c9577e
--- /dev/null
+++ b/contrib/win32/win32compat/includes/netinet/ip.h
@@ -0,0 +1,7 @@
+#ifndef COMPAT_IP_H
+#define COMPAT_IP_H 1
+
+/* NX */
+/* Compatibility header to avoid lots of #ifdef _WIN32's in includes.h */
+
+#endif
diff --git a/contrib/win32/win32compat/includes/netinet/tcp.h b/contrib/win32/win32compat/includes/netinet/tcp.h
new file mode 100644
index 0000000..0f2d93f
--- /dev/null
+++ b/contrib/win32/win32compat/includes/netinet/tcp.h
@@ -0,0 +1,7 @@
+#ifndef COMPAT_TCP_H
+#define COMPAT_TCP_H 1
+
+/* NX */
+/* Compatibility header to avoid lots of #ifdef _WIN32's in includes.h */
+
+#endif
diff --git a/contrib/win32/win32compat/includes/process.h b/contrib/win32/win32compat/includes/process.h
new file mode 100644
index 0000000..3703e6d
--- /dev/null
+++ b/contrib/win32/win32compat/includes/process.h
@@ -0,0 +1,7 @@
+#ifndef Process_H
+#define Process_H
+
+/* NX */
+/* Compatibility header to avoid lots of #ifdef _WIN32's in includes.h */
+
+#endif
diff --git a/contrib/win32/win32compat/includes/pwd.h b/contrib/win32/win32compat/includes/pwd.h
new file mode 100644
index 0000000..b990eed
--- /dev/null
+++ b/contrib/win32/win32compat/includes/pwd.h
@@ -0,0 +1,32 @@
+#ifndef COMPAT_PWD_H
+#define COMPAT_PWD_H 1
+
+/* NX */
+/* Compatibility header to give us pwd-like functionality on Win32 */
+
+struct passwd
+{
+	char	*pw_name;	/* user's login name */
+	char	*pw_passwd;	/* password? */
+	char	*pw_gecos;	/* ??? */
+	uid_t	pw_uid;		/* numerical user ID */
+	gid_t	pw_gid;		/* numerical group ID */
+	char	*pw_dir;	/* initial working directory */
+	char	*pw_shell;	/* path to shell */
+};
+
+uid_t getuid(void);
+gid_t getgid(void);
+uid_t geteuid(void);
+gid_t getegid(void);
+int setuid(uid_t uid);
+int setgid(gid_t gid);
+int seteuid(uid_t uid);
+int setegid(gid_t gid);
+struct passwd *getpwuid(uid_t uid);
+struct passwd *getpwnam(const char *username);
+void endpwent(void);
+
+typedef int PWD_USER_TOKEN; /* This is really just a HANDLE, but we might not have windows.h included */
+PWD_USER_TOKEN PwdCreateUserToken(const char *pUserName, const char *pDomainName, const char *pSourceName);
+#endif
diff --git a/contrib/win32/win32compat/includes/resolv.h b/contrib/win32/win32compat/includes/resolv.h
new file mode 100644
index 0000000..b3b5858
--- /dev/null
+++ b/contrib/win32/win32compat/includes/resolv.h
@@ -0,0 +1,7 @@
+#ifndef COMPAT_RESOLV_H
+#define COMPAT_RESOLV_H 1
+
+/* NX */
+/* Compatibility header to avoid lots of #ifdef _WIN32's in includes.h */
+
+#endif
diff --git a/contrib/win32/win32compat/includes/sys/ioctl.h b/contrib/win32/win32compat/includes/sys/ioctl.h
new file mode 100644
index 0000000..e013f32
--- /dev/null
+++ b/contrib/win32/win32compat/includes/sys/ioctl.h
@@ -0,0 +1,7 @@
+#ifndef COMPAT_IOCTL_H
+#define COMPAT_IOCTL_H 1
+
+/* NX */
+/* Compatibility header to avoid lots of #ifdef _WIN32's in includes.h */
+
+#endif
diff --git a/contrib/win32/win32compat/includes/sys/param.h b/contrib/win32/win32compat/includes/sys/param.h
new file mode 100644
index 0000000..c2810f7
--- /dev/null
+++ b/contrib/win32/win32compat/includes/sys/param.h
@@ -0,0 +1,7 @@
+#ifndef COMPAT_PARAM_H
+#define COMPAT_PARAM_H 1
+
+/* NX */
+/* Compatibility header to avoid lots of #ifdef _WIN32's in includes.h */
+
+#endif
diff --git a/contrib/win32/win32compat/includes/sys/resource.h b/contrib/win32/win32compat/includes/sys/resource.h
new file mode 100644
index 0000000..06b8916
--- /dev/null
+++ b/contrib/win32/win32compat/includes/sys/resource.h
@@ -0,0 +1,7 @@
+#ifndef COMPAT_RESOURCE_H
+#define COMPAT_RESOURCE_H 1
+
+/* NX */
+/* Compatibility header to avoid lots of #ifdef _WIN32's in includes.h */
+
+#endif
diff --git a/contrib/win32/win32compat/includes/sys/select.h b/contrib/win32/win32compat/includes/sys/select.h
new file mode 100644
index 0000000..cd145a4
--- /dev/null
+++ b/contrib/win32/win32compat/includes/sys/select.h
@@ -0,0 +1,7 @@
+#ifndef COMPAT_SELECT_H
+#define COMPAT_SELECT_H 1
+
+/* NX */
+/* Compatibility header to avoid lots of #ifdef _WIN32's in includes.h */
+
+#endif
diff --git a/contrib/win32/win32compat/includes/sys/socket.h b/contrib/win32/win32compat/includes/sys/socket.h
new file mode 100644
index 0000000..deae424
--- /dev/null
+++ b/contrib/win32/win32compat/includes/sys/socket.h
@@ -0,0 +1,155 @@
+#ifndef _LIBWINSOCKHELP_SOCKET_H_
+#define _LIBWINSOCKHELP_SOCKET_H_ 1
+
+/* Include the original header */
+#define WIN32_LEAN_AND_MEAN 1
+#define _WIN32_WINNT 0x501
+#include <winsock2.h>
+#include <Ws2tcpip.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+/* Set to 1 (macros as function decl's) or 0 (simple macros) depending upon needs */
+#define NEED_FUNC_MACROS 0
+
+
+/* Declare our indirection functions */
+FILE* WSHELPfdopen(int sfd, const char *mode);
+int WSHELPfstat(int sfd, struct stat *buf);
+int WSHELPisatty (int sfd);
+int WSHELPpipe(int *pfds);
+int WSHELPdup (int oldfd);
+int WSHELPdup2(int oldfd, int newfd);
+int WSHELPopen (const char *pathname, int flags, ...);
+int WSHELPcreat (const char *pathname, int mode);
+int WSHELPsocket (int af, int type, int protocol);
+int WSHELPsetsockopt (int sfd, int level, int optname, const char* optval, int optlen);
+int WSHELPgetsockopt(int sfd, int level, int optname, char* optval, int* optlen);
+int WSHELPgetsockname(int sfd, struct sockaddr* name, int* namelen);
+int WSHELPgetpeername(int sfd, struct sockaddr* name, int* namelen);
+int WSHELPioctlsocket(int sfd, long cmd, u_long* argp);
+int WSHELPlisten (int sfd, int backlog);
+int WSHELPbind (int sfd, const struct sockaddr *name, int namelen);
+int WSHELPconnect (int sfd, const struct sockaddr* name, int namelen);
+int WSHELPshutdown(int sfd, int how);
+int WSHELPaccept(int sfd, struct sockaddr* addr, int* addrlen);
+int WSHELPselect (int sfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, const struct timeval *timeout);
+
+/* Other helpers */
+void WSHELPinitialize();
+int map_standard_descriptor(int *fd);
+void allocate_standard_descriptor(int fd);
+
+/* Redirect callers of socket functions to use our indirection functions */
+#if NEED_FUNC_MACROS
+#define isatty(sfd)								WSHELPisatty(sfd)
+#define fstat(sfd, buf)                                                         WSHELPfstat(sfd, buf)
+#define fdopen(sfd, mode)                                                       WSHELPfdopen(sfd, mode)
+#define pipe(pfds)								WSHELPpipe(pfds)
+#define dup(oldfd)                                                              WSHELPdup(oldfd)
+#define socket(af, type, protocol)						WSHELPsocket(af, type, protocol)
+#define setsockopt(sfd, level, optname, optval, optlen)				WSHELPsetsockopt(sfd, level, optname, optval, optlen)
+#define getsockopt(sfd, level, optname, optval, optlen)				WSHELPgetsockopt(sfd, level, optname, optval, optlen)
+#define getsockname(sfd, name, namelen)						WSHELPgetsockname(sfd, name, namelen)
+#define getpeername(sfd, name, namelen)						WSHELPgetpeername(sfd, name, namelen)
+#define ioctlsocket(sfd, cmd, argp)						WSHELPioctlsocket(sfd, cmd, argp)
+#define listen(sfd, backlog)							WSHELPlisten(sfd, backlog)
+#define bind(sfd, name, namelen)						WSHELPbind(sfd, name, namelen)
+#define connect(sfd, name, namelen)						WSHELPconnect(sfd, name, namelen)
+#define shutdown(sfd, how)							WSHELPshutdown(sfd, how)
+#define accept(sfd, addr, addrlen)						WSHELPaccept(sfd, addr, addrlen)
+#define select(sfds, readsfds, writesfds, exceptsfds, timeout)		        WSHELPselect(sfds, readsfds, writesfds, exceptsfds, timeout)
+#else /* NEED_FUNC_MACROS */
+//#define isatty				WSHELPisatty
+#define fstat                           WSHELPfstat
+#define fdopen                          WSHELPfdopen
+#define pipe				WSHELPpipe
+#define socket				WSHELPsocket
+#define dup                             WSHELPdup
+#define dup2                            WSHELPdup2
+#define open                            WSHELPopen
+#define creat                           WSHELPcreat
+#define setsockopt			WSHELPsetsockopt
+#define getsockopt			WSHELPgetsockopt
+#define getsockname			WSHELPgetsockname
+#define getpeername			WSHELPgetpeername
+#define ioctlsocket			WSHELPioctlsocket
+#define listen				WSHELPlisten
+#define bind				WSHELPbind
+#define connect				WSHELPconnect
+#define shutdown			WSHELPshutdown
+#define accept				WSHELPaccept
+#define select				WSHELPselect
+#endif /* NEED_FUNC_MACROS */
+
+/* Declare new functions */
+int socketpair(int socks[2]);
+
+/* Debug helpers */
+void debug_sfd(int sfd);
+
+/* Include the original header */
+#include <io.h>
+
+/* Declare our indirection functions */
+int WSHELPread(int sfd, void *dst, unsigned int max);
+int WSHELPwrite(int sfd, const void *buf, unsigned int max);
+int WSHELPclose(int sfd);
+
+/* Redirect callers of io functions to use our indirection functions */
+#if NEED_FUNC_MACROS
+#define read(fd, dst, max)		WSHELPread(fd, dst, max)
+#define write(fd, buf, max)		WSHELPwrite(fd, buf, max)
+#define close(fd)			WSHELPclose(fd)
+#else /* NEED_FUNC_MACROS */
+#define read WSHELPread
+#define write WSHELPwrite
+#define close WSHELPclose
+#endif /* NEED_FUNC_MACROS */
+
+#ifndef sleep
+#define sleep(a) Sleep(1000 * a)
+#endif
+
+/* Shutdown constants */
+#define SHUT_WR SD_SEND
+#define SHUT_RD SD_RECEIVE
+#define SHUT_RDWR SD_BOTH
+
+/* Other constants */
+#define IN_LOOPBACKNET	127 /* 127.* is the loopback network */
+
+#ifndef MAXHOSTNAMELEN
+#define MAXHOSTNAMELEN	64
+#endif
+
+
+/* Errno helpers */
+#define ENETDOWN		WSAENETDOWN
+#define EAFNOSUPPORT            WSAEAFNOSUPPORT
+#define	EINPROGRESS		WSAEINPROGRESS
+#define EXX			WSAEMFILE
+#define EXX1			WSAENOBUFS
+#define EPROTONOSUPPORT	        WSAEPROTONOSUPPORT
+#define EPROTOTYPE		WSAEPROTOTYPE
+#define	ESOCKTNOSUPPORT         WSAESOCKTNOSUPPORT
+#define EADDRINUSE		WSAEADDRINUSE
+// in errno.h #define EINVAL			WSAEINVAL
+#define EISCONN			WSAEISCONN
+#define ENOTSOCK		WSAENOTSOCK
+#define EOPNOTSUPP		WSAENOTSUPP
+// in errno.h #define EINTR			WSAEINTR
+#define EALREADY		WSAEALREADY
+#define	ECONNREFUSED	        WSAECONNREFUSED
+// in errno.h #define	EFAULT			WSAEFAULT
+#define ENOTUNREACH		WSAENOTUNREACH
+#define EHOSTUNREACH	        WSAEHOSTUNREACH
+#define ETIMEDOUT		WSAETIMEDOUT
+#define EWOULDBLOCK		WSAEWOULDBLOCK
+#define	EACCESS			WSAEACCESS
+#define ECONNRESET		WSAECONNRESET
+#define ENOPROTOOPT		WSAENOPROTOOPT
+#define EPFNOSUPPORT	        WSAEPFNOSUPPORT
+#define ENOTCONN		WSAENOTCONN
+#endif
diff --git a/contrib/win32/win32compat/includes/sys/time.h b/contrib/win32/win32compat/includes/sys/time.h
new file mode 100644
index 0000000..2ec0c88
--- /dev/null
+++ b/contrib/win32/win32compat/includes/sys/time.h
@@ -0,0 +1,7 @@
+#ifndef COMPAT_TIME_H
+#define COMPAT_TIME_H 1
+
+/* NX */
+/* Compatibility header to avoid lots of #ifdef _WIN32's in includes.h */
+
+#endif
diff --git a/contrib/win32/win32compat/includes/sys/types.h b/contrib/win32/win32compat/includes/sys/types.h
new file mode 100644
index 0000000..8232373
--- /dev/null
+++ b/contrib/win32/win32compat/includes/sys/types.h
@@ -0,0 +1,40 @@
+#ifndef COMPAT_TYPES_H
+#define COMPAT_TYPES_H 1
+
+/* NX */
+/* Compatibility header to allow code that uses these types to compile on Win32 */
+
+typedef unsigned int uid_t;
+typedef unsigned int gid_t;
+typedef long _off_t;
+typedef long off_t;
+typedef unsigned int _dev_t;
+typedef unsigned int dev_t;				/* device code */
+typedef unsigned short _ino_t;			/* i-node number */
+typedef unsigned short ino_t;
+
+#if defined(__MINGW32__)
+
+typedef unsigned short _mode_t;
+typedef _mode_t mode_t;
+
+typedef long time_t;
+typedef long long __time64_t;
+typedef long long off64_t;
+
+/* On Win32 group and other permissions are the same as user permissions, sort of */
+/*
+FIXME: GFPZR: In newer GCC versions these seems to be defined.
+*/
+/*
+#ifndef S_IXGRP
+#define S_IXGRP S_IXUSR
+#endif
+
+#ifndef S_IXOTH
+#define S_IXOTH S_IXUSR
+#endif
+*/
+#endif
+
+#endif
diff --git a/contrib/win32/win32compat/includes/sys/uio.h b/contrib/win32/win32compat/includes/sys/uio.h
new file mode 100644
index 0000000..6774166
--- /dev/null
+++ b/contrib/win32/win32compat/includes/sys/uio.h
@@ -0,0 +1,25 @@
+#ifndef COMPAT_UIO_H
+#define COMPAT_UIO_H 1
+
+/* NX */
+/* Compatibility header to avoid #ifdefs on Win32 */
+
+#include <sys/socket.h>
+
+#define _O_BINARY       0x8000
+
+/* All socket io stuff has been replaced with read/Close/Write, so this works now */
+//#define open	_open
+//#define pipe(a)	_pipe(a, 2048, _O_BINARY)
+//#define dup		_dup
+//#define dup2	_dup2
+
+#ifdef __MINGW32__
+struct iovec
+{
+	void *iov_base;
+	size_t iov_len;
+};
+#endif
+
+#endif
diff --git a/contrib/win32/win32compat/includes/sys/un.h b/contrib/win32/win32compat/includes/sys/un.h
new file mode 100644
index 0000000..7fb35cf
--- /dev/null
+++ b/contrib/win32/win32compat/includes/sys/un.h
@@ -0,0 +1,7 @@
+#ifndef COMPAT_UN_H
+#define COMPAT_UN_H 1
+
+/* NX */
+/* Compatibility header to avoid lots of #ifdef _WIN32's in includes.h */
+
+#endif
diff --git a/contrib/win32/win32compat/includes/sys/wait.h b/contrib/win32/win32compat/includes/sys/wait.h
new file mode 100644
index 0000000..717b4e0
--- /dev/null
+++ b/contrib/win32/win32compat/includes/sys/wait.h
@@ -0,0 +1,7 @@
+#ifndef COMPAT_WAIT_H
+#define COMPAT_WAIT_H 1
+
+/* NX */
+/* Compatibility header to avoid lots of #ifdef _WIN32's in includes.h */
+
+#endif
diff --git a/contrib/win32/win32compat/includes/syslog.h b/contrib/win32/win32compat/includes/syslog.h
new file mode 100644
index 0000000..e167bfa
--- /dev/null
+++ b/contrib/win32/win32compat/includes/syslog.h
@@ -0,0 +1,30 @@
+#ifndef COMPAT_SYSLOG_H
+#define COMPAT_SYSLOG_H 1
+
+/* NX */
+/* Compatibility header to give us some syslog-like functionality on Win32 */
+
+#define LOG_CRIT	(2)				/* critical */
+#define LOG_ERR		(3)				/* errors */
+#define LOG_WARNING	(4)				/* warnings */
+#define	LOG_INFO	(6)				/* informational */
+#define LOG_DEBUG	(7)				/* debug messages */
+#define LOG_USER	(1 << 3)		/* user level messages */
+#define LOG_DAEMON	(3 << 3)		/* daemons/servers */
+#define LOG_AUTH	(4 << 3)		/* security messages */
+#define LOG_LOCAL0	(16 << 3)		/* reserved for local use */
+#define LOG_LOCAL1	(17 << 3)		/* reserved for local use */
+#define LOG_LOCAL2	(18 << 3)		/* reserved for local use */
+#define LOG_LOCAL3	(19 << 3)		/* reserved for local use */
+#define LOG_LOCAL4	(20 << 3)		/* reserved for local use */
+#define LOG_LOCAL5	(21 << 3)		/* reserved for local use */
+#define LOG_LOCAL6	(22 << 3)		/* reserved for local use */
+#define LOG_LOCAL7	(23 << 3)		/* reserved for local use */
+
+#define LOG_PID		0x01			/* log the pid */
+
+void openlog	(char *, unsigned int, int);
+void closelog	(void);
+void syslog		(int, const char *, const char *);
+
+#endif
diff --git a/contrib/win32/win32compat/includes/termios.h b/contrib/win32/win32compat/includes/termios.h
new file mode 100644
index 0000000..656bb0f
--- /dev/null
+++ b/contrib/win32/win32compat/includes/termios.h
@@ -0,0 +1,42 @@
+#ifndef COMPAT_TERMIOS_H
+#define COMPAT_TERMIOS_H 1
+
+/* NX */
+/* Compatibility header to allow some termios functionality to compile without #ifdefs */
+
+#define VDISCARD	1
+#define VEOL		2
+#define VEOL2		3
+#define VEOF		4
+#define VERASE		5
+#define VINTR		6
+#define VKILL		7
+#define VLNEXT		8
+#define VMIN		9
+#define VQUIT		10
+#define VREPRINT	11
+#define VSTART		12
+#define VSTOP		13
+#define VSUSP		14
+#define VSWTC		15
+#define VTIME		16
+#define VWERASE		17
+#define NCCS		18
+
+typedef unsigned char cc_t;
+typedef unsigned int  tcflag_t;
+typedef unsigned int  speed_t;
+
+struct termios
+{
+  tcflag_t	c_iflag;
+  tcflag_t	c_oflag;
+  tcflag_t	c_cflag;
+  tcflag_t	c_lflag;
+  char		c_line;
+  cc_t		c_cc[NCCS];
+  speed_t	c_ispeed;
+  speed_t	c_ospeed;
+};
+
+#endif
diff --git a/contrib/win32/win32compat/includes/unistd.h b/contrib/win32/win32compat/includes/unistd.h
new file mode 100644
index 0000000..1873204
--- /dev/null
+++ b/contrib/win32/win32compat/includes/unistd.h
@@ -0,0 +1,23 @@
+#ifndef COMPAT_UNISTD_H
+#define COMPAT_UNISTD_H 1
+
+/* NX */
+/* Compatibility header to avoid lots of #ifdefs in includes.h on Win32 */
+
+#include <sys/uio.h>
+#include <conio.h>
+#include <direct.h>
+
+/* We can't put these in string.h since we can't easily override that header, so here they are */
+#if !defined(HAVE_STRCASECMP) && !defined(__MINGW32__)
+size_t strcasecmp(const char *left, const char *right);
+#endif
+
+#if !defined(HAVE_STRNCASECMP) && !defined(__MINGW32__)
+size_t strncasecmp(const char *left, const char *right, size_t n);
+#endif
+
+int gettimeofday (struct timeval *tv, void *tz);
+/* End of prototypes in the wrong file */
+
+#endif
diff --git a/contrib/win32/win32compat/kerberos.c b/contrib/win32/win32compat/kerberos.c
new file mode 100644
index 0000000..a74ccf7
--- /dev/null
+++ b/contrib/win32/win32compat/kerberos.c
@@ -0,0 +1,248 @@
+/*
+ * Author: NoMachine <developers@nomachine.com>
+ *
+ * Copyright (c) 2009, 2012 NoMachine
+ * All rights reserved
+ *
+ * Support functions and system calls' replacements needed to let the
+ * software run on Win32 based operating systems.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "includes.h"
+
+#ifdef KRB5
+#ifdef GSSAPI
+
+#include "kerberos.h"
+
+/*
+ * Handles to runtime loaded MIT KfW libraries.
+ */
+ 
+static HMODULE Krb5_32  = NULL;
+static HMODULE Comerr32 = NULL;
+static HMODULE Gssapi32 = NULL;
+
+/*
+ * Pointers to runtime loaded KfW functions.
+ */
+
+static struct _MitDispatch
+{
+  /*
+   * gssapi32.dll.
+   */
+   
+  gss_indicate_mechs_ptr gss_indicate_mechs;
+  gss_release_buffer_ptr gss_release_buffer;
+  gss_display_status_ptr gss_display_status;
+  gss_delete_sec_context_ptr gss_delete_sec_context;
+  gss_release_name_ptr gss_release_name;
+  gss_release_cred_ptr gss_release_cred;
+  gss_init_sec_context_ptr gss_init_sec_context;
+  gss_import_name_ptr gss_import_name;
+  gss_get_mic_ptr gss_get_mic;
+
+  /*
+   * krb5_32.dll.
+   */
+
+  krb5_free_context_ptr krb5_free_context;
+  krb5_free_principal_ptr krb5_free_principal;
+  krb5_cc_destroy_ptr krb5_cc_destroy;
+} MitDispatch = {0};
+
+/*
+ * This global variable is exported by gssapi32.dll.
+ */
+ 
+gss_OID gss_nt_service_name;
+
+/*
+ * Try loads MIT Kerberos for Windows libraries. This function  
+ * must be called before use Kerberos functions.
+ *
+ * RETURNS: 0 if OK.
+ */
+ 
+int InitMitKerberos()
+{
+  int exitCode = -1;
+
+  void *serviceNamePtr = NULL;
+  
+  
+  /*
+   * Load functions from gssapi32.dll.
+   */
+
+  debug("Loading gssapi32.dll...");
+  
+  FAIL((Gssapi32 = LoadLibrary("gssapi32.dll")) == NULL);
+  
+  FAIL((GET_MIT_FUNCTION(Gssapi32, gss_indicate_mechs)) == NULL);
+  FAIL((GET_MIT_FUNCTION(Gssapi32, gss_release_buffer)) == NULL);
+  FAIL((GET_MIT_FUNCTION(Gssapi32, gss_display_status)) == NULL);
+  FAIL((GET_MIT_FUNCTION(Gssapi32, gss_delete_sec_context)) == NULL);
+  FAIL((GET_MIT_FUNCTION(Gssapi32, gss_release_name)) == NULL);
+  FAIL((GET_MIT_FUNCTION(Gssapi32, gss_release_cred)) == NULL);
+  FAIL((GET_MIT_FUNCTION(Gssapi32, gss_init_sec_context)) == NULL);
+  FAIL((GET_MIT_FUNCTION(Gssapi32, gss_import_name)) == NULL);
+  FAIL((GET_MIT_FUNCTION(Gssapi32, gss_get_mic)) == NULL);
+
+  /*
+   * This is global variable exported by gssapi32.dll.
+   * Note, that we reveive POINTER not VALUE, so we need to
+   * do memcpy in this case.
+   */
+   
+  serviceNamePtr = GetProcAddress(Gssapi32, "gss_nt_service_name");
+  
+  FAIL(serviceNamePtr == NULL);
+  
+  memcpy(&gss_nt_service_name, serviceNamePtr, sizeof(gss_OID));
+  
+  /*
+   * Load functions from krb5_32.dll.
+   */
+  
+  debug("Loading krb5_32.dll...");
+  
+  FAIL((Krb5_32 = (HMODULE) LoadLibrary("krb5_32.dll")) == NULL);
+  
+  FAIL((GET_MIT_FUNCTION(Krb5_32, krb5_free_context)) == NULL);
+  FAIL((GET_MIT_FUNCTION(Krb5_32, krb5_free_principal)) == NULL);
+  FAIL((GET_MIT_FUNCTION(Krb5_32, krb5_cc_destroy)) == NULL);
+
+  /*
+   * Error handler.
+   */
+   
+  exitCode = 0;
+
+  fail:
+  
+  if (exitCode)
+  {
+    UninitMitKerberos();
+    
+    error("Cannot load MIT KfW libraries. Error code is: %u.\n"
+              "Please ensure that path to these libraries is properly "
+                  "set in your PATH variable.\n", GetLastError());
+  }
+  
+  return exitCode;
+}
+
+/*
+ * Free MIT KfW libraries if loaded before.
+ */
+ 
+void UninitMitKerberos()
+{
+  FreeLibrary(Krb5_32);
+  FreeLibrary(Comerr32);
+  FreeLibrary(Gssapi32);
+}
+
+/*
+ * Fake GSSAPI functions. We pass control to runtime loaded
+ * KfW libs here.
+ */
+
+KFW_CALL gss_indicate_mechs(OM_uint32 *a, gss_OID_set *b)
+{
+  return MitDispatch.gss_indicate_mechs(a, b);
+}
+
+KFW_CALL gss_release_buffer(OM_uint32 *a, gss_buffer_t b)
+{
+  return MitDispatch.gss_release_buffer(a, b);
+}
+
+KFW_CALL gss_display_status(OM_uint32 *a, OM_uint32 b, int c, gss_OID d, 
+                                OM_uint32 *e, gss_buffer_t f)
+{
+  return MitDispatch.gss_display_status(a, b, c, d, e, f);
+}
+
+KFW_CALL gss_delete_sec_context(OM_uint32 *a, gss_ctx_id_t *b, gss_buffer_t c)
+{
+  return MitDispatch.gss_delete_sec_context(a, b, c);
+}
+
+KFW_CALL gss_release_name(OM_uint32 *a, gss_name_t *b)
+{
+  return MitDispatch.gss_release_name(a, b);
+}
+
+KFW_CALL gss_release_cred(OM_uint32 *a, gss_cred_id_t *b)
+{
+  return MitDispatch.gss_release_cred(a, b);
+}
+
+KFW_CALL gss_init_sec_context(OM_uint32 *a, gss_cred_id_t b,
+                                  gss_ctx_id_t *c, gss_name_t d,
+                                      gss_OID e, OM_uint32 f,
+                                          OM_uint32 g, gss_channel_bindings_t h,
+                                              gss_buffer_t i, gss_OID * j,
+                                                  gss_buffer_t k, OM_uint32 *l,
+                                                      OM_uint32 *m)
+{
+  return MitDispatch.gss_init_sec_context(a, b, c, d, e, f, g, h, i, j, k, l, m);
+}
+
+KFW_CALL gss_import_name(OM_uint32 *a, gss_buffer_t b, gss_OID c, gss_name_t *d)
+{
+  return MitDispatch.gss_import_name(a, b, c, d);
+}
+
+KFW_CALL gss_get_mic(OM_uint32 *a, gss_ctx_id_t b, gss_qop_t c,
+                         gss_buffer_t d, gss_buffer_t e)
+{
+  return MitDispatch.gss_get_mic(a, b, c, d, e);
+}
+
+/*
+ * Fake KRB5 functions. We pass control to runtime loaded
+ * KfW libs here.
+ */
+
+void KRB5_CALLCONV krb5_free_context(krb5_context a)
+{
+  MitDispatch.krb5_free_context(a);
+}
+
+void KRB5_CALLCONV krb5_free_principal(krb5_context a, krb5_principal b)
+{
+  MitDispatch.krb5_free_principal(a, b);
+}
+
+krb5_error_code KRB5_CALLCONV krb5_cc_destroy(krb5_context a, krb5_ccache b)
+{
+  return MitDispatch.krb5_cc_destroy(a, b);
+}
+
+#endif /* GSSAPI */
+#endif /* KRB5 */
diff --git a/contrib/win32/win32compat/kerberos.h b/contrib/win32/win32compat/kerberos.h
new file mode 100644
index 0000000..a070ab8
--- /dev/null
+++ b/contrib/win32/win32compat/kerberos.h
@@ -0,0 +1,98 @@
+/*
+ * Author: NoMachine <developers@nomachine.com>
+ *
+ * Copyright (c) 2009, 2012 NoMachine
+ * All rights reserved
+ *
+ * Support functions and system calls' replacements needed to let the
+ * software run on Win32 based operating systems.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef Kerberos_H
+#define Kerberos_H
+
+#include <windows.h>
+
+#include "kfwfix.h"
+
+#include "Debug.h"
+#include <windows.h>
+#include <krb5.h>
+#include <gssapi/gssapi.h>
+
+int InitMitKerberos();
+void UninitMitKerberos();
+
+/*
+ * Helper macros for load functions from KfW DLLs and
+ * put it to MitDispatch table, where we store KfW API functions.
+ */
+ 
+#define GET_SYM(MODULE, F) (F ## _ptr) GetProcAddress(MODULE, #F)
+#define GET_MIT_FUNCTION(MODULE, F) MitDispatch.F = GET_SYM(MODULE, F)
+
+/*
+ * Function prototypes for MIT KfW libs. We need it
+ * for load libs at runtime. Note, we add only functions
+ * needed by ssh client here.
+ */
+ 
+#define KFW_CALL OM_uint32 KRB5_CALLCONV
+
+typedef KFW_CALL (*gss_indicate_mechs_ptr)(OM_uint32 *, gss_OID_set *);
+typedef KFW_CALL (*gss_release_buffer_ptr)(OM_uint32 *, gss_buffer_t);
+
+typedef KFW_CALL (*gss_display_status_ptr)(OM_uint32 *, OM_uint32, int, 
+                                       gss_OID, OM_uint32 *, gss_buffer_t);
+
+typedef KFW_CALL (*gss_delete_sec_context_ptr)(OM_uint32 *, gss_ctx_id_t *, 
+                                           gss_buffer_t);
+
+typedef KFW_CALL (*gss_release_name_ptr)(OM_uint32 *, gss_name_t *);
+typedef KFW_CALL (*gss_release_cred_ptr)(OM_uint32 *, gss_cred_id_t *);
+
+typedef KFW_CALL (*gss_init_sec_context_ptr)(OM_uint32 *, gss_cred_id_t,
+                                         gss_ctx_id_t *, gss_name_t,
+                                             gss_OID, OM_uint32, OM_uint32, 
+                                                 gss_channel_bindings_t,
+                                                     gss_buffer_t, gss_OID *,
+                                                         gss_buffer_t, OM_uint32 *,
+                                                             OM_uint32 *);
+
+typedef KFW_CALL (*gss_import_name_ptr)(OM_uint32 *, gss_buffer_t, 
+                                            gss_OID, gss_name_t *);
+
+typedef OM_uint32 KRB5_CALLCONV (*gss_get_mic_ptr)(OM_uint32 *, gss_ctx_id_t, 
+                                                       gss_qop_t, gss_buffer_t, 
+                                                           gss_buffer_t);
+
+typedef void KRB5_CALLCONV (*krb5_free_context_ptr)(krb5_context);
+
+typedef void KRB5_CALLCONV (*krb5_free_principal_ptr)(krb5_context,
+                                                          krb5_principal);
+                                                          
+typedef krb5_error_code KRB5_CALLCONV (*krb5_cc_destroy_ptr)(krb5_context, 
+                                                                 krb5_ccache);
+
+#endif
diff --git a/contrib/win32/win32compat/lsalogon.c b/contrib/win32/win32compat/lsalogon.c
new file mode 100644
index 0000000..4a6c32e
--- /dev/null
+++ b/contrib/win32/win32compat/lsalogon.c
@@ -0,0 +1,382 @@
+/*
+ * Author: NoMachine <developers@nomachine.com>
+ *
+ * Copyright (c) 2009, 2012 NoMachine
+ * All rights reserved
+ *
+ * Support functions and system calls' replacements needed to let the
+ * software run on Win32 based operating systems.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "lsalogon.h"
+#include "Debug.h"
+
+/*
+ * Allocate new NXAuth struct and initialize it with given auth data.
+ * This function is needed becouse:
+ *
+ * a) LSA needs one continous memory block on input.
+ *
+ * b) We can't send pointers in auth data to LSA 'server', becouse
+ *    LSA package can be 32 or 64 bit and the same to client application.
+ *    Client and Server must be compatible, so all fields must have the
+ *    same size in lsa 'server' and logon client application.
+ *
+ * So, we allocate one 'big' NXAuth struct and copy to it all
+ * needed auth data. 
+ *
+ * nxauth     - new allocated NXAuth struct (OUT)
+ * user       - user name (IN)
+ * pkblob     - public key blob (IN)
+ * blen       - pkblob size in bytes (IN)
+ * sign       - signature (IN)
+ * signSize   - signature size in bytes (IN)
+ * data       - We copy it from nxssh auth code (IN)
+ * dataSize   - size of data field in bytes (IN)
+ * dataFellow - We pass global 'datafellow' variable from nxsshd here (IN)
+ *
+ * RETURNS: 0 if OK.
+ */
+
+int AllocNXAuth(NXAuth **nxAuth, char *user, char *pkBlob, 
+                    int pkBlobSize, char *sign, int signSize, 
+                        char *data, int dataSize, int dataFellow)
+{
+  int exitCode = 1;
+  
+  /*
+   * Pointers to fields in local allocated NXAuth struct.
+   */
+  
+  char *userPtr = NULL;
+  char *signPtr = NULL;
+  char *dataPtr = NULL;
+  char *blobPtr = NULL;
+  
+  /*
+   * Are arguments ok?
+   */
+    
+  debug("Checking args...");
+  
+  FAIL(user == NULL);
+  FAIL(nxAuth == NULL);
+  FAIL(pkBlob == NULL);
+  FAIL(sign == NULL);
+  FAIL(signSize == 0);
+  FAIL(dataSize == 0);
+  FAIL(pkBlobSize == 0);
+  
+  *nxAuth = NULL;
+  
+  /*
+   * Compute total size of NXAuth struct.
+   */
+  
+  debug("Computing total size of NXAuth...");
+  
+  int userSize = strlen(user) + 1;
+  
+  int totalSize = sizeof(NXAuth) + userSize + signSize + dataSize + pkBlobSize;
+  
+  /*
+   * Allocate new NXAuth struct.
+   */
+  
+  debug("Allocating new NXAuth structure...");
+
+  *nxAuth = (NXAuth *) malloc(totalSize);
+  
+  FAIL(*nxAuth == NULL);
+  
+  /*
+   * Store sizes of fields in NXAuth.
+   */
+  
+  (*nxAuth) -> totalSize_  = totalSize;  
+  (*nxAuth) -> userSize_   = userSize;
+  (*nxAuth) -> signSize_   = signSize;  
+  (*nxAuth) -> dataSize_   = dataSize;  
+  (*nxAuth) -> pkBlobSize_ = pkBlobSize;  
+
+  /*
+   * Compute adressess of fields.
+   */
+  
+  userPtr = (char *) &((*nxAuth) -> buf_);
+  signPtr = (char *) (userPtr + userSize);
+  dataPtr = (char *) (signPtr + signSize);
+  blobPtr = (char *) (dataPtr + dataSize);
+  
+  /*
+   * Copy input buffers into structure's fields.
+   */
+  
+  debug("Filling up NXAuth struct...");
+  
+  memcpy(userPtr, user, userSize);
+  memcpy(signPtr, sign, signSize);
+  memcpy(dataPtr, data, dataSize);
+  memcpy(blobPtr, pkBlob, pkBlobSize);
+  
+  (*nxAuth) -> dataFellow_ = dataFellow;
+
+  exitCode = 0;   
+  
+fail:
+
+  /*
+   * Clean up if function fails.
+   */
+  
+  if (exitCode)
+  {
+    debug("ERROR. Cannot create NXAuth struct (%u).", GetLastError());
+    
+    if (nxAuth && *nxAuth)
+    {
+      free(*nxAuth);
+      
+      *nxAuth = NULL;
+    }
+  }
+  
+  return exitCode;
+}
+
+/*
+ * Try to logon using NXLsa package.
+ * 
+ * hToken     - user token if success (OUT)
+ * user       - user name (IN)
+ * pkblob     - public key blob (IN)
+ * blen       - pkblob size in bytes (IN)
+ * sign       - signature (IN)
+ * signSize   - signature size in bytes (IN)
+ * data       - We copy it from nxssh auth code (IN)
+ * dataSize   - size of data field in bytes (IN)
+ * dataFellow - We copy it from nxssh auth code (IN)
+ *
+ * RETURNS: 0 if OK.
+ */
+
+int LsaLogon(HANDLE *hToken, char homeDir[MAX_PATH], char *user, 
+                 char *pkBlob, int pkBlobSize, char *sign, int signSize, 
+                     char *data, int dataSize, int dataFellow)
+{
+  int exitCode = 1;
+  
+  NTSTATUS ntStat = 0;
+  
+  LSA_STRING logonProcName;
+  LSA_STRING originName;
+  LSA_STRING authPckgName;
+  
+  HANDLE hLsa = NULL;
+  
+  LSA_OPERATIONAL_MODE securityMode;
+  
+  /*
+   * Impersonation, "weak" token returned from network logon.
+   * We can't create process as other user via this token.
+   */
+  
+  HANDLE hWeakToken = NULL;
+  
+  /*
+   * Login data.
+   */
+  
+  NXAuth *nxAuth = NULL;
+
+  ULONG nxAuthSize = 0;
+
+  ULONG authPckgId  = 0;
+  
+  TOKEN_SOURCE srcToken;
+  
+  PVOID profile = NULL;
+
+  ULONG profileSize;
+  
+  LUID  logonId;
+  
+  QUOTA_LIMITS quotas;
+  
+  NTSTATUS loginStat;
+  
+
+  debug("-> LsaLogon()...");
+
+  /*
+   * We check only hToken arg, becouse other args are tested in AllocNXAuth().
+   */
+  
+  debug("Checking args...");
+  
+  FAIL(hToken == NULL);
+  
+  /*
+   * Setup lsa strings.
+   */
+
+  debug("Setting up LSA Strings...");
+  
+  FAIL(InitLsaString(&logonProcName, "NXLogon"));
+  FAIL(InitLsaString(&originName, "NTLM"));
+  FAIL(InitLsaString(&authPckgName, "NXLsa"));
+
+  /*
+   * Enable needed privilege to current running process.
+   */
+
+  EnablePrivilege("SeTcbPrivilege", 1);
+  
+  /*
+   * Register new logon process.
+   */
+  
+  debug("LsaRegisterLogonProcess()...");
+
+  NTFAIL(LsaRegisterLogonProcess(&logonProcName, &hLsa, &securityMode));
+  
+  /*
+   * Retrieve Authenticated Package ID.
+   */
+  
+  debug("Retrieving Authentification Package ID...");
+  
+  NTFAIL(LsaLookupAuthenticationPackage(hLsa, &authPckgName, &authPckgId));
+  
+  /*
+   * Allocate NXAuth struct.
+   */
+
+  debug("Allocating NXAuth struct...");
+  
+  FAIL(AllocNXAuth(&nxAuth, user, pkBlob, pkBlobSize,
+                       sign, signSize, data, dataSize, dataFellow));
+                       
+  nxAuthSize = nxAuth -> totalSize_;                       
+
+  /*
+   * Create TOKEN_SOURCE part
+   */
+  
+  debug("Setting up TOKEN_SOURCE...");
+  
+  FAIL(AllocateLocallyUniqueId(&srcToken.SourceIdentifier) == FALSE);
+  
+  memcpy(srcToken.SourceName, "*nxsshd*", 8);
+
+  /*
+   * Try to login using NXAuth struct.
+   */
+
+  debug("Login attemp...");
+  
+  NTFAIL(LsaLogonUser(hLsa, &originName, Network,
+                          authPckgId, nxAuth, nxAuthSize, NULL,
+                              &srcToken, &profile, &profileSize,
+                                  &logonId, &hWeakToken, &quotas, &loginStat));
+
+  debug("login status: %x...", loginStat);
+  
+  debug("homedir = %s, homedirSize = %d", (char *) profile, profileSize);
+  
+  strcpy(homeDir, profile);
+  
+  //PrintToken(hToken);
+  
+  /*
+   * Duplicate 'weak' impersonation token into Primary Key token.
+   * We can create process using duplicated token.
+   */
+  
+  debug("Duplicating token...");
+  
+  FAIL(DuplicateTokenEx(hWeakToken, MAXIMUM_ALLOWED,
+                            NULL, SecurityImpersonation,
+                                TokenPrimary, hToken) == 0);
+  
+  exitCode = 0;
+  
+fail:
+
+  if (exitCode)
+  {
+    switch(ntStat)
+    {
+      case STATUS_LOGON_FAILURE:
+      {
+        debug("NXLsa authorization failed. " 
+                  "(err = %u, ntStat = %x).", GetLastError(), ntStat);
+
+        exitCode = 0;
+
+        break;
+      }
+      
+      case STATUS_NO_SUCH_PACKAGE:
+      {
+        debug("NXLsa package not found. "
+                  "(err = %u, ntStat = %x).", GetLastError(), ntStat);
+                  
+        break;          
+      }
+      
+      default:
+      {
+        debug("Cannot logon using LSA package (err = %u, ntStat = %x).",
+                  GetLastError(), ntStat);
+      }
+    }        
+            
+    hToken = NULL;
+  }
+  else
+  {
+    debug("LsaLogon : OK.");
+  }
+
+  /*
+   * Clean up.
+   */
+  
+  CloseHandle(hWeakToken);
+  
+  LsaFreeReturnBuffer(profile);
+   
+  EnablePrivilege("SeTcbPrivilege", 0);
+  
+  LsaDeregisterLogonProcess(hLsa);
+  
+  ClearLsaString(&logonProcName);
+  ClearLsaString(&originName);
+  ClearLsaString(&authPckgName);
+         
+  debug("<- LsaLogon()...");
+  
+  return exitCode;
+}
diff --git a/contrib/win32/win32compat/lsalogon.h b/contrib/win32/win32compat/lsalogon.h
new file mode 100644
index 0000000..b2c7f4d
--- /dev/null
+++ b/contrib/win32/win32compat/lsalogon.h
@@ -0,0 +1,65 @@
+/*
+ * Author: NoMachine <developers@nomachine.com>
+ *
+ * Copyright (c) 2009, 2011 NoMachine
+ * All rights reserved
+ *
+ * Support functions and system calls' replacements needed to let the
+ * software run on Win32 based operating systems.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef LsaLogon_H
+#define LsaLogon_H
+
+#include <stdio.h>
+#include <openssl/rsa.h>
+#include <openssl/dsa.h>
+#include <windows.h>
+#include <Ntsecapi.h>
+
+#include "Debug.h"
+#include "lsastring.h"
+#include "win32auth.h"
+
+typedef struct _NXAuth
+{
+  DWORD totalSize_;
+  DWORD dataFellow_;
+  DWORD userSize_;
+  DWORD signSize_;
+  DWORD dataSize_;
+  DWORD pkBlobSize_;
+  
+  BYTE buf_[1];
+} NXAuth;
+
+int AllocNXAuth(NXAuth **nxAuth, char *user, char *pkBlob, 
+                    int pkBlobSize, char *sign, int signSize, 
+                        char *data, int dataSize, int dataFellow);
+                        
+int LsaLogon(HANDLE *hToken, char homeDir[MAX_PATH], char *user, char *pkBlob, 
+                 int pkBlobSize, char *sign, int signSize, 
+                     char *data, int dataSize, int dataFellow);
+                     
+#endif
diff --git a/contrib/win32/win32compat/lsastring.c b/contrib/win32/win32compat/lsastring.c
new file mode 100644
index 0000000..7543b54
--- /dev/null
+++ b/contrib/win32/win32compat/lsastring.c
@@ -0,0 +1,152 @@
+/*
+ * Author: NoMachine <developers@nomachine.com>
+ *
+ * Copyright (c) 2009, 2011 NoMachine
+ * All rights reserved
+ *
+ * Support functions and system calls' replacements needed to let the
+ * software run on Win32 based operating systems.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "LsaString.h"
+ 
+/*
+ * Allocate UNICODE_STRING's buffer and initializes it with
+ * given string.
+ *
+ * lsaStr - UNICODE_STRING to initialize (IN/OUT)
+ * wstr   - string, which will be copied to lsaStr (IN)
+ *
+ * RETURNS: 0 if OK.
+ */
+
+int InitUnicodeString(UNICODE_STRING *lsaStr, const wchar_t *wstr)
+{
+  int exitCode = 1; 
+  
+  int size = (wstr) ? wcslen(wstr) * 2 : 0;
+
+  lsaStr -> Length        = size;
+  lsaStr -> MaximumLength = size + 2;
+  lsaStr -> Buffer        = (wchar_t *) malloc(size + 2);
+  
+  FAIL(lsaStr -> Buffer == NULL);
+
+  memcpy(lsaStr -> Buffer, wstr, size);
+
+  lsaStr -> Buffer[size / 2] = 0;
+  
+  exitCode = 0;
+  
+fail:
+
+  if (exitCode)
+  {
+    printf("ERROR. Cannot initialize UNICODE_STRING...");
+  }
+  
+  return exitCode;
+}
+
+
+/*
+ * Allocate LSA_STRING's buffer and initializes it with
+ * given string.
+ *
+ * lsaStr - LSA_STRING to initialize (IN/OUT)
+ * str    - string, which will be copied to lsaStr (IN)
+ *
+ * RETURNS: 0 if OK.
+ */
+
+int InitLsaString(LSA_STRING *lsaStr, const char *str)
+{
+  int exitCode = 1; 
+  
+  int len = (str) ? strlen(str) : 0;
+  
+  lsaStr -> Length        = len;
+  lsaStr -> MaximumLength = len + 1;
+  lsaStr -> Buffer        = (char *) malloc(len + 1);
+  
+  FAIL(lsaStr -> Buffer == NULL);
+  
+  memcpy(lsaStr -> Buffer, str, len);
+
+  lsaStr -> Buffer[len] = 0;
+  
+  exitCode = 0;
+  
+fail:
+
+  if (exitCode)
+  {
+    printf("ERROR. Cannot initialize LSA_STRING...");
+  }
+  
+  return exitCode;
+}
+
+
+/*
+ * Clear LSA_STRING's buffer.
+ *
+ * lsaStr - LSA_STRING to clear (IN/OUT)
+ */
+
+void ClearLsaString(LSA_STRING *lsaStr)
+{
+  if (lsaStr)
+  {
+    if (lsaStr -> Buffer)
+    {
+      free(lsaStr -> Buffer);
+      
+      lsaStr -> Buffer = NULL;
+    }
+    lsaStr -> MaximumLength = 0;
+    lsaStr -> Length = 0;
+  }
+}
+
+/*
+ * Clear UNICODE_STRING's buffer.
+ *
+ * lsaStr - UNICODE_STRING to clear (IN/OUT)
+ */
+
+void ClearUnicodeString(UNICODE_STRING *lsaStr)
+{
+  if (lsaStr)
+  {
+    if (lsaStr -> Buffer)
+    {
+      free(lsaStr -> Buffer);
+      
+      lsaStr -> Buffer = NULL;
+    }
+    lsaStr -> MaximumLength = 0;
+    lsaStr -> Length = 0;
+  }
+}
diff --git a/contrib/win32/win32compat/lsastring.h b/contrib/win32/win32compat/lsastring.h
new file mode 100644
index 0000000..601eecc
--- /dev/null
+++ b/contrib/win32/win32compat/lsastring.h
@@ -0,0 +1,49 @@
+/*
+ * Author: NoMachine <developers@nomachine.com>
+ *
+ * Copyright (c) 2009, 2011 NoMachine
+ * All rights reserved
+ *
+ * Support functions and system calls' replacements needed to let the
+ * software run on Win32 based operating systems.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef LsaString_H
+#define LsaString_H
+
+#include <stdio.h>
+#include <windows.h>
+#include <Ntsecapi.h>
+
+#include "Debug.h"
+
+int InitUnicodeString(UNICODE_STRING *lsaStr, const wchar_t *wstr);
+
+void ClearUnicodeString(UNICODE_STRING *lsaStr);
+
+int InitLsaString(LSA_STRING *lsaStr, const char *str);
+
+void ClearLsaString(LSA_STRING *lsaStr);
+
+#endif
diff --git a/contrib/win32/win32compat/pwd.c b/contrib/win32/win32compat/pwd.c
new file mode 100644
index 0000000..47024e4
--- /dev/null
+++ b/contrib/win32/win32compat/pwd.c
@@ -0,0 +1,395 @@
+/*
+ * Author: NoMachine <developers@nomachine.com>
+ *
+ * Copyright (c) 2009, 2011 NoMachine
+ * All rights reserved
+ *
+ * Support functions and system calls' replacements needed to let the
+ * software run on Win32 based operating systems.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "includes.h"
+
+#include <Lmcons.h>
+#include <Lm.h>
+#include <stdlib.h>
+#include <ntsecapi.h>
+#include <errno.h>
+#include <shlobj.h>
+#include <Userenv.h>
+
+#include "win32auth.h"
+#include "homedirhelp.h"
+
+
+uid_t getuid(void)
+{
+  return 0;
+}
+
+gid_t getgid(void)
+{
+  return 0;
+}
+
+uid_t geteuid(void)
+{
+  return 0;
+}
+
+gid_t getegid(void)
+{
+  return 0;
+}
+
+int setuid(uid_t uid)
+{
+  return 0;
+}
+
+int setgid(gid_t gid)
+{
+  return 0;
+}
+
+int seteuid(uid_t uid)
+{
+  return 0;
+}
+
+int setegid(gid_t gid)
+{
+  return 0;
+}
+
+/*
+ * Global pw variables
+ */
+
+static struct passwd pw;
+
+static char pw_gecos[UNLEN + 1]    = {'\0'};
+static char pw_username[UNLEN + 1] = {'\0'};
+static char pw_passwd[UNLEN + 1]   = {'\0'};
+static char pw_homedir[MAX_PATH]   = {'\0'};
+static char pw_password[MAX_PATH]  = {'\0'};
+static char pw_shellpath[MAX_PATH] = {'\0'};
+
+/*
+ * Retrieve user homedir from token, save it in static string
+ * and return pointer to this string.
+ *
+ * userName - user's name (IN)
+ * token    - logon user's token (IN)
+ *
+ * RETURNS: pointer to static string with homedir or NULL if fails.
+ */
+
+char *GetHomeDirFromToken(char *userName, HANDLE token)
+{
+  debug("-> GetHomeDirFromToken()...");
+  
+  PROFILEINFO profileInfo;
+  
+  memset(&profileInfo, 0, sizeof(profileInfo));
+
+  profileInfo.dwSize       = sizeof(profileInfo);
+  profileInfo.lpUserName   = userName;
+  profileInfo.lpServerName = NULL;
+  
+  if (LoadUserProfile(token, &profileInfo) == FALSE)
+  {
+    debug("<- GetHomeDirFromToken()...");
+    debug("LoadUserProfile failure: %d", GetLastError());
+    
+    return NULL;
+  }
+
+  /*
+   * And retrieve homedir from profile.
+   */
+        
+  if (!SUCCEEDED(SHGetFolderPath(NULL, CSIDL_PROFILE, token, 0, pw_homedir)))
+  {
+    debug("<- GetHomeDirFromToken()...");
+    debug("SHGetFolderPath failed");
+    
+    return NULL;
+  }
+          
+  /*
+   * Unload user profile.
+   */
+       
+  if (UnloadUserProfile(token, profileInfo.hProfile) == FALSE)
+  {
+    debug("WARNING. Cannot unload user profile (%u).", GetLastError());
+  }
+  
+  debug("<- GetHomeDirFromToken()...");
+  
+  return pw_homedir;
+}
+
+
+char *GetHomeDir(char *userName)
+{
+  /*
+   * Get home directory path (if this fails, the user is invalid, bail)
+   */
+
+  char *homeDir = NULL;
+  
+  homeDir = gethomedir(userName, NULL);
+  
+  if (homeDir == NULL || homeDir[0] == '\0')
+  {
+    return NULL;
+  }
+  
+  debug3("getpwuid: homedir [%s]", homeDir);
+  
+  strncpy(pw_homedir, homeDir, sizeof(pw_homedir));
+
+  free(homeDir);
+  
+  return pw_homedir;
+}
+
+/*
+ * Not thread safe, would need to use thread local
+ * storage instead of a static.
+ */
+
+struct passwd *getpwuid(uid_t uid)
+{
+  static struct passwd pw;
+
+  static char username[UNLEN + 1];
+  
+  DWORD usernamelen = UNLEN + 1;
+  
+  char *homedir;
+
+  /*
+   * Clear errno.
+   */
+  
+  errno = 0;
+
+  /*
+   * Zero out the structure.
+   */
+  
+  memset(&pw, 0, sizeof(pw));
+  
+  memset(pw_username, 0, sizeof(pw_username));
+  memset(pw_homedir, 0, sizeof(pw_homedir));
+  memset(pw_password, 0, sizeof(pw_password));
+  memset(pw_shellpath, 0, sizeof(pw_shellpath));
+
+  /*
+   * Point to the static string variables.
+   */
+  
+  pw.pw_name = pw_username;
+  pw.pw_passwd = pw_password;
+  pw.pw_gecos = pw_gecos;
+  pw.pw_shell = pw_shellpath;
+  pw.pw_dir = pw_homedir;
+
+  /*
+   * Get the current user's name.
+   */
+  
+  GetUserName(username, &usernamelen);
+  
+  debug3("getpwuid: username [%s]", username);
+  
+  strncpy(pw_username, username, sizeof(pw_username));
+
+  /*
+   * Nxssh need path to 'known_hosts' file, so we don't
+   * comment it here (see -> getpwnam() function).
+   */
+  
+  /*
+   * Get default shell path.
+   */
+  
+  GetSystemDirectory(pw_shellpath, MAX_PATH);
+  
+  debug3("getpwuid: system dir [%s]", pw_shellpath);
+  
+  strcat(pw_shellpath, "\\cmd.exe");
+  
+  debug3("getpwuid: shell path [%s]", pw_shellpath);
+
+  /*
+   * Get home directory path (if this fails,
+   * the user is invalid, bail)
+   */
+  
+  homedir = gethomedir(username, NULL);
+  
+  if (!homedir || homedir[0] == '\0')
+  {
+    /*
+     * Bail out.
+     */
+      
+    errno = ENOENT;
+
+    return &pw;
+  }
+
+  debug3("getpwuid: homedir [%s]", homedir);
+    
+  strncpy(pw_homedir, homedir, sizeof(pw_homedir));
+        
+  free(homedir);
+
+  /*
+   * Point to the username static variable.
+   */
+  
+  pw.pw_name   = pw_username;
+  pw.pw_passwd = pw_passwd;
+  pw.pw_gecos  = pw_gecos;
+  pw.pw_shell  = pw_shellpath;
+  pw.pw_dir    = pw_homedir;
+
+  return &pw;
+}
+
+
+struct passwd *getpwnam(const char *userin)
+{
+  char *homedir;
+
+  debug3("getpwnam: username [%s]", userin);
+
+  /*
+   * Clear errno.
+   */
+  
+  errno = 0;
+
+  /*
+   * Zero out the structure.
+   */
+  
+  memset(&pw, 0, sizeof(pw));
+  
+  memset(pw_username, 0, sizeof(pw_username));
+  memset(pw_homedir, 0, sizeof(pw_homedir));
+  memset(pw_password, 0, sizeof(pw_password));
+  memset(pw_shellpath, 0, sizeof(pw_shellpath));
+
+  /*
+   * Point to the static string variables.
+   */
+  
+  pw.pw_name   = pw_username;
+  pw.pw_passwd = pw_password;
+  pw.pw_gecos  = pw_gecos;
+  pw.pw_shell  = pw_shellpath;
+  pw.pw_dir    = pw_homedir;
+
+  /*
+   * Get default shell path.
+   */
+  
+  GetSystemDirectory(pw_shellpath, MAX_PATH);
+
+  debug3("getpwnam: system dir [%s]", pw_shellpath);
+  
+  strcat(pw_shellpath, "\\cmd.exe");
+  
+  debug3("getpwnam: shell path [%s]", pw_shellpath);
+
+  /*
+   * Copy user name to static structure.
+   */
+  
+  strncpy(pw_username, userin, UNLEN + 1);
+
+  /*
+   * We don't need homedir on nxsshd until login attemp.
+   * Here we must use NtCreateToken in keyauth session, but
+   * later we will get homedir from nxlsa if possible.
+   */
+  
+  /*
+   * Get home directory path (if this fails, the user is invalid, bail) //
+   */
+  
+  //homedir = gethomedir(userin, NULL);
+  
+  //if (!homedir || homedir[0] == '\0')
+  //{
+    /*
+     * Bail out
+     */
+      
+  //  errno = ENOENT;
+  //  return &pw;
+  //}
+
+  //debug3("getpwnam: homedir [%s]", homedir);
+  
+  //strncpy(pw_homedir, homedir, sizeof(pw_homedir));
+ 
+  //free(homedir);
+
+  /*
+   * Get a token for this user.
+   */
+  
+  return &pw;
+}
+
+void endpwent(void)
+{
+  /*
+   * This normally cleans up access to the passwd file,
+   * which we don't have, thus no cleanup.
+   */
+}
+
+
+#ifdef NX_USE_NTCREATETOKEN
+
+/*
+ * Simple helper to avoid having to include win32auth.h.
+ */
+
+PWD_USER_TOKEN PwdCreateUserToken(const char *pUserName, 
+                                      const char *pDomainName, 
+                                          const char *pSourceName)
+{
+  return (PWD_USER_TOKEN) CreateUserToken(pUserName, pDomainName, pSourceName);
+}
+
+#endif
diff --git a/contrib/win32/win32compat/sfds.c b/contrib/win32/win32compat/sfds.c
new file mode 100644
index 0000000..00d2a92
--- /dev/null
+++ b/contrib/win32/win32compat/sfds.c
@@ -0,0 +1,399 @@
+/*
+ * Author: NoMachine <developers@nomachine.com>
+ *
+ * Copyright (c) 2009, 2012 NoMachine
+ * All rights reserved
+ *
+ * Support functions and system calls' replacements needed to let the
+ * software run on Win32 based operating systems.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <winsock2.h>
+#include <io.h>
+#include "sfds.h"
+
+extern void debug(const char *fmt,...);
+extern void debug2(const char *fmt,...);
+extern void debug3(const char *fmt,...);
+extern void error(const char *fmt,...);
+extern void fatal(const char *fmt,...);
+
+/* 
+ * structure to store real file descriptor and type for sfd
+ */
+ 
+static struct
+{
+  int fd;
+  HANDLE handle;
+  sfd_type type;
+} sfd_map[SFD_MAP_SIZE];
+
+static int sfd_map_init = 0;
+static int sfd_count = 0;
+int sfd_start = 0;
+
+/* 
+ * store real fd in map, detect fd type and return sfd number.
+ */
+ 
+int allocate_sfd(int fd_or_handle)
+{
+  int slot = SFD_FD_INVALID;
+  int i;
+  int real_fd;
+
+  HANDLE real_handle;
+  
+  DWORD handle_type;
+
+  /*
+   * Init the map once 
+   */
+   
+  if (!sfd_map_init)
+  {
+    sfd_map_init = 1;
+    
+    for (i = 0; i < SFD_MAP_SIZE; ++i)
+    {
+      sfd_map[i].fd = SFD_FD_INVALID;
+      sfd_map[i].type = SFD_TYPE_NONE;
+    }
+  }
+
+  /*
+   * Find an open slot 
+   */
+   
+  for (i = sfd_start; i < SFD_MAP_SIZE; ++i)
+  {
+    /*
+     * Is this slot open? 
+     */
+     
+     if (sfd_map[i].fd == SFD_FD_INVALID)
+     {
+       slot = i;
+      
+       break;
+     }
+  }  
+  
+  /*
+   * Bail if no slot found 
+   */
+   
+  if (slot == SFD_FD_INVALID)
+  {
+    error("ERROR: Too many connections.");
+                    
+    return -1;
+  }
+
+  /*
+   * Detect and save real fd and real handle 
+   */
+   
+  real_handle = (HANDLE) _get_osfhandle(fd_or_handle);
+
+  if (real_handle == INVALID_HANDLE_VALUE)
+  {
+    /*
+     * fd_or_handle was a handle, we can try to create a fd for it
+     */
+
+    real_handle = (HANDLE) fd_or_handle;
+
+    real_fd = _open_osfhandle((long) real_handle, 0);
+  }
+  else
+  {
+    /*
+     * fd_or_handle was a fd 
+     */
+    
+    real_fd = fd_or_handle;
+  }
+
+  debug3("_get_osfhandle() for real_fd [%d] returned [%d]", real_fd, real_handle);
+
+  /*
+   * Detect and save type 
+   */
+   
+  handle_type = GetFileType(real_handle);
+
+  debug3("GetFileType() for handle [%d] returned [%d]", real_handle, handle_type);
+
+  switch (handle_type)
+  {
+    case FILE_TYPE_CHAR:
+    {
+      sfd_map[slot].type = SFD_TYPE_CONSOLE;
+
+      break;
+    }
+    
+    case FILE_TYPE_PIPE:
+    {
+      if (GetNamedPipeInfo(real_handle, NULL, NULL, NULL, NULL))
+      {
+        sfd_map[slot].type = SFD_TYPE_PIPE;
+      }
+      else
+      {
+        sfd_map[slot].type = SFD_TYPE_SOCKET;
+      }
+    
+      break;
+    }  
+
+    case FILE_TYPE_DISK:
+    {
+      sfd_map[slot].type = SFD_TYPE_FD;
+
+      break;
+    }
+  
+    case FILE_TYPE_UNKNOWN:
+    {
+      error("unknown type for handle [%d]", real_handle);
+
+      return SFD_FD_INVALID;
+
+      break;
+    }
+  
+    default:
+    {
+      error("cannot detect a type for handle [%d]", real_handle);
+  
+      return SFD_FD_INVALID;
+
+      break;
+    }
+  }
+
+  /*
+   * Save the fd and handle 
+   */
+   
+  sfd_map[slot].fd = (int) real_fd;
+  
+  sfd_map[slot].handle = (HANDLE) real_handle;
+
+  debug("allocating new sfd, sfd [%i] fd [%i] handle [%d] type [%i]",
+            slot, real_fd, real_handle, sfd_map[slot].type);
+
+  sfd_count++;
+
+  /*
+   * Return the slot as the sfd 
+   */
+   
+  return (slot);
+}
+
+/* 
+ * For a real fd, get our sfd 
+ */
+ 
+int fd_to_sfd(int real_fd)
+{
+  int i;
+  int sfds;
+
+  /* 
+   * Walk the list.
+   */
+   
+  for (i = 0, sfds = 0; i < SFD_MAP_SIZE && sfds < sfd_count; i++)
+  {
+    /*
+     * Increment the count of sfds that we have encountered in our walk,
+     */
+
+    if (sfd_map[i].fd != SFD_FD_INVALID)
+    {
+      sfds++;
+    }
+
+    if (sfd_map[i].fd == real_fd)
+    {
+      return i;
+    }
+  }
+
+  fatal("cannot convert fd to sfd");
+  
+  return SFD_FD_INVALID;
+}
+
+/*
+ * For an sfd, get the real descriptor behind it.
+ */
+
+int sfd_to_fd(int sfd)
+{
+  return sfd_map[sfd].fd;
+}
+
+/*
+ * For an sfd, get the real handle behind it 
+ */
+ 
+HANDLE sfd_to_handle(int sfd)
+{
+  return sfd_map[sfd].handle;
+}
+
+void sfd_replace(int sfd, HANDLE handle, int type)
+{
+  //_close(sfd_map[sfd].handle);
+
+  sfd_map[sfd].handle = handle;
+  sfd_map[sfd].type   = type;
+}
+
+/*
+ * For an sfd, get the type 
+ */
+ 
+int get_sfd_type(int sfd)
+{
+  if(sfd < sizeof(sfd_map) / sizeof(sfd_map[0]))
+  {
+    return sfd_map[sfd].type;
+  }
+  else
+  {
+    return -1;
+  }
+}
+
+/*
+ * Free an sfd from the map.
+ */
+ 
+void free_sfd(int sfd)
+{
+  if (sfd_map[sfd].type != SFD_TYPE_NONE 
+          && sfd < sizeof(sfd_map) / sizeof(sfd_map[0]))
+  {
+    /* 
+     * Blank the slot 
+     */
+     
+    sfd_map[sfd].fd = SFD_FD_INVALID;
+    sfd_map[sfd].handle = (HANDLE) SFD_HANDLE_INVALID;
+    sfd_map[sfd].type = SFD_TYPE_NONE;
+    sfd_count--;
+  }
+}
+
+/*
+ * Check if sfd is file.
+ */
+ 
+int
+sfd_is_fd(int sfd)
+{
+  if (sfd_map[sfd].type == SFD_TYPE_FD)
+  {
+    return 1;
+  }
+  
+  return 0;
+}
+
+/*
+ * Check if sfd is socket.
+ */
+ 
+int sfd_is_socket(int sfd)
+{
+  if (sfd_map[sfd].type == SFD_TYPE_SOCKET)
+  {
+    return 1;
+  }
+
+  return 0;
+}
+
+/*
+ * Check if sfd is pipe.
+ */
+ 
+int sfd_is_pipe(int sfd)
+{
+  if (sfd_map[sfd].type == SFD_TYPE_PIPE)
+  {
+    return 1;
+  }
+ 
+  return 0;
+}
+
+/*
+ * Check if sfd is console.
+ */
+ 
+int sfd_is_console(int sfd)
+{
+  if (sfd_map[sfd].type == SFD_TYPE_CONSOLE)
+  {
+    return 1;
+  }
+ 
+  return 0;
+}
+
+/*
+ * Check if sfd is file or console.
+ */
+ 
+int sfd_is_fd_or_console(int sfd)
+{
+  if (sfd_is_fd(sfd) || sfd_is_console(sfd))
+  {
+    return 1;
+  }
+
+  return 0;
+}
+
+/*
+ * Check if sfd is socket or pipe.
+ */
+
+int sfd_is_socket_or_pipe(int sfd)
+{
+  if (sfd_is_socket(sfd) || sfd_is_pipe(sfd))
+  {
+    return 1;
+  }
+
+  return 0;
+}
diff --git a/contrib/win32/win32compat/sfds.h b/contrib/win32/win32compat/sfds.h
new file mode 100644
index 0000000..88f633a
--- /dev/null
+++ b/contrib/win32/win32compat/sfds.h
@@ -0,0 +1,72 @@
+#ifndef _SFDS_H_
+#define _SFDS_H_ 1
+
+/* Types */
+
+typedef int sfd_type;
+
+#define SFD_TYPE_NONE       0
+#define SFD_TYPE_FD         1
+#define SFD_TYPE_SOCKET     2
+#define SFD_TYPE_PIPE       3
+#define SFD_TYPE_CONSOLE    4
+
+#define SFD_MAP_SIZE        256
+#define SFD_FD_INVALID     -1
+#define SFD_HANDLE_INVALID -1
+
+/*
+ * Struct for compatibility with AF_UNIX socket.
+ * Bind() and connect() should receive pointer to this struct.
+ */
+ 
+#define UNIX_PATH_LEN 108
+
+typedef unsigned short uint16_t;
+typedef uint16_t sa_family_t;
+
+struct sockaddr_un
+{
+  sa_family_t sun_family;         /* address family AF_LOCAL/AF_UNIX */
+  char sun_path[UNIX_PATH_LEN];   /* 108 bytes of socket address     */
+};
+
+/* For a real fd or SOCKET, allocate an sfd */
+int allocate_sfd(int fd_or_handle);
+
+/* Free an sfd from the map */
+void free_sfd(int sfd);
+
+/* For a real fd or SOCKET, get our sfd */
+int fd_to_sfd(int fd_or_socket);
+
+/* For an sfd, get the real fd behind it */
+int sfd_to_fd(int sfd);
+
+/* For an sfd, get the real handle behind it */
+HANDLE sfd_to_handle(int sfd);
+
+/* For an sfd, get the type */
+int get_sfd_type(int sfd);
+
+/*  Check if sfd is file */
+int sfd_is_fd(int sfd);
+
+/* Check if sfd is socket */
+int sfd_is_socket(int sfd);
+
+/* Check if sfd is pipe */
+int sfd_is_pipe(int sfd);
+
+/* Check if sfd is console */
+int sfd_is_console(int sfd);
+
+/* Check if sfd is file or console */
+int sfd_is_fd_or_console(int sfd);
+
+/* Check if sfd is socket or pipe */
+int sfd_is_socket_or_pipe(int sfd);
+
+void sfd_replace_handle(int sfd, HANDLE handle);
+
+#endif
diff --git a/contrib/win32/win32compat/socket.c b/contrib/win32/win32compat/socket.c
new file mode 100644
index 0000000..7f374e3
--- /dev/null
+++ b/contrib/win32/win32compat/socket.c
@@ -0,0 +1,2763 @@
+/*
+ * Author: NoMachine <developers@nomachine.com>
+ *
+ * Copyright (c) 2009, 2012 NoMachine
+ * All rights reserved
+ *
+ * Support functions and system calls' replacements needed to let the
+ * software run on Win32 based operating systems.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <winsock2.h>
+#include <errno.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include "sfds.h"
+
+#define FAIL(X) if (X) goto fail
+
+#undef  NX_DEBUG
+
+#ifdef NX_DEBUG
+  #define DBG_MSG(FMT, ARGS...) fprintf(stderr, FMT "\n", ## ARGS)
+#else
+  #define DBG_MSG(FMT, ARGS...)
+#endif
+
+extern void debug(const char *fmt,...);
+extern void debug2(const char *fmt,...);
+extern void debug3(const char *fmt,...);
+extern void error(const char *fmt,...);
+extern void fatal(const char *fmt,...);
+
+static int winsock_initialized = 0;
+
+extern int logfd;
+
+static FD_SET debug_sfds;
+static FD_SET crlf_sfds;
+
+static fd_set read_sfd_set;
+static fd_set write_sfd_set;
+
+#define MAX_THREADS 256
+#define TEST_READ   1
+#define TEST_WRITE  0
+
+#define MSG_WAITALL 0x8
+
+int PassInputFd  = STDIN_FILENO;
+int PassOutputFd = STDOUT_FILENO;
+
+/*
+ * We store cookies for authorize 
+ * connections on AF_UNIX sockets here.
+ */
+ 
+struct _SocketCookie
+{ 
+  FILE *f;
+  int socket;
+  char *cookie;
+} SocketCookieMap[SFD_MAP_SIZE] = {0};
+
+DWORD WINAPI selectThread(LPVOID lpParam);
+
+typedef struct 
+{
+  HANDLE thread;
+  
+  DWORD thread_id;
+  
+  HANDLE semaphore1;
+  HANDLE semaphore2;
+
+  int sfd;
+  int thread_no;
+  int test_type;
+  int signaled;
+  int exit;
+  int exited;
+} thread_data_t, *thread_data_p;
+
+static thread_data_p thread_data_set[MAX_THREADS];
+
+#define IS_WINSOCK_INITIALIZED() (winsock_initialized != 0)
+
+void WSHELPinitialize();
+
+/*
+ * FIXME. This function forces stopping all socket threads 
+ * at next select. This workaround nivelates problem with
+ * infinite hangs up in below scenario:
+ * 
+ * a) read select start.
+ * b) write select start.
+ * c) read select ends: SSH2_MSG_CHANNEL_CLOSE received.
+ * d) close input channel.
+ * e) now write select may never ends.
+ *
+ * We call this function after (d).
+ */
+
+void StopSocketThreads()
+{
+  DBG_MSG("-> StopSocketThreads()...");
+
+  FD_ZERO(&write_sfd_set);
+  FD_ZERO(&read_sfd_set);
+  
+  DBG_MSG("<- StopSocketThreads()...");
+}
+
+
+void read_sfd_set_add(int sfd)
+{
+  static int do_init = 1;
+
+  if (do_init)
+  {
+    FD_ZERO(&read_sfd_set);
+    
+    do_init = 0;
+  }
+
+  FD_SET((SOCKET) sfd, &read_sfd_set);
+}
+
+
+void write_sfd_set_add(int sfd)
+{
+  static int do_init = 1;
+
+  if (do_init)
+  {
+    FD_ZERO(&write_sfd_set);
+
+    do_init = 0;
+  }
+
+  FD_SET((SOCKET) sfd, &write_sfd_set);
+}
+
+
+void debug_sfd(int sfd)
+{
+  static int do_init = 1;
+
+  if (do_init)
+  {
+    FD_ZERO(&debug_sfds);
+    
+    do_init = 0;
+  }
+
+  FD_SET((SOCKET) sfd, &debug_sfds);
+}
+
+
+void crlf_sfd(int sfd)
+{
+  static int do_init = 1;
+
+  if (do_init)
+  {
+    FD_ZERO(&crlf_sfds);
+  
+    do_init = 0;
+  }
+
+  FD_SET((SOCKET) sfd, &crlf_sfds);
+}
+
+
+static int getWSAErrno()
+{
+  int wsaerrno = WSAGetLastError();
+
+  if (wsaerrno == WSAEWOULDBLOCK)
+  {
+    return EAGAIN;
+  }  
+  
+  if (wsaerrno == WSAEFAULT)
+  {
+    return EFAULT;
+  }
+  
+  if (wsaerrno == WSAEINVAL)
+  {
+    return EINVAL;
+  }  
+  
+  return wsaerrno;
+}
+
+
+int WSHELPisatty(int sfd)
+{
+  int ret;
+  
+  /*
+   * We can only do this for console fds.
+   */
+  
+  if (sfd_is_console(sfd) && sfd > 0)
+  {
+    ret = _isatty(sfd_to_fd(sfd));
+
+    return ret;
+  }
+
+  /*
+   * Not a tty.
+   */
+  
+  return 0;
+}
+
+
+int WSHELPfstat(int sfd, struct stat *buf)
+{
+  int ret;
+
+  struct _stat tmp;
+  
+  DBG_MSG("WSHELPfstat(sfd = %d, buf = %p)", sfd, buf);
+
+  ret = _fstat(sfd_to_fd(sfd), &tmp);
+
+  /*
+   * Handle errors.
+   */
+  
+  if (ret == -1)
+  {
+    errno = getWSAErrno();
+    
+    debug("fstat() returned error, errno [%d]", errno);
+  
+    return -1;
+  }
+
+  buf -> st_gid   = tmp.st_gid;
+  buf -> st_atime = tmp.st_atime;
+  buf -> st_ctime = tmp.st_ctime;
+  buf -> st_dev   = tmp.st_dev;
+  buf -> st_ino   = tmp.st_ino;
+  buf -> st_mode  = tmp.st_mode;
+  buf -> st_mtime = tmp.st_mtime;
+  buf -> st_nlink = tmp.st_nlink;
+  buf -> st_rdev  = tmp.st_rdev;
+  buf -> st_size  = tmp.st_size;
+  buf -> st_uid   = tmp.st_uid;
+
+  return ret;
+}
+
+
+FILE* WSHELPfdopen(int sfd, const char *mode)
+{
+  FILE* ret;
+
+  ret = fdopen(sfd_to_fd(sfd), mode);
+
+  /*
+   * Handle errors.
+   */
+  
+  if (ret == NULL)
+  {
+    errno = getWSAErrno();
+
+    debug("fdopen() returned error, errno [%d]", errno);
+  
+    return NULL;
+  }
+  
+  return ret;
+}
+
+
+int WSHELPpipe(int pfds[2])
+{
+  int ret;
+
+  ret = _pipe(pfds, 1024, _O_BINARY);
+
+  /*
+   * Handle errors.
+   */
+  
+  if (ret == -1)
+  {
+    errno = getWSAErrno();
+
+    debug("_pipe() returned error, errno [%d]", errno);
+    
+    return -1;
+  }
+
+  pfds[0] = allocate_sfd((int)pfds[0]);
+
+  pfds[1] = allocate_sfd((int)pfds[1]);
+
+  return ret;
+}
+
+
+int WSHELPdup(int oldsfd)
+{
+  int oldfd;
+
+  int newfd;
+  
+  int newsfd;
+
+  oldfd = sfd_to_fd(oldsfd);
+
+  /*
+   * Clear errno.
+   */
+  
+  errno = 0;
+
+  /*
+   * Pass through to base layer.
+   */
+  
+  newfd = _dup(oldfd);
+
+  /*
+   * Handle errors.
+   */
+  
+  if (newfd == -1)
+  {
+    errno = getWSAErrno();
+
+    debug("_dup() returned error, errno [%d]", errno);
+    
+    return -1;
+  }
+
+  /*
+   * Map the socket.
+   */
+  
+  newsfd = allocate_sfd(newfd);
+
+  return newsfd;
+}
+
+
+int WSHELPdup2(int oldsfd, int newsfd)
+{
+  int oldfd;
+  int newfd;
+
+  oldfd = sfd_to_fd(oldsfd);
+  newfd = sfd_to_fd(newsfd);
+
+  /*
+   * Clear errno.
+   */
+  
+  errno = 0;
+
+  /*
+   * Pass through to base layer.
+   */
+  
+  newfd = _dup2(oldfd, newfd);
+
+  /*
+   * Handle errors.
+   */
+  
+  if (newfd == -1)
+  {
+    errno = getWSAErrno();
+    
+    debug("_dup2() returned error, errno [%d]", errno);
+  
+    return -1;
+  }
+
+  /*
+   * Map the socket.
+   */
+  
+  newsfd = allocate_sfd(newfd);
+
+  return newsfd;
+}
+
+
+int WSHELPopen(const char *pathname, int flags, ...)
+{
+  va_list arguments;
+  int newfd;
+  int newsfd;
+
+  va_start(arguments, flags);
+
+  /*
+   * Clear errno.
+   */
+  
+  errno = 0;
+
+  /*
+   * Pass through to base layer.
+   */
+  
+  newfd = _open(pathname, flags, arguments);
+
+  va_end(arguments);
+
+  /*
+   * Handle errors.
+   */
+  
+  if (newfd == -1)
+  {
+    errno = getWSAErrno();
+
+    debug("_open() returned error, errno [%d]", errno);
+    
+    return -1;
+  }
+
+  /*
+   * Map the socket.
+   */
+  
+  newsfd = allocate_sfd(newfd);
+
+  return newsfd;
+}
+
+
+int WSHELPcreat(const char *pathname, int mode)
+{
+  int newfd;
+  int newsfd;
+
+  /*
+   * Clear errno.
+   */
+  
+  errno = 0;
+
+  /*
+   * Pass through to base layer.
+   */
+  
+  newfd = _creat(pathname, mode);
+
+  /*
+   * Handle errors.
+   */
+  
+  if (newfd == -1)
+  {
+    errno = getWSAErrno();
+
+    debug("_creat() returned error, errno [%d]", errno);
+    
+    return -1;
+  }
+
+  /*
+   * Map the socket.
+   */
+  
+  newsfd = allocate_sfd(newfd);
+
+  return newsfd;
+}
+
+
+int WSHELPsocket(int af, int type, int protocol)
+{
+  SOCKET sock = -1;
+  
+  int sfd;
+  
+  /*
+   * Verify that winsock has been initialized.
+   */
+  
+  if (!IS_WINSOCK_INITIALIZED())
+  {
+    WSHELPinitialize();
+  }
+
+  /*
+   * Clear errno.
+   */
+  
+  errno = 0;
+
+  switch(af)
+  {
+    /*
+     * AF_UNIX. We emulate unix socket by localhost tcp here.
+     */
+    
+    case AF_UNIX:
+    {
+      DBG_MSG("Creating AF_UNIX socket...");
+      
+      sock = socket(AF_INET, type, 0);
+      
+      break;
+    }
+    
+    /*
+     * We pass through to base layer as default.
+     */
+    
+    default:
+    {
+      DBG_MSG("Creating AF_INET socket...");
+      
+      sock = socket(af, type, protocol);
+    }
+  }
+
+  /*
+   * Handle errors.
+   */
+  
+  if (sock == INVALID_SOCKET)
+  {
+    errno = getWSAErrno();
+    
+    debug("socket() returned error, errno [%d]", errno);
+    
+    DBG_MSG("Cannot create socket : errno = %u", errno);
+    
+    return -1;
+  }
+
+  DBG_MSG("Socket %u created.", sock);
+  
+  /*
+   * Map the socket to our fd.
+   */
+  
+  sfd = allocate_sfd((int) sock);
+
+  return sfd;
+}
+
+
+int WSHELPsetsockopt(int sfd, int level, int optname, const char* optval, int optlen)
+{
+  SOCKET sock;
+  
+  int ret;
+
+  /*
+   * Clear errno.
+   */
+  
+  errno = 0;
+
+  /*
+   * Get the SOCKET.
+   */
+  
+  sock = (SOCKET) sfd_to_handle(sfd);
+
+  /*
+   * Call the underlying function.
+   */
+  
+  ret = setsockopt(sock, level, optname, optval, optlen);
+
+  /*
+   * Check for errors.
+   */
+  
+  if (ret == SOCKET_ERROR)
+  {
+    errno = getWSAErrno();
+    
+    debug("setsockopt() returned error, errno [%d]", errno);
+    
+    return -1;
+  }
+
+  return 0;
+}
+
+
+int WSHELPgetsockopt(int sfd, int level, int optname, char* optval, int* optlen)
+{
+  SOCKET sock;
+  
+  int ret;
+
+  /*
+   * Clear errno.
+   */
+  
+  errno = 0;
+
+  /*
+   * Get the SOCKET.
+   */
+  
+  sock = (SOCKET) sfd_to_handle(sfd);
+
+  /* 
+   * Call the underlying function.
+   */
+  
+  ret = getsockopt(sock, level, optname, optval, optlen);
+
+  /*
+   * Check for errors.
+   */
+  
+  if (ret == SOCKET_ERROR)
+  {
+    errno = getWSAErrno();
+   
+    debug("getsockopt() returned error, errno [%d]", errno);
+    
+    return -1;
+  }
+
+  return 0;
+}
+
+
+int WSHELPgetsockname(int sfd, struct sockaddr* name, int* namelen)
+{
+  SOCKET sock;
+  
+  int ret;
+
+  /*
+   * Clear errno.
+   */
+  
+  errno = 0;
+
+  /*
+   * Get the SOCKET.
+   */
+  
+  sock = (SOCKET) sfd_to_handle(sfd);
+
+  /*
+   * Call the underlying function.
+   */
+  
+  ret = getsockname(sock, name, namelen);
+
+  /*
+   * Check for errors.
+   */
+  
+  if (ret == SOCKET_ERROR)
+  {
+    errno = getWSAErrno();
+   
+    debug("getsockname() returned error, errno [%d]", errno);
+    
+    return -1;
+  }
+
+  return 0;
+}
+
+
+int WSHELPgetpeername(int sfd, struct sockaddr* name, int* namelen)
+{
+  SOCKET sock;
+  
+  int ret;
+
+  /*
+   * Clear errno.
+   */
+  
+  errno = 0;
+
+  /*
+   * Get the SOCKET.
+   */
+  
+  sock = (SOCKET) sfd_to_handle(sfd);
+
+  /*
+   * Call the underlying function.
+   */
+
+  ret = getpeername(sock, name, namelen);
+
+  /*
+   * Check for errors.
+   */
+  
+  if (ret == SOCKET_ERROR)
+  {
+    errno = getWSAErrno();
+    
+    debug("getpeername() returned error, errno [%d]", errno);
+    
+    return -1;
+  }
+
+  return 0;
+}
+
+
+int WSHELPioctlsocket(int sfd, long cmd, u_long* argp)
+{
+  SOCKET sock;
+  
+  int ret;
+
+  /*
+   * Clear errno.
+   */
+  
+  errno = 0;
+
+  /*
+   * Get the SOCKET.
+   */
+  
+  sock = (SOCKET) sfd_to_handle(sfd);
+
+  /*
+   * Call the underlying function.
+   */
+  
+  ret = ioctlsocket(sock, cmd, argp);
+
+  /*
+   * Check for errors.
+   */
+  
+  if (ret == SOCKET_ERROR)
+  {
+    errno = getWSAErrno();
+    
+    debug("ioctlsocket() returned error, errno [%d]", errno);
+    
+    return -1;
+  }
+
+  return 0;
+}
+
+
+int WSHELPlisten(int sfd, int backlog)
+{
+  SOCKET sock;
+  
+  int ret;
+
+  /*
+   * Clear errno.
+   */
+  
+  errno = 0;
+
+  /*
+   * Get the SOCKET.
+   */
+  
+  sock = (SOCKET) sfd_to_handle(sfd);
+
+  /*
+   * Call the underlying function.
+   */
+ 
+  ret = listen(sock, backlog);
+
+  /*
+   * Check for errors.
+   */
+  
+  if (ret == SOCKET_ERROR)
+  {
+    errno = getWSAErrno();
+   
+    debug("listen() returned error, errno [%d]", errno);
+    
+    return -1;
+  }
+
+  return 0;
+}
+
+
+int WSHELPbind(int sfd, const struct sockaddr *name, int namelen)
+{
+  SOCKET sock = -1;
+  
+  int ret = SOCKET_ERROR;
+
+  /*
+   * Clear errno.
+   */
+ 
+  errno = 0;
+
+  /*
+   * Get the SOCKET.
+   */
+  
+  sock = (SOCKET) sfd_to_handle(sfd);
+
+  switch(name -> sa_family)
+  {
+    /*
+     * We emulate unix socket here, by tcp socket binded to localhost.
+     */
+    
+    case AF_UNIX:
+    {
+      int len = 0;
+
+      unsigned int i = 0;
+  
+      FILE *f = NULL;
+      
+      char cookie[64 + 1] = {0};
+  
+      struct sockaddr_in sin = {0};
+  
+      struct sockaddr_un *unixName = (struct sockaddr_un *) name;
+
+      /*
+       * Bind socket to localhost:0.
+       */
+  
+      DBG_MSG("Binding socket %u to localhost:0...", (unsigned int) sock);
+  
+      sin.sin_family = AF_INET;
+      sin.sin_port = 0;
+      sin.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+
+      FAIL(bind(sock, (struct sockaddr *) &sin, sizeof(sin)));
+  
+      /*
+       * Retreave local name for socket.
+       */
+  
+      DBG_MSG("Retreaving socket's local name...");
+  
+      len = sizeof(sin);
+  
+      FAIL(getsockname(sock, (struct sockaddr *) &sin, &len));
+
+      sin.sin_port = ntohs(sin.sin_port);
+  
+      DBG_MSG("family = %u", sin.sin_family);
+      DBG_MSG("port   = %u", sin.sin_port);
+
+      /*
+       * Check is socket file already exists.
+       */
+  
+      DBG_MSG("Checking is socket file free...");
+  
+      WSASetLastError(WSAEADDRINUSE);
+      
+      f = fopen(unixName -> sun_path, "rt");
+  
+      FAIL(f);
+  
+      /*
+       * Create file with retrieved port and cookie.
+       * This file emulates unix socket itself.
+       */
+  
+      DBG_MSG("Creating socket file [%s]...", unixName -> sun_path);
+  
+      f = fopen(unixName -> sun_path, "wt+");
+ 
+      FAIL(f == NULL);
+  
+      /*
+       * Write tcp port to soket file.
+       */
+      
+      fprintf(f, "%d ", sin.sin_port);
+   
+      /*
+       * Write 64-byte cookie to socket file.
+       * We add port number to rand() to avoid generating the same
+       * cookie until next second reached.
+       *
+       */
+      
+      for (i = 0; i < 64; i++)
+      {
+        cookie[i] = 33 + (rand() + sin.sin_port) % (128 - 33);
+      }
+      
+      cookie[64] = 0;
+      
+      fputs(cookie, f);
+      
+      fflush(f);
+      
+      /*
+       * Cache cookie and file handle in SocketCookieMap var.
+       */
+      
+      for (i = 0; i < SFD_MAP_SIZE; i++)
+      {
+        /*
+         * Find first empty row.
+         */
+        
+        if (SocketCookieMap[i].socket == 0)
+        {
+          SocketCookieMap[i].socket = sock;
+          SocketCookieMap[i].cookie = strdup(cookie);
+          SocketCookieMap[i].f      = f;
+
+          /*
+          for (int i = 0; i < 64; j++)
+          {
+            printf("%02x ", SocketCookieMap[i].cookie[j]);
+          }
+          */
+
+          break;
+        }
+      }
+ 
+      /*
+       * Clear error.
+       */
+      
+      ret = 0;
+      
+      WSASetLastError(0);
+      
+      break;
+    }
+    
+    /*
+     * As default, we call underlying function.
+     */
+  
+    default:
+    {
+      ret = bind(sock, name, namelen);
+    }
+  }
+
+fail:
+  
+  /*
+   * Check for errors.
+   */
+  
+  if (ret == SOCKET_ERROR)
+  {
+    errno = getWSAErrno();
+   
+    debug("bind() returned error, errno [%d]", errno);
+    
+    return -1;
+  }
+
+  return 0;
+}
+
+
+int WSHELPconnect(int sfd, const struct sockaddr* name, int namelen)
+{
+  SOCKET sock = -1;
+
+  int ret = SOCKET_ERROR;
+
+  /*
+   * Clear errno.
+   */
+  
+  errno = 0;
+  
+  /*
+   * Get the SOCKET.
+   */
+  
+  sock = (SOCKET) sfd_to_handle(sfd);
+
+  switch(name -> sa_family)
+  {
+    /*
+     * We emulate unix socket here, by tcp socket binded to localhost.
+     */
+    
+    case AF_UNIX:
+    {
+      int len  = 0;
+      int port = -1;
+
+      char cookie[64 + 1] = {0};
+
+      unsigned int i = 0;
+  
+      FILE *f = NULL;
+  
+      struct sockaddr_in sin = {0};
+  
+      struct sockaddr_un *unixName = (struct sockaddr_un *) name;
+
+      /*
+       * Open socket file.
+       */
+      
+      DBG_MSG("Opening socket file [%s] for socket %u...",
+                  unixName -> sun_path, (unsigned int) sock);
+      
+      f = fopen(unixName -> sun_path, "rt");
+      
+      FAIL(f == NULL);
+      
+      /*
+       * Read tcp port and cokie from socket file.
+       */
+      
+      fscanf(f, "%d ", &port);
+      fgets(cookie, 64 + 1, f);
+      
+      fclose(f);
+
+      /*
+       * Connect to localhost on given port.
+       */
+  
+      DBG_MSG("Connecting to localhost:%u on socket %u...", 
+                  port, (unsigned int) sock);
+  
+      sin.sin_family = AF_INET;
+      sin.sin_port = htons(port);
+      sin.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+
+      FAIL(connect(sock, (struct sockaddr *) &sin, sizeof(sin)));
+      
+      /*
+       * Send authorization cookie.
+       * If cookie doesn't match to cookie stored on server side
+       * server shutdown connection.
+       */
+
+      DBG_MSG("Sending authorization cookie...\n");
+      
+      for (i = 0; i < 64; i++)
+      {
+        DBG_MSG("%02x ", cookie[i]);
+      }
+      
+      DBG_MSG("\n");
+      
+      
+      ret = send(sock, cookie, 64, MSG_DONTROUTE);
+    
+      FAIL(ret != 64);
+
+      /*
+       * Clear error.
+       */
+      
+      ret = 0;
+      
+      break;
+    }
+    
+    /*
+     * As default, we call underlying function.
+     */
+
+    default:
+    {
+      /*
+       * Call the underlying function as default.
+       */
+  
+      ret = connect(sock, name, namelen);
+    }
+  }
+  
+  /*
+   * Check for errors.
+   */
+  
+fail:
+
+  if (ret == SOCKET_ERROR)
+  {
+    errno = getWSAErrno();
+   
+    debug("connect() returned error, errno [%d]", errno);
+
+    DBG_MSG("connect() returned error, errno [%d]\n", errno);
+  
+    /*
+     * Re-map EAGAIN for connect() semantics.
+     */
+    
+    if (errno == EAGAIN)
+    {
+      errno = WSAEINPROGRESS;
+    }  
+    
+    return -1;
+  }
+
+  return 0;
+}
+
+
+int WSHELPshutdown(int sfd, int how)
+{
+  SOCKET sock;
+  
+  int ret;
+
+  /*
+   * Clear errno.
+   */
+  
+  errno = 0;
+
+  /*
+   * Get the SOCKET.
+   */
+  
+  sock = (SOCKET) sfd_to_handle(sfd);
+
+  /*
+   * Call the underlying function.
+   */
+  
+  ret = shutdown(sock, how);
+
+  /*
+   * Check for errors.
+   */
+  
+  if (ret == SOCKET_ERROR)
+  {
+    errno = getWSAErrno();
+   
+    debug("shutdown() returned error, errno [%d]", errno);
+    
+    return -1;
+  }
+
+  return 0;
+}
+
+
+int WSHELPaccept(int sfd, struct sockaddr* addr, int* addrlen)
+{
+  SOCKET sock;
+  
+  SOCKET new_sock;
+  
+  int new_sfd;
+  
+  int i = 0;
+  int j = 0;
+  int ret = -1;
+
+  int expectedFamily = addr -> sa_family;
+  
+  /*
+   * Clear errno
+   */
+
+  errno = 0;
+
+  /*
+   * Get the SOCKET
+   */
+
+  sock = (SOCKET) sfd_to_handle(sfd);
+
+  /*
+   * Call the underlying function
+   */
+
+  new_sock = accept(sock, addr, addrlen);
+
+  switch(expectedFamily)  
+  {
+    /*
+     * Cookie authorization for AF_UNIX.
+     */
+    
+    case AF_UNIX:
+    {
+      fd_set readsocks;
+
+      struct timeval timeout = {10, 0};
+
+      char remoteCookie[64 + 1] = {0};
+
+      int authorized = 0;
+      
+      /*
+       * Retrieave 64-byte authorization cookie from client.
+       */
+
+      DBG_MSG("Waiting for 64-byte cookie...\n");
+
+      FD_ZERO(&readsocks);
+      FD_SET((SOCKET) new_sock, &readsocks);
+
+      select(0, &readsocks, NULL, NULL, &timeout);
+
+      ret = recv(new_sock, remoteCookie, 64, 0);
+
+
+      #ifdef NX_DEBUG
+
+      DBG_MSG("\nRemoteCookie = [");
+
+      for (i = 0; remoteCookie[i]; i++)
+      {
+        DBG_MSG("%02x ", remoteCookie[i]);
+      }
+
+      DBG_MSG("]\n\n");
+
+      #endif
+
+      /*
+       * Find correct cookie in SocketCookieMap.
+       */
+
+      for (i = 0; i < SFD_MAP_SIZE; i++)
+      {
+        /*
+         * Find socket.
+         */
+
+        if (SocketCookieMap[i].socket == sock)
+        {
+          #ifdef NX_DEBUG
+
+          DBG_MSG("\nServerCookie = [");
+
+          for (j = 0; SocketCookieMap[i].cookie[j]; j++)
+          {
+            DBG_MSG("%02x ", SocketCookieMap[i].cookie[j]);
+          }
+
+          DBG_MSG("]\n\n");
+
+          #endif
+
+          /*
+           * Compare cookies.
+           */
+
+          if (strncmp(SocketCookieMap[i].cookie, remoteCookie, 64) == 0)
+          {
+            authorized = 1;
+          }
+
+          break;
+        }
+      }
+      
+      /*
+       * Cookies doesn't match. Shutdown connection.
+       */
+
+      if (authorized == 0)
+      {
+        DBG_MSG("ERROR. Accept from unathorized client."
+                    " I'm going to shutdown connection.\n");
+
+        shutdown(new_sock, SD_BOTH);
+
+        new_sock = INVALID_SOCKET;
+      }  
+
+      break;
+    }
+    
+    default:
+    {
+    }
+  }
+  
+  /*
+   * Handle errors
+   */
+
+  if (new_sock == INVALID_SOCKET)
+  {
+    errno = getWSAErrno();
+    
+    debug("accept() returned error, errno [%d]", errno);
+    
+    return -1;
+  }
+
+  /*
+   * Map the socket
+   */
+  
+  new_sfd = allocate_sfd((int)new_sock);
+
+  return new_sfd;
+}
+
+
+int socketpair(int socks[2])
+{
+  struct sockaddr_in addr;
+
+  SOCKET listener;
+
+  int e;
+
+  int addrlen = sizeof(addr);
+
+  /*
+   * Clear out last error.
+   */
+
+  errno = 0;
+
+  if (socks == 0)
+  {
+    WSASetLastError(WSAEINVAL);
+
+    errno = getWSAErrno();
+    
+    return SOCKET_ERROR;
+  }
+
+  /*
+   * Initialize to invalid sockets.
+   */
+  
+  socks[0] = socks[1] = INVALID_SOCKET;
+  
+  if ((listener = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
+  {
+    errno = getWSAErrno();
+    
+    return SOCKET_ERROR;
+  }
+
+  /*
+   * Zero out the structure and set params.
+   */
+  
+  memset(&addr, 0, sizeof(addr));
+
+  addr.sin_family      = AF_INET;
+  addr.sin_addr.s_addr = htonl(0x7f000001);
+  addr.sin_port        = 0;
+
+  /*
+   * Call base function.
+   */
+
+  e = bind(listener, (const struct sockaddr*) &addr, sizeof(addr));
+  
+  if (e == SOCKET_ERROR)
+  {
+    e = WSAGetLastError();
+    
+    closesocket(listener);
+    
+    WSASetLastError(e);
+    
+    errno = getWSAErrno();
+    
+    return SOCKET_ERROR;
+  }
+
+  /*
+   * Find out what ephermeral port got assigned.
+   */
+  
+  e = getsockname(listener, (struct sockaddr*) &addr, &addrlen);
+  
+  if (e == SOCKET_ERROR)
+  {
+    e = WSAGetLastError();
+    
+    closesocket(listener);
+   
+    WSASetLastError(e);
+    
+    errno = getWSAErrno();
+    
+    return SOCKET_ERROR;
+  }
+
+  do
+  {
+    if (listen(listener, 1) == SOCKET_ERROR)
+    {
+      break;
+    }
+
+    if ((socks[0] = (int) WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0)) == (int) INVALID_SOCKET)
+    {
+      break;
+    }
+
+    if (connect(socks[0], (const struct sockaddr*) &addr, sizeof(addr)) == SOCKET_ERROR)
+    {
+      break;
+    }
+
+    if ((socks[1] = (int) accept(listener, NULL, NULL)) == (int) INVALID_SOCKET)
+    {
+      break;
+    }
+
+    /*
+     * Don't need to listen anymore.
+     */
+    
+    closesocket(listener);
+
+    /*
+     * Maps the sockets.
+     */
+    
+    socks[0] = allocate_sfd((int)socks[0]);
+    socks[1] = allocate_sfd((int)socks[1]);
+
+    /*
+     * All set, return the socket pair.
+     */
+    
+    return 0;
+  } while (0);
+
+  /*
+   * Cleanup and return if we bailed out of creation above.
+   */
+  
+  e = WSAGetLastError();
+  
+  closesocket(listener);
+  
+  closesocket(socks[0]);
+  
+  closesocket(socks[1]);
+  
+  WSASetLastError(e);
+  
+  errno = getWSAErrno();
+
+  socks[0] = INVALID_SOCKET;
+  socks[1] = INVALID_SOCKET;
+
+  return SOCKET_ERROR;
+}
+
+
+int peekConsoleRead(int sfd)
+{
+  INPUT_RECORD irec;
+
+  DWORD events_read;
+  
+  HANDLE h;
+  
+  DWORD sleep_time = 0;
+
+  h = sfd_to_handle(sfd);
+
+  if (h == INVALID_HANDLE_VALUE)
+  {
+    error("can't get a handle for sfd [%d]", sfd);
+
+    return 0;
+  }
+
+  for (;;)
+  {
+    int ret = PeekConsoleInput (h, &irec, 1, &events_read);
+
+    if (!ret)
+    {
+      debug("PeekConsoleInput on sfd [%d] failed with error code [%d]",
+                 sfd, GetLastError());
+      return 0;
+    }
+
+    if (events_read && irec.EventType == KEY_EVENT)
+    {
+      break;
+    }
+    else if (events_read)
+    {
+      ReadConsoleInput (h, &irec, 1, &events_read);
+    }
+
+    Sleep (sleep_time >> 3);
+    
+    if (sleep_time < 80)
+    {
+      sleep_time++;
+    }  
+  }
+
+  return 1;
+}
+
+
+int peekConsoleWrite(int sfd)
+{
+  return 1;
+}
+
+
+int peekPipeRead(int sfd)
+{
+  HANDLE h;
+
+  DWORD n = 0;
+  
+  DWORD pFlags = 0;
+  
+  DWORD sleep_time = 0;
+  
+  int ret = 0;
+
+  h = sfd_to_handle(sfd);
+
+  if (h == INVALID_HANDLE_VALUE)
+  {
+    error("can't get a handle for sfd [%d]", sfd);
+    
+    return 0;
+  } 
+
+  ret = GetNamedPipeInfo(h, &pFlags, NULL, NULL, NULL);
+
+  if (!ret)
+  {
+    error("GetNamedPipeInfo on sfd [%d] failed with error code [%d]",
+              sfd, GetLastError());
+    return 0;
+  }
+
+  for (;;)
+  {
+    ret = PeekNamedPipe (h, NULL, 0, NULL, &n, NULL);
+
+    if (!ret)
+    {
+      error("PeekNamedPipe on sfd [%d] failed with error code [%d]",
+                sfd, GetLastError());
+      return 0;
+    }
+
+    if (n > 0)
+    {
+      break;
+    }
+
+    Sleep (sleep_time >> 3);
+    
+    if (sleep_time < 80)
+    {
+      sleep_time++;
+    }  
+  }
+
+  return 1;
+}
+
+
+int peekPipeWrite(int sfd)
+{
+  return 1;
+}
+
+
+int selectSocketRead(int sfd)
+{
+  DBG_MSG("-> selectSocketRead(sfd = %d)...\n", sfd);
+  
+  int ret = 0;
+
+  fd_set readsocks;
+  
+  struct timeval timeout = {1, 0};
+
+  FD_ZERO(&readsocks);
+
+  FD_SET((SOCKET) sfd_to_handle(sfd), &readsocks);
+
+  
+  DBG_MSG("selectSocketRead(sfd = %d) : readsocks.fd_count = %d\n", sfd, readsocks.fd_count);
+  
+  DBG_MSG("selectSocketRead(sfd = %d, socket = %d) : select...\n", 
+              (int) sfd, (int) sfd_to_handle(sfd));
+  
+  while(ret == 0)
+  {
+    FD_ZERO(&readsocks);
+
+    FD_SET((SOCKET) sfd_to_handle(sfd), &readsocks);
+
+    ret = select(0, &readsocks, NULL, NULL, &timeout);
+  }
+  
+  DBG_MSG("selectSocketRead(sfd = %d, socket = %d) : end select...\n", 
+              (int) sfd, (int) sfd_to_handle(sfd));
+
+  /*
+   * Bail if select failed for some reason.
+   */
+  
+  if (ret == SOCKET_ERROR)
+  {
+    error("select on sfd [%d] failed with error code [%d]",
+              sfd, GetLastError());
+
+    DBG_MSG("<- selectSocketRead(sfd = %d)...\n", sfd);
+
+    return 0;
+  }
+
+  DBG_MSG("<- selectSocketRead(sfd = %d)...\n", sfd);
+  
+  return 1;
+}
+
+
+int selectSocketWrite(int sfd)
+{
+  DBG_MSG("-> selectSocketWrite(sfd = %d)...\n", sfd);
+  
+  int ret = 0;
+
+  fd_set writesocks;
+  
+  struct timeval timeout = {1, 0};
+
+  FD_ZERO(&writesocks);
+
+  FD_SET((SOCKET) sfd_to_handle(sfd), &writesocks);
+
+  DBG_MSG("selectSocketWrite(sfd = %d) : writesocks.fd_count = %d...\n", sfd, writesocks.fd_count);
+
+  DBG_MSG("selectSocketWrite(sfd = %d, socket = %d) : select...\n", 
+              (int) sfd, (int) sfd_to_handle(sfd));
+
+  while (ret == 0)
+  {
+    FD_ZERO(&writesocks);
+
+    FD_SET((SOCKET) sfd_to_handle(sfd), &writesocks);
+
+    ret = select(0, NULL, &writesocks, NULL, &timeout);
+  }
+  
+  DBG_MSG("selectSocketWrite(sfd = %d, socket = %d) : end select...\n", 
+              (int) sfd, (int) sfd_to_handle(sfd));
+
+  /*
+   * Fail if select failed for some reason.
+   */
+
+  if (ret == SOCKET_ERROR)
+  {
+    error("select on sfd [%d] failed with error code [%d]",
+              sfd, GetLastError());
+          
+    DBG_MSG("<- selectSocketWrite(sfd = %d)...\n", sfd);
+          
+    return 0;
+  }
+
+  DBG_MSG("<- selectSocketWrite(sfd = %d)...\n", sfd);
+ 
+  return 1;
+}
+
+
+DWORD WINAPI selectThread( LPVOID lpParam )
+{
+  DBG_MSG("-> selectThread()...\n");
+  
+  DWORD dwWaitResult;
+
+  thread_data_p thread_data;
+
+  thread_data = (thread_data_p)lpParam;
+
+  int sfd = thread_data -> sfd;
+  int thread_no = thread_data -> thread_no;
+  int test_type = thread_data -> test_type;
+
+  debug2("starting thread [%i] for sfd [%i] with test type[%i]",
+                  thread_no, sfd, test_type);
+
+  while(1)
+  {
+
+    dwWaitResult = WaitForSingleObject(thread_data -> semaphore1, INFINITE);
+
+    if (thread_data -> exit)
+    {
+      goto out;
+    }  
+
+    switch (dwWaitResult)
+    {
+      case WAIT_OBJECT_0:
+      {
+        switch(get_sfd_type(sfd))
+        {
+          case SFD_TYPE_FD:
+          {
+            break;
+          }  
+        
+          case SFD_TYPE_SOCKET:
+          {
+            if (test_type == TEST_READ)
+            {
+              selectSocketRead(sfd);
+            }  
+            else
+            {
+              selectSocketWrite(sfd);
+            }  
+            
+            break;
+          }  
+          
+          case SFD_TYPE_PIPE:
+          {  
+            if (test_type == TEST_READ)
+            {
+              peekPipeRead(sfd);
+            }  
+            else
+            {
+              peekPipeWrite(sfd);
+            }
+            
+            break;
+          }  
+         
+          case SFD_TYPE_CONSOLE:
+          {
+            if (test_type == TEST_READ)
+            {
+              peekConsoleRead(sfd);
+            }  
+            else
+            {
+              peekConsoleWrite(sfd);
+            }  
+            
+            break;
+          }  
+        }
+      
+        if (thread_data -> exit)
+        {
+          goto out;
+        }  
+
+        if (!ReleaseSemaphore(thread_data -> semaphore2, 1, NULL))
+        {
+          error("WaitForSingleObject in thread [%d] failed with error code [%d]",
+                    thread_no, GetLastError());
+
+          return 0;
+        } 
+          
+        break;
+      }  
+
+      default:
+      {
+        error("ReleaseSemaphore in thread [%d] failed with error code [%d]",
+                   thread_no, GetLastError());
+
+        return 0;
+      }
+    }  
+  }
+
+  out:
+
+  debug2("stopping thread [%i] for sfd [%i] with test type[%i]",
+                  thread_no, sfd, test_type);
+
+  thread_data -> exited = 1;
+
+  DBG_MSG("<- selectThread()...\n");
+  
+  ExitThread(1);
+
+  return 1;
+}
+
+
+int startSelectThread(int sfd, int test_type)
+{
+  DBG_MSG("-> startSelectThread(sfd = %d, test_type = %d)...\n", sfd, test_type);
+  
+  int thread_no = 0;
+  
+  int i;
+  
+  DWORD ID;
+
+  for (i = 0; i < MAX_THREADS; i++)
+  {
+    if (thread_data_set[i] == NULL)
+    {
+      thread_no = i;
+      
+      break;
+    }
+  }
+
+  if (thread_data_set[thread_no] != NULL)
+  {
+      fatal("MAX_THREADS exceed");
+  }
+
+  thread_data_set[thread_no] = (thread_data_p) HeapAlloc(GetProcessHeap(), 
+                                                             HEAP_ZERO_MEMORY, 
+                                                                 sizeof(thread_data_t));
+
+  if (thread_data_set[thread_no] == NULL)
+  {
+    fatal("heap allocation failed with error code [%d]", GetLastError());
+  }
+
+  thread_data_set[thread_no] -> sfd       = sfd;
+  thread_data_set[thread_no] -> thread_no = thread_no;
+  thread_data_set[thread_no] -> test_type = test_type;
+  thread_data_set[thread_no] -> signaled  = 0;
+  thread_data_set[thread_no] -> exit      = 0;
+  thread_data_set[thread_no] -> exited    = 0;
+
+  thread_data_set[thread_no] -> semaphore1 = CreateSemaphore(NULL, 1, 1, NULL);
+
+  if (thread_data_set[thread_no] -> semaphore1 == NULL)
+  {
+    fatal("CreateSemaphore failed with error code [%d]",
+              GetLastError());
+  }
+
+  thread_data_set[thread_no] -> semaphore2 = CreateSemaphore(NULL, 0, 1, NULL);
+
+  if (thread_data_set[thread_no] -> semaphore2 == NULL)
+  {
+    fatal("CreateSemaphore failed with error code [%d]", GetLastError());
+  }
+
+  thread_data_set[thread_no] -> thread = CreateThread(NULL, 0, selectThread, 
+                                                        thread_data_set[thread_no],
+                                                            0, &ID);
+
+  thread_data_set[thread_no] -> thread_id = ID;
+
+
+  if (thread_data_set[thread_no] -> thread == NULL)
+  {
+      fatal("CreateThread failed with error code [%d]", GetLastError());
+  }
+
+  DBG_MSG("<- startSelectThread(thread_no = %d)...\n", thread_no);
+
+  return thread_no;
+}
+
+
+int cleanSelectThread(int thread_no)
+{
+  DBG_MSG("-> cleanSelectThread(thread_no = %d)...\n", thread_no);
+  
+  CloseHandle(thread_data_set[thread_no] -> semaphore1);
+  CloseHandle(thread_data_set[thread_no] -> semaphore2);
+  CloseHandle(thread_data_set[thread_no] -> thread);
+
+  if(thread_data_set[thread_no] != NULL)
+  {
+    HeapFree(GetProcessHeap(), 0, thread_data_set[thread_no]);
+   
+    thread_data_set[thread_no] = NULL;
+  }
+  
+  DBG_MSG("<- cleanSelectThread()...\n");
+          
+  return 1;
+}
+
+
+int WSHELPselect(int fds, fd_set* readsfds, fd_set* writesfds,
+                     fd_set* exceptsfds, const struct timeval* timeout)
+{
+  DBG_MSG("-> WSHELPselect(fds = %d)...\n", fds);
+  
+  DWORD dwWaitResult;
+
+  DWORD ms;
+
+  unsigned int i;
+  
+  int count = 0;
+
+  static int sfd_read_to_thread_map[MAX_THREADS] = {0};
+
+  static int sfd_write_to_thread_map[MAX_THREADS] = {0};
+
+  HANDLE semaphores[MAX_THREADS] = {NULL};
+
+  int i_sem = 0;
+  
+  int semaphores_to_thread_map[MAX_THREADS] = {0};
+
+  static unsigned int threads_count = 0;
+
+  /*
+   * 'except' should be implemented.
+   */
+   
+  if (exceptsfds)
+  {
+    fatal("exceptsfds not implemented");
+  }
+
+  /*
+   * convert timeout to ms or to INFINITE if null.
+   */
+
+  ms = timeout ? (DWORD) (timeout -> tv_sec * 1000) + (timeout -> tv_usec / 1000) : INFINITE;
+
+  if (ms == 0 && timeout -> tv_usec)
+  {
+    ms = 1;
+  }  
+
+  /*
+   * just wait if all set's are empty.
+   */
+   
+  if (!readsfds && !writesfds && !exceptsfds)
+  {
+    HANDLE empty = NULL;
+
+    dwWaitResult = WaitForSingleObject(empty, ms);
+
+    switch (dwWaitResult)
+    {
+      case WAIT_OBJECT_0:
+      { 
+        errno = EINTR;
+
+        DBG_MSG("<- WSHELPselect(fds = %d, ret = -1)...\n", fds);
+            
+        return -1;
+      }  
+            
+      case WAIT_FAILED:
+      {
+        fatal("WaitForSingleObject failed with error code [%d]", GetLastError());
+      }
+      
+      case WAIT_TIMEOUT:
+      {      
+        DBG_MSG("<- WSHELPselect(fds = %d, ret = 0)...\n", fds);
+            
+        return 0;
+      }  
+    }
+  }
+
+  /*
+   * threads for read fds removed from set should be stopped.
+   */
+  
+  DBG_MSG("WSHELPselect(fds = %d) : stopping threads for read fds "
+            "removed from set...\n", fds);
+  
+  if (read_sfd_set.fd_count != 0)
+  {
+    for (i = 0; i < read_sfd_set.fd_count; ++i)
+    {
+      int sfd = (int) read_sfd_set.fd_array[i];
+      
+      if (!FD_ISSET(sfd, readsfds))
+      {
+        //int thread_no = thread_data_set[sfd_read_to_thread_map[sfd]] -> thread_no;
+
+        //debug("WSHELPselect(fds = %d) :   stoping thread_no = %d for sfd = %d...\n", fds, thread_no, sfd);
+
+        thread_data_set[sfd_read_to_thread_map[sfd]] -> exit = 1;
+
+        FD_CLR((SOCKET) sfd, &read_sfd_set);
+
+        sfd_read_to_thread_map[sfd] = -1;
+      }
+      //else
+      //{
+      //  debug("WSHELPselect(fds = %d) : i = %d : sfd = %d, FD_ISSET != 0...\n", fds, sfd);
+      //}
+    }
+  }
+
+  /*
+   * threads for write fds removed from set should be stopped.
+   */
+
+  DBG_MSG("WSHELPselect(fds = %d) : stopping threads for write fds removed from set...\n", fds);
+        
+  if (write_sfd_set.fd_count != 0)
+  {
+    for (i = 0; i < write_sfd_set.fd_count; ++i)
+    {
+      int sfd = (int) write_sfd_set.fd_array[i];
+      
+      if (!FD_ISSET(sfd, writesfds))
+      {
+        //int thread_no = thread_data_set[sfd_read_to_thread_map[sfd]] -> thread_no;
+        
+        //debug("WSHELPselect(fds = %d) :   stopping thread_no = %d for sfd = %d...\n", fds, thread_no, sfd);
+
+        thread_data_set[sfd_write_to_thread_map[sfd]] -> exit = 1;
+        
+        FD_CLR((SOCKET) sfd, &write_sfd_set);
+        
+        sfd_write_to_thread_map[sfd] = -1;
+      }
+      //else
+      //{
+      //  debug("WSHELPselect(fds = %d) : i = %d : sfd = %d, FD_ISSET != 0...\n", fds, sfd);
+      //}
+    }
+  }
+
+  DBG_MSG("WSHELPselect(fds = %d) : Weaking up threads signaled in previous run...\n", fds);
+
+  for (i = 0; i < MAX_THREADS; i++)
+  {
+    /*
+     * threads signaled in previous run should be waken up.
+     */
+  
+    if (thread_data_set[i] != NULL && thread_data_set[i] -> signaled == 1)
+    {
+      if (!ReleaseSemaphore(thread_data_set[i] -> semaphore1, 1, NULL))
+      {
+        fatal("ReleaseSemaphore failed with error code [%d]", GetLastError());
+      }
+    
+      thread_data_set[i] -> signaled = 0;
+    }
+     
+    /*
+     * Cleaning after exited threads.
+     */
+    
+    if (thread_data_set[i] != NULL && thread_data_set[i] -> exited == 1)
+    {
+      cleanSelectThread(i);
+
+      threads_count--;
+    }
+  }
+
+  /*
+   * new thread should be started for each new read fd.
+   */
+
+  DBG_MSG("WSHELPselect(fds = %d) : Starting new thread for each new read fd...\n", fds);
+  
+  if (readsfds != NULL && readsfds -> fd_count != 0)
+  {
+    for (i = 0; i < readsfds -> fd_count; ++i)
+    {
+      int sfd = (int) readsfds -> fd_array[i];
+      
+      if (!FD_ISSET(sfd, &read_sfd_set))
+      {
+        int thread_no = startSelectThread(sfd, TEST_READ);
+        
+        //debug("WSHELPselect(fds = %d) :   Starting read thread (thread_no = %d) for sfd = %d...\n",
+        //          fds, thread_no, sfd);
+        
+        read_sfd_set_add(sfd);
+        
+        sfd_read_to_thread_map[sfd] = thread_no;
+        
+        threads_count++;
+      }
+    }
+  }
+
+  /*
+   * New thread should be started for each new write fd.
+   */
+
+  DBG_MSG("WSHELPselect(fds = %d) : Starting new thread for each new write fd...\n", fds);
+  
+  if (writesfds != NULL && writesfds -> fd_count != 0)
+  {
+    for (i = 0; i < writesfds -> fd_count; ++i)
+    {
+      int sfd = (int) writesfds -> fd_array[i];
+   
+      if (!FD_ISSET(sfd, &write_sfd_set))
+      {
+        int thread_no = startSelectThread(sfd, TEST_WRITE);
+        
+        //debug("WSHELPselect(fds = %d) :   Starting write thread (thread_no = %d) for sfd = %d...\n",
+        //          fds, thread_no, sfd);
+
+        
+        write_sfd_set_add(sfd);
+        
+        sfd_write_to_thread_map[sfd] = thread_no;
+        
+        threads_count++;
+      }
+    }
+  }
+
+  /*
+   * constructing array of semaphores for working threads
+   * new array is needed because in threads map we can have
+   * threads which should exit right now.
+   */
+
+  DBG_MSG("WSHELPselect(fds = %d) : constructing array of semaphores for working threads...\n", fds);
+
+  for (i = 0; i < MAX_THREADS; i++)
+  {
+    if (thread_data_set[i] != NULL && !thread_data_set[i] -> exit )
+    {
+      semaphores[i_sem] = thread_data_set[i] -> semaphore2;
+
+      semaphores_to_thread_map[i_sem] = i;
+      
+      i_sem++;
+    }
+
+  }
+
+  /*
+   * wait for signal from threads.
+   */
+   
+  #ifdef NX_DEBUG
+  
+  {
+    char str[256] = "{";
+    char tmp[32]  = "";
+    
+    for (i = 0; i < read_sfd_set.fd_count; ++i)
+    {
+      int sfd = (int) read_sfd_set.fd_array[i];
+      
+      sprintf(tmp, " %d", sfd);
+      
+      strcat(str, tmp);
+    }
+    
+    strcat(str, " }");
+    
+    debug("read_sfd_set = %s", str);
+  
+    /*
+     *
+     */
+  
+    str[0] = '{';
+    str[1] = '\0';
+    
+    for (i = 0; i < write_sfd_set.fd_count; ++i)
+    {
+      int sfd = (int) write_sfd_set.fd_array[i];
+      
+      sprintf(tmp, " %d", sfd);
+      
+      strcat(str, tmp);
+    }
+    
+    strcat(str, " }");
+    
+    debug("write_sfd_set = %s", str);
+  }
+  
+  #endif
+  
+  
+  DBG_MSG("WSHELPselect(fds = %d) : Waiting for signal from threads...\n", fds);
+
+  DBG_MSG("i_sem = %d\n", i_sem);
+  
+  dwWaitResult = WaitForMultipleObjects(i_sem, semaphores, FALSE, ms);
+
+  //debug("WSHELPselect(fds = %d) :   FD_ZERO(readsfds)...\n", fds);
+  
+  if (readsfds) FD_ZERO(readsfds);
+  
+  //debug("WSHELPselect(fds = %d) :   FD_ZERO(writesfds)...\n", fds);
+  
+  if (writesfds) FD_ZERO(writesfds);
+  
+  //debug("WSHELPselect(fds = %d) :   FD_ZERO(exceptsfds)...\n", fds);
+  
+  if (exceptsfds) FD_ZERO(exceptsfds);
+
+  switch (dwWaitResult)
+  {
+    case WAIT_FAILED:
+    {
+      fatal("WaitForMultipleObjects failed with error code [%d]", GetLastError());
+    }
+      
+    case WAIT_TIMEOUT:
+    {
+      DBG_MSG("<- WSHELPselect(fds = %d, ret = 0)...\n", fds);
+     
+      return 0;
+    }   
+  }
+
+  /*
+   * Prepare return fd sets with signaled fd's.
+   */
+
+  //debug("WSHELPselect(fds = %d) : preparing return fd sets with signaled fd's...\n", fds);
+  
+  for (i = 0; i<MAX_THREADS; i++)
+  {
+    if (dwWaitResult == WAIT_OBJECT_0 + i)
+    {
+      int thread_no = semaphores_to_thread_map[i];
+      
+      if (thread_data_set[thread_no] -> test_type == TEST_READ)
+      {
+        FD_SET((SOCKET) thread_data_set[thread_no] -> sfd, readsfds);
+        
+        DBG_MSG("WSHELPselect(fds = %d) :   "
+                       "thread_no = %d, sfd = %d, readsfds = %d...\n", 
+                           fds, thread_no,
+                               thread_data_set[thread_no] -> sfd, (int) readsfds);
+      }
+      else
+      {
+        FD_SET((SOCKET) thread_data_set[thread_no] -> sfd, writesfds);
+        
+        DBG_MSG("WSHELPselect(fds = %d) :   "
+                       "thread_no = %d, sfd = %d, readsfds = %d...\n", 
+                           fds, thread_no, 
+                               thread_data_set[thread_no] -> sfd, (int) writesfds);
+      }  
+
+      count ++;
+
+      thread_data_set[thread_no] -> signaled = 1;
+    }
+  }
+
+  DBG_MSG("<- WSHELPselect(fds = %d, ret = %d)...\n", fds, count);
+  
+  return count;
+}
+
+/*
+ * IO functions.
+ */
+
+int WSHELPread(int sfd, char *dst, unsigned int max)
+{
+  DBG_MSG("-> WSHELPread(sfd = %d)...\n", sfd);
+
+  SOCKET sock;
+
+  int ret = -1;
+
+  switch(get_sfd_type(sfd))
+  {
+    case SFD_TYPE_SOCKET:
+    {
+      /*
+       * Clear errno.
+       */
+      
+      errno = 0;
+
+      /*
+       * Get the SOCKET.
+       */
+      
+      sock = (SOCKET) sfd_to_handle(sfd);
+
+      /*
+       * Call the underlying function.
+       */
+      
+      ret = recv(sock, dst, max, 0);
+
+      if (FD_ISSET(sfd, &debug_sfds))
+      {
+        if (ret > 0)
+        {
+          dst[ret] = '\0';
+
+          debug("read[%d]: %s", sfd, dst);
+        }
+      }
+
+      if (ret < 0)
+      {
+        debug("read from socket sfd [%d] failed with error code [%d]",
+                  sfd, GetLastError());
+      }
+
+      /*
+       * Check for errors.
+       */
+      
+      if (ret == SOCKET_ERROR)
+      {
+        errno = getWSAErrno();
+        
+        DBG_MSG("WSHELPread(sfd = %d) : SOCKET_ERROR...\n", sfd);
+
+        DBG_MSG("<- WSHELPread(sfd = %d, ret = -1)...\n", sfd);
+        
+        return -1;
+      }
+
+      break;
+    }
+    
+    case SFD_TYPE_FD:
+    case SFD_TYPE_PIPE:
+    case SFD_TYPE_CONSOLE:
+    {
+      ret = _read(sfd_to_fd(sfd), dst, max);
+      
+      if (FD_ISSET(sfd_to_fd(sfd), &debug_sfds))
+      {
+        if (ret > 0)
+        {
+          dst[ret] = '\0';
+
+          debug("read[%d] len %d: %s", sfd_to_fd(sfd), ret, dst);
+        }
+      }
+
+      if (ret < 0)
+      {
+        error("read from pipe/console sfd [%d] failed with error code [%d]",
+                  sfd, GetLastError());
+      }
+
+      break;
+    }  
+  }
+
+  DBG_MSG("<- WSHELPread(sfd = %d, ret = %d)...\n", sfd, ret);
+  
+  return ret;
+}
+
+int WSHELPwrite(int sfd, const char *buf, unsigned int max)
+{
+  DBG_MSG("-> WSHELPwrite(sfd = %d)...\n", sfd);
+  
+  SOCKET sock;
+  
+  int ret = -1;
+
+  switch(get_sfd_type(sfd))
+  {
+    case SFD_TYPE_SOCKET:
+    {
+      /*
+       * Clear errno.
+       */
+      
+      errno = 0;
+
+      /*
+       * Get the SOCKET.
+       */
+      
+      sock = (SOCKET) sfd_to_handle(sfd);
+
+      if (FD_ISSET(sfd, &crlf_sfds) && max == 1 && buf[0] == 13)
+      {
+        /*
+         * FIXME: We're getting CR's (13) instead of CR + LF or just LF, 
+         * either of which would work.
+         */
+        
+        char locbuf[1] = {10};
+
+        ret = send(sock, locbuf, 1, 0);
+      }
+      else
+      {
+        /*
+         * Call the underlying function.
+         */
+        
+        ret = send(sock, buf, max, 0);
+      }
+
+      if (FD_ISSET(sfd, &debug_sfds))
+      {
+        if (ret > 0)
+        {
+          static int writecount = 0;
+          
+          char *locbuf = malloc(max + 1);
+          
+          memcpy(locbuf, buf, max);
+
+          locbuf[max] = '\0';
+
+          writecount += max;
+
+          debug("write[%d] len %d: %s", sfd, max, locbuf);
+          
+          if (max == 1)
+          {
+            debug("write[%d] one char: %08x", sfd, locbuf[0]);
+          }
+          
+          free(locbuf);
+        }
+      }
+
+      if (ret < 0)
+      {
+        /*
+         * write error only if failed sfd is not a stderr (2).
+         */
+
+        if (sfd != 2)
+        {
+          error("write to socket sfd [%d] failed with error code [%d]",
+                    sfd, GetLastError());
+
+          DBG_MSG("<- WSHELPwrite(sfd = %d, ret = -1)...\n", sfd);
+        }
+
+        exit(-1);
+      }
+
+      /*
+       * Check for errors.
+       */
+      
+      if (ret == SOCKET_ERROR)
+      {
+        errno = getWSAErrno();
+
+        DBG_MSG("WSHELPwrite(sfd = %d) : SOCKET_ERROR...\n", sfd);
+
+        DBG_MSG("<- WSHELPwrite(sfd = %d, ret = -1)...\n", sfd);
+
+        return -1;
+      }
+      break;
+    }  
+
+    case SFD_TYPE_FD:
+    case SFD_TYPE_PIPE:
+    case SFD_TYPE_CONSOLE:
+    {
+      ret = _write(sfd_to_fd(sfd), buf, max);
+      
+      if (FD_ISSET(sfd_to_fd(sfd), &debug_sfds))
+      {
+        if (ret > 0)
+        {
+          char *locbuf = malloc(max + 1);
+         
+          memcpy(locbuf, buf, max);
+
+          locbuf[max] = '\0';
+          
+          debug("write[%d]: %s", sfd_to_fd(sfd), locbuf);
+          
+          free(locbuf);
+        }
+      }
+
+      if (ret < 0)
+      {
+        /*
+         * write error only if failed sfd is not a stderr (2).
+         */
+  
+        if (sfd != 2)
+        {
+          error("write to pipe/console sfd [%d] failed with error code [%d]",
+                    sfd, GetLastError());
+        }
+      }
+      
+      break;
+    }  
+  }
+
+  DBG_MSG("<- WSHELPwrite(sfd = %d, ret = %d)...\n", sfd, ret);
+  
+  return ret;
+}
+
+
+int WSHELPclose(int sfd)
+{
+  DBG_MSG("-> WSHELPclose(sfd = %d)...\n", sfd);
+  
+  int i;
+  
+  int socketInUse = 0;
+  
+  SOCKET sock;
+  
+  int ret = -1;
+
+  switch(get_sfd_type(sfd))
+  {
+    case SFD_TYPE_SOCKET:
+    {
+      /*
+       * Clear errno.
+       */
+      
+      errno = 0;
+
+      /*
+       * Get the SOCKET.
+       */
+      
+      sock = (SOCKET) sfd_to_handle(sfd);
+     
+      if (sock == INVALID_SOCKET)
+      {
+        errno = EBADF;
+               
+        DBG_MSG("WSHELPclose(sfd = %d) : INVALID_SOCKET...\n", sfd);
+
+        DBG_MSG("<- WSHELPclose(sfd = %d, ret = -1)...\n", sfd);
+               
+        return -1;
+      }
+
+      /*
+       * Remove cookie in SocketCookieMap var (for AF_UNIX only).
+       */
+      
+      for (i = 0; i < SFD_MAP_SIZE; i++)
+      {
+        /*
+         * Find socket in table.
+         */
+        
+        if (SocketCookieMap[i].socket == sock)
+        {
+          /*
+           * Remove cookie.
+           */
+          
+          SocketCookieMap[i].socket = 0;
+
+          if (SocketCookieMap[i].cookie)
+          {
+            free(SocketCookieMap[i].cookie);
+          }
+          
+          if (SocketCookieMap[i].f)
+          {
+            fclose(SocketCookieMap[i].f);
+          }
+          
+          break;
+        }
+      }
+
+      /*
+       * Test is socket in use by another sfd?
+       */
+
+      socketInUse = 0;
+
+      i = 0;
+      
+      while(!socketInUse && i < SFD_MAP_SIZE)
+      {
+        //DBG_MSG("%d |-> %d ? %d\n", i, sfd_to_handle(i), sock);
+        
+        if (((int) sfd_to_handle(i) == (int) sock) && (i != (int) sfd))
+        {
+          socketInUse = 1;
+        }
+
+        i++;
+      }
+      
+      /*
+       * Call the underlying function.
+       */
+
+      if (!socketInUse)
+      {
+        DBG_MSG("Closing socket %d\n", sock);
+      
+        ret = closesocket(sock);
+      }
+      else
+      {
+        DBG_MSG("Socket %d in use.\n", sock);
+        
+        ret = 0;
+      }
+
+      /*
+       * Remove mapping table entry.
+       */
+      
+      free_sfd(sfd);
+
+      /*
+       * Check for errors.
+       */
+      
+      if (ret == SOCKET_ERROR)
+      {
+        errno = getWSAErrno();
+              
+        DBG_MSG("WSHELPclose(sfd = %d) : SOCKET_ERROR...\n", sfd);
+
+        DBG_MSG("<- WSHELPclose(sfd = %d, ret = -1)...\n", sfd);
+              
+        return -1;
+      }
+      
+      break;
+    }  
+    
+    case SFD_TYPE_FD:
+    case SFD_TYPE_PIPE:
+    case SFD_TYPE_CONSOLE:
+    {
+      ret = _close(sfd_to_fd(sfd));
+
+      free_sfd(sfd);
+
+      break;
+    }  
+  }
+
+  DBG_MSG("<- WSHELPclose(sfd = %d, ret = %d)...\n", sfd, ret);
+  
+  return ret;
+}
+
+
+/*
+ * Internal functions.
+ */
+
+void WSHELPinitialize()
+{
+  DBG_MSG("-> WSHELPinitialize()...\n");
+  
+  WORD wVersionRequested;
+  
+  WSADATA wsaData;
+  
+  int err;
+
+  wVersionRequested = MAKEWORD(2, 2);
+
+  if (WSAStartup(wVersionRequested, &wsaData))
+  {  
+    fatal("ERROR: Cannot initialize WinSock DLL.");
+  }  
+
+  /*
+   * Confirm that the WinSock DLL supports 2.2. 
+   * Note that if the DLL supports versions greater   
+   * than 2.2 in addition to 2.2, it will still return
+   * 2.2 in wVersion since that is the version we     
+   * requested.
+   */
+  
+  if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2)
+  {
+    fatal("ERROR: WinSock 2.2 needed.");
+  }
+
+  /*
+   * The WinSock DLL is acceptable. Proceed.
+   */
+  
+  winsock_initialized = 1;
+
+  DBG_MSG("<- WSHELPinitialize()...\n");
+}
+
+
+void allocate_standard_descriptor(int fd)
+{
+  DBG_MSG("-> allocate_standard_descriptor(fd = %d)...\n", fd);
+  
+  allocate_sfd(fd);
+  
+  DBG_MSG("<- allocate_standard_descriptor()...");
+}
diff --git a/contrib/win32/win32compat/startupneeds.c b/contrib/win32/win32compat/startupneeds.c
new file mode 100644
index 0000000..ee48214
--- /dev/null
+++ b/contrib/win32/win32compat/startupneeds.c
@@ -0,0 +1,41 @@
+/*
+ * Author: NoMachine <developers@nomachine.com>
+ *
+ * Copyright (c) 2009, 2010 NoMachine
+ * All rights reserved
+ *
+ * Support functions and system calls' replacements needed to let the
+ * software run on Win32 based operating systems.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "includes.h"
+
+#include <sys/socket.h>
+
+int startup_handler(void)
+{
+  WSHELPinitialize();
+
+  return 0;
+}
diff --git a/contrib/win32/win32compat/strcasecmp.c b/contrib/win32/win32compat/strcasecmp.c
new file mode 100644
index 0000000..07c38ea
--- /dev/null
+++ b/contrib/win32/win32compat/strcasecmp.c
@@ -0,0 +1,103 @@
+/*
+ * Author: NoMachine <developers@nomachine.com>
+ *
+ * Copyright (c) 2009, 2010 NoMachine
+ * All rights reserved
+ *
+ * Support functions and system calls' replacements needed to let the
+ * software run on Win32 based operating systems.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* NX */
+/* Similar to strcasecmp.c from OpenBSD */
+/* Note: This could be moved to the OpenBSD-Compat layer in OpenSSH and added to config.h etc. */
+
+#include "includes.h"
+#if !defined(HAVE_STRCASECMP) || !defined(HAVE_STRNCASECMP)
+#include <sys/types.h>
+#include <string.h>
+#endif
+
+#ifndef HAVE_STRCASECMP
+size_t strcasecmp(const char *left, const char *right)
+{
+  #if 0
+ 
+  const unsigned char *uleft = (const unsigned char *) left, *uright = (const unsigned char *) right;
+
+  while (tolower(*uleft) == tolower(*uright))
+  {
+    if (*uleft++ == '\0')
+    {
+      return (0);
+    }
+    
+    uright++;
+  }
+  
+  return (tolower(*uleft) - tolower(*uright));
+  
+  #else
+  
+  return stricmp(left, right);
+  
+  #endif
+}
+#endif
+
+#ifndef HAVE_STRNCASECMP
+size_t strncasecmp(const char *left, const char *right, size_t n)
+{
+  #if 0
+
+  if (n != 0)
+  {
+    const unsigned char *uleft = (const unsigned char *) left, *uright = (const unsigned char *) right;
+
+    do
+    {
+      if (tolower(*uleft) != tolower(*uright))
+      {
+        return (tolower(*uleft) - tolower(*uright));
+      }
+      
+      if (*uleft++ == '\0')
+      {
+        break;
+      }
+      
+      uright++;
+    }
+    while (--n != 0);
+  }
+  
+  return (0);
+
+  #else
+  
+  return strnicmp(left, right, n);
+  
+  #endif
+}
+#endif
diff --git a/contrib/win32/win32compat/stringhelp.c b/contrib/win32/win32compat/stringhelp.c
new file mode 100644
index 0000000..358414c
--- /dev/null
+++ b/contrib/win32/win32compat/stringhelp.c
@@ -0,0 +1,54 @@
+/*
+ * Author: NoMachine <developers@nomachine.com>
+ *
+ * Copyright (c) 2009, 2010 NoMachine
+ * All rights reserved
+ *
+ * Support functions and system calls' replacements needed to let the
+ * software run on Win32 based operating systems.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <Windows.h>
+
+#define SocketErrorStringSize 1024
+
+char * strerror_win32(int error)
+{
+
+  char SocketErrorString[2 * SocketErrorStringSize] = { 0 };
+
+  DWORD error_win32 = WSAGetLastError();
+
+  if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
+                        NULL, error_win32, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
+                            (LPTSTR) SocketErrorString, SocketErrorStringSize,
+                                NULL ) != 0)
+  {
+    return SocketErrorString;
+  }
+  else
+  {
+    return "Unknown error";
+  }
+}
diff --git a/contrib/win32/win32compat/stringhelp.h b/contrib/win32/win32compat/stringhelp.h
new file mode 100644
index 0000000..9df958d
--- /dev/null
+++ b/contrib/win32/win32compat/stringhelp.h
@@ -0,0 +1,45 @@
+/*
+ * Author: NoMachine <developers@nomachine.com>
+ *
+ * Copyright (c) 2009, 2010 NoMachine
+ * All rights reserved
+ *
+ * Support functions and system calls' replacements needed to let the
+ * software run on Win32 based operating systems.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef STRINHELP_H
+#define STRINGHELP_H 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+char * strerror_win32(int);
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif
diff --git a/contrib/win32/win32compat/syslog.c b/contrib/win32/win32compat/syslog.c
new file mode 100644
index 0000000..17deb1f
--- /dev/null
+++ b/contrib/win32/win32compat/syslog.c
@@ -0,0 +1,48 @@
+/*
+ * Author: NoMachine <developers@nomachine.com>
+ *
+ * Copyright (c) 2009, 2010 NoMachine
+ * All rights reserved
+ *
+ * Support functions and system calls' replacements needed to let the
+ * software run on Win32 based operating systems.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* NX */
+/* Note: This should not be moved to OpenBSDCompat, as it is for Win32 only */
+#include "includes.h"
+
+#ifndef HAVE_SYSLOG
+void openlog(char *ident, unsigned int option, int facility)
+{
+}
+
+void closelog (void)
+{
+}
+
+void syslog (int priority, const char *format, const char *formatBuffer)
+{
+}
+#endif
diff --git a/contrib/win32/win32compat/win32auth.c b/contrib/win32/win32compat/win32auth.c
new file mode 100644
index 0000000..2b4015c
--- /dev/null
+++ b/contrib/win32/win32compat/win32auth.c
@@ -0,0 +1,795 @@
+/*
+ * Author: NoMachine <developers@nomachine.com>
+ *
+ * Copyright (c) 2009, 2011 NoMachine
+ * All rights reserved
+ *
+ * Support functions and system calls' replacements needed to let the
+ * software run on Win32 based operating systems.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "win32auth.h"
+
+/*
+ * Retrieve Security ID (SID) from username.
+ *
+ * psid   - output SID (OUT)
+ * user   - username string (IN)
+ *
+ * RETURNS: 0 if OK.
+ */
+
+static int GetSidW(PSID *psid, const wchar_t *user)
+{
+  wchar_t *refDomain = NULL;
+
+  DWORD refDomainSize = 0;
+
+  DWORD sidSize = 0;
+
+  SID_NAME_USE peUse;
+    
+  int exitCode = 1;
+
+  /*
+   * Retrieve SID's size
+   */
+
+  LookupAccountNameW(NULL, user, NULL, &sidSize, NULL, &refDomainSize, &peUse);
+
+  FAIL(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
+
+  /*
+   * Allocate buffer and retrieve SID
+   */
+  
+  *psid = (PSID) LocalAlloc(LPTR, sidSize);
+
+  refDomain = (wchar_t *) LocalAlloc(LPTR, refDomainSize * sizeof(wchar_t));
+
+  FAIL(LookupAccountNameW(NULL, user, *psid, &sidSize, 
+                             refDomain, &refDomainSize, &peUse) == FALSE);
+  
+  exitCode = 0;
+  
+fail:
+  
+  /*
+   * We don't need reference domain.
+   */
+  
+  if (refDomain)
+  {
+    LocalFree(refDomain);
+  }
+  
+  if (exitCode != 0)
+  {
+    debug("ERROR. Cannot retrieve SID (%u).", GetLastError());
+  }
+  
+  return exitCode;
+}
+
+
+/*
+ * Enable or disable privilege for current running process
+ *
+ * privName - privilege name (IN)
+ * enabled  - 1 for enabling, 0 for disabling (IN)
+ *
+ * RETURNS: 0 if OK.
+ */
+
+int EnablePrivilege(const char *privName, int enabled)
+{
+  TOKEN_PRIVILEGES tp;
+  
+  HANDLE hProcToken = NULL;
+  
+  LUID luid;
+
+  int exitCode = 1;
+
+  /*
+   * Retrievie LUID from privilege name
+   */
+  
+  FAIL(LookupPrivilegeValue(NULL, privName, &luid) == FALSE);
+  
+  /*
+   * Retrievie token for current running process
+   */
+
+  FAIL(OpenProcessToken(GetCurrentProcess(), 
+                            TOKEN_ADJUST_PRIVILEGES, &hProcToken) == FALSE);
+
+  /*
+   * Adjust privilege to current running process
+   */
+  
+  tp.PrivilegeCount           = 1;
+  tp.Privileges[0].Luid       = luid;
+  tp.Privileges[0].Attributes = enabled ? SE_PRIVILEGE_ENABLED : 0;
+
+  FAIL(AdjustTokenPrivileges(hProcToken, FALSE, &tp, 
+                                 sizeof(TOKEN_PRIVILEGES), NULL, NULL) == FALSE);
+
+  exitCode = 0;
+  
+fail:
+
+  /*
+   * Free allocated memory if needed.
+   */
+  
+  if (hProcToken)
+  {
+    CloseHandle(hProcToken);
+  }  
+
+  if (exitCode)
+  {
+    DWORD err = GetLastError();
+    
+    debug("ERROR. Cannot enable privilege to current process (%u).", err);
+  }
+  
+  return exitCode;
+}
+
+/*
+ * This functions allocate and initialize some 'well known' SIDs.
+ * This SIDs are global uniqualy, i.e. they are the same on all
+ * machines.
+ */
+
+static PSID LocalSID()
+{
+  PSID psid = NULL;
+
+  SID_IDENTIFIER_AUTHORITY nt = SECURITY_LOCAL_SID_AUTHORITY;
+  
+  AllocateAndInitializeSid(&nt, 1, 0, 0, 0, 0, 0, 0, 0, 0, &psid);
+  
+  return psid;
+}
+
+static PSID EveryoneSID()
+{
+  PSID psid = NULL;
+  
+  SID_IDENTIFIER_AUTHORITY nt = SECURITY_WORLD_SID_AUTHORITY;
+
+  AllocateAndInitializeSid(&nt, 1, 0, 0, 0, 0, 0, 0, 0, 0, &psid);
+  
+  return psid;
+}
+
+static PSID AuthenticatedUsersSID()
+{
+  PSID psid = NULL;
+
+  SID_IDENTIFIER_AUTHORITY nt = SECURITY_NT_AUTHORITY;
+  
+  AllocateAndInitializeSid(&nt, 1, SECURITY_AUTHENTICATED_USER_RID, 
+                               0, 0, 0, 0, 0, 0, 0, &psid);
+  
+  return psid;
+}
+
+static PSID InteractiveSID()
+{
+  PSID psid = NULL;
+  
+  SID_IDENTIFIER_AUTHORITY nt = SECURITY_NT_AUTHORITY;
+  
+  AllocateAndInitializeSid(&nt, 1, SECURITY_INTERACTIVE_RID,
+                               0, 0, 0, 0, 0, 0, 0, &psid);
+  
+  return psid;
+}
+
+/*
+ * Allocate new TOKEN_PRIVILEGES structure and fill it with privileges
+ * from given user account.
+ *
+ * pPrivToken - new, allocated structure (OUT)
+ * userSid    - SID of user (IN)
+ *
+ * RETURNS: 0 if OK.
+ */
+
+int SetupTokenPrivileges(PTOKEN_PRIVILEGES *pPrivToken, PSID userSid)
+{
+  DWORD ntStat = 0;
+  
+  int exitCode = 1;
+  
+  LSA_OBJECT_ATTRIBUTES lsaOA = {0};
+
+  PLSA_UNICODE_STRING userRights = NULL;
+  
+  ULONG nRights = 0;
+  
+  DWORD size;
+  
+  int i, j;
+  
+  /*
+   * Open local policy.
+   */
+
+  LSA_HANDLE hPolicy;
+  
+  lsaOA.Length = sizeof(lsaOA);
+  
+  ACCESS_MASK mask = POLICY_VIEW_LOCAL_INFORMATION | POLICY_LOOKUP_NAMES;
+  
+  debug("Opening local policy...");
+  
+  ntStat = LsaOpenPolicy(NULL, &lsaOA, mask, &hPolicy);
+  
+  FAIL(ntStat);
+  
+  /*
+   * Retrieve user's privileges.
+   */
+  
+  debug("Retrieving user's privileges list...");
+  
+  ntStat = LsaEnumerateAccountRights(hPolicy, userSid, &userRights, &nRights);
+
+  /*
+   * This error code means there is no any rights.
+   * In this case, we should create empty list.
+   */
+  
+  if (ntStat == STATUS_OBJECT_NAME_NOT_FOUND)
+  {
+    nRights = 0;
+    ntStat  = 0;
+  }
+  
+  FAIL(ntStat);
+  
+  /*
+   * FIXME. Now if some privilege name is not recognized by
+   * LookupPrivilegeName() part of pPrivToken buffer will be
+   * unused.
+   */
+   
+  /*
+   * Allocate buffer for TOKEN_PRIVILEGES.
+   */
+  
+  debug("Allocating buffer for TOKEN_PRIVILEGES [%u]...", nRights);
+  
+  size = sizeof(DWORD) + nRights * sizeof(LUID_AND_ATTRIBUTES);
+  
+  (*pPrivToken) = LocalAlloc(LPTR, size);
+  
+  FAIL(pPrivToken == NULL);
+  
+  /*
+   * Fill TOKEN_PRIVILEGES with LUIDs of retrieved privileges.
+   */
+  
+  j = 0;
+  
+  for (i = 0; i < nRights; i++)
+  {
+    /*
+     * Retrieve unicode name of privilege.
+     * Make sure there is a zero word at the end.
+     */
+    
+    wchar_t privName[128];
+    
+    int len = userRights[i].Length;
+    
+    memcpy(privName, userRights[i].Buffer, len * sizeof(wchar_t));
+    
+    privName[len] = 0;
+    
+    debug("Adding %ls... ", privName);
+
+    /*
+     * Retrieve LUID for given privilege name.
+     */
+    
+    if(LookupPrivilegeValueW(NULL, privName,
+                                   &(*pPrivToken) -> Privileges[i].Luid) == FALSE)
+    {
+      debug("WARNING. Cannot add privilege to token (%u).", GetLastError());
+    }
+    else
+    {
+      (*pPrivToken) -> Privileges[j].Attributes = SE_PRIVILEGE_ENABLED;
+
+      j++;
+    }  
+  }
+  
+  /*
+   * j = number of privileges, which were recognized by
+   * LookupPrivilegesValue().
+   */
+  
+  (*pPrivToken) -> PrivilegeCount = j;
+  
+  exitCode = 0;
+
+fail:
+
+  /*
+   * Clenup.
+   */
+  
+  if (userRights)
+  {
+    LsaFreeMemory(userRights);
+  }
+  
+  if (hPolicy)
+  {
+    CloseHandle(hPolicy);
+  }  
+  
+  if (exitCode)
+  {
+    debug("ERROR. Cannot setup TOKEN_PRIVILEGES (err=%u, ntStat=%x).",
+              GetLastError(), ntStat);
+  }
+}
+
+
+/*
+ * Allocate new TOKEN_GROUPS structure and fill it with groups, which
+ * given user belong to.
+ *
+ * pGroupsToken - new, allocated TOKEN_GROUPS structure (OUT)
+ * userNameW    - wide string with username (IN)
+ *
+ * RETURNS: 0 if OK.
+ */
+
+int SetupTokenGroups(PTOKEN_GROUPS *groupsToken, wchar_t *userNameW)
+{
+  wchar_t **localGroups  = NULL;
+  wchar_t **globalGroups = NULL;
+  
+  DWORD nLocalGroups     = 0;
+  DWORD nLocalGroupsTot  = 0;
+  
+  DWORD nGlobalGroups    = 0;
+  DWORD nGlobalGroupsTot = 0;
+  
+  DWORD nGroupsTotal     = 0;
+  
+  DWORD size;
+  
+  int i;
+  
+  int exitCode = 1;
+
+  /*
+   * Retrieve local groups, which user belong to.
+   */
+  
+  debug("Retrieving local groups list...");
+  
+  FAIL(NetUserGetLocalGroups(NULL, userNameW, 0, 
+                                LG_INCLUDE_INDIRECT, 
+                                    (LPBYTE *) &localGroups,
+                                         MAX_PREFERRED_LENGTH,
+                                             &nLocalGroups, 
+                                                 &nLocalGroupsTot));
+
+  debug("Retrieving global groups list...");
+  
+  /*
+   * Retrieve global groups, which user belong to.
+   */
+
+  FAIL(NetUserGetGroups(NULL, userNameW, 0, (LPBYTE *) 
+                            &globalGroups, MAX_PREFERRED_LENGTH, 
+                                &nGlobalGroups, &nGlobalGroupsTot));
+  
+
+  /*
+   * Allocate buffer for TOKEN_GROUPS struct.
+   *
+   * We assume user belong to Everyone, AuthenticatedUsers, Local, Interactive
+   * and groups retrievied from NetUserGetLocalGroups() and NetUserGetGroups()
+   * for given user.
+   */
+  
+  nGroupsTotal = nLocalGroups + nGlobalGroups + 4;
+
+  size = (nGroupsTotal + 1) * sizeof(SID_AND_ATTRIBUTES) + sizeof(DWORD);
+  
+  *groupsToken = (TOKEN_GROUPS *) LocalAlloc(LPTR, size);
+  
+  (*groupsToken) -> GroupCount = nGroupsTotal;
+
+  /*
+   * Write SIDs of local groups into TOKEN_GROUPS struct.
+   */
+  
+  #define INSIDE_GROUP_FLAG SE_GROUP_ENABLED\
+                            | SE_GROUP_ENABLED_BY_DEFAULT\
+                            | SE_GROUP_MANDATORY
+
+  int delta = 4;
+
+  for (i = 0; i < nLocalGroups; i++)
+  {
+    FAIL(GetSidW(&(*groupsToken) -> Groups[i + delta].Sid, localGroups[i]));
+
+    (*groupsToken) -> Groups[i + delta].Attributes = INSIDE_GROUP_FLAG;
+  }
+  
+  /*
+   * Write SIDs of global groups into TOKEN_GROUPS struct.
+   */
+
+  delta = 4 + nLocalGroups;
+
+  for (i = 0; i < nGlobalGroups; i++)
+  {
+    FAIL(GetSidW(&(*groupsToken) -> Groups[delta + i].Sid, globalGroups[i]));
+
+    (*groupsToken) -> Groups[delta + i].Attributes = INSIDE_GROUP_FLAG;
+  }
+  
+  /*
+   * Write SIDs of Everyone, AuthenticatedUsers, Local and Interactive
+   * groups into TOKEN_GROUPS struct.
+   */
+  
+  (*groupsToken) -> Groups[0].Sid = EveryoneSID();
+  (*groupsToken) -> Groups[0].Attributes = INSIDE_GROUP_FLAG;
+  
+  (*groupsToken) -> Groups[1].Sid = AuthenticatedUsersSID();
+  (*groupsToken) -> Groups[1].Attributes = INSIDE_GROUP_FLAG;
+  
+  (*groupsToken) -> Groups[2].Sid = LocalSID();
+  (*groupsToken) -> Groups[2].Attributes = INSIDE_GROUP_FLAG;
+  
+  (*groupsToken) -> Groups[3].Sid = InteractiveSID();
+  (*groupsToken) -> Groups[3].Attributes = INSIDE_GROUP_FLAG;
+
+  exitCode = 0;
+
+fail:
+
+  /*
+   * Clean up.
+   */
+  
+  NetApiBufferFree(localGroups);
+  NetApiBufferFree(globalGroups);
+
+  if (exitCode)
+  {
+    debug("ERROR. Failed to setup TOKEN_GROUPS (%u).", GetLastError());
+  }
+  
+  return exitCode;
+}
+
+#ifdef NX_USE_NTCREATETOKEN
+
+/*
+ * Creates new user's access token using NtCreateToken() function.
+ *
+ * userName   - user name string (IN)
+ * domainName - domain name (IN) (UNUSED)
+ * sourceName - ?? (IN)
+ *
+ * RETURNS: Handle to created token or INVALID_HANDLE_VALUE if fails.
+ */
+
+HANDLE CreateUserToken(const char *userName, 
+                           const char *domainName, const char *sourceName)
+{
+  debug2("-> CreateUserToken()...");
+  
+  HMODULE hNtDll = NULL;
+  
+  NtCreateTokenPtr NtCreateToken = NULL;
+  
+  HANDLE token = INVALID_HANDLE_VALUE;
+  
+  /*
+   * These are compounds of user's access token structure.
+   * The goal is setup these strutures and combine them
+   * into one access token using NtCreateToken() WINAPI function.
+   */
+  
+  LUID authId = SYSTEM_LUID;
+  
+  TOKEN_USER userToken;
+
+  PTOKEN_GROUPS groupsToken = NULL;
+  
+  PTOKEN_PRIVILEGES pPrivToken = NULL;
+  
+  TOKEN_OWNER ownerToken;
+  
+  TOKEN_PRIMARY_GROUP primaryGroupToken;
+
+  TOKEN_SOURCE sourceToken;  
+  
+  PTOKEN_DEFAULT_DACL pDaclToken = NULL;
+  
+  LARGE_INTEGER expirationTime = {0xFFFFFFFF, 0x7FFFFFFF};
+  
+  OBJECT_ATTRIBUTES oa;
+  
+  /*
+   * Temporary variables
+   */
+  
+  SECURITY_QUALITY_OF_SERVICE sqos = 
+  {
+    sizeof(sqos), 
+    SecurityAnonymous, 
+    SECURITY_STATIC_TRACKING,
+    FALSE
+  };
+    
+  int i;
+  
+  size_t size = 0;
+  
+  wchar_t *userNameW = NULL;
+  
+  DWORD cbSize;
+  
+  HANDLE hProcToken = NULL;
+  
+  /*
+   * Variables to handle error codes.
+   */
+  
+  int exitCode = 1;
+  int ntStat   = 0;
+  
+  /*
+   * Make wide char version of user's name.
+   */
+  
+  size = (strlen(userName) + 1) * sizeof(wchar_t);
+  
+  userNameW = (wchar_t *) LocalAlloc(LPTR, size);;
+
+  swprintf(userNameW, L"%hs", userName);
+  
+  /*
+   * Give needed privilege to current running process
+   */
+  
+  debug("Enabling privilege to current running process...");
+
+  EnablePrivilege("SeTcbPrivilege", 1);
+  EnablePrivilege("SeChangeNotifyPrivilege", 1);
+  EnablePrivilege("SeIncreaseQuotaPrivilege", 1);
+  EnablePrivilege("SeAssignPrimaryTokenPrivilege", 1);
+  EnablePrivilege("SeCreateTokenPrivilege", 1);
+  
+  /*
+   * Create TOKEN_USER part
+   */
+      
+  debug("Setting up TOKEN_USER...");
+  
+  FAIL(GetSidW(&userToken.User.Sid, userNameW));
+
+  userToken.User.Attributes = 0;
+  
+  /*
+   * Create TOKEN_OWNER part. We assume Owner = User.
+   */
+  
+  debug("Setting up TOKEN_OWNER...");
+  
+  FAIL(GetSidW(&ownerToken.Owner, userNameW));
+  
+  /*
+   * Create TOKEN_SOURCE part
+   */
+  
+  debug("Setting up TOKEN_SOURCE...");
+  
+  FAIL(AllocateLocallyUniqueId(&sourceToken.SourceIdentifier) == FALSE);
+  
+  size = min(strlen(sourceName), 8);
+      
+  memcpy(sourceToken.SourceName, "********", 8);
+  memcpy(sourceToken.SourceName, sourceName, size);
+
+  /*
+   * Create TOKEN_GROUPS part
+   */
+  
+  debug("Setting up TOKEN_GROUPS...");
+  
+  FAIL(SetupTokenGroups(&groupsToken, userNameW));
+  
+  /*
+   * Create TOKEN_PRIVILEGES part
+   */
+  
+  debug("Setting up TOKEN_PRIVILEGES...");
+  
+  FAIL(SetupTokenPrivileges(&pPrivToken, userToken.User.Sid));
+  
+  /*
+   * Create TOKEN_PRIMARY_GROUP part
+   */
+  
+  debug("Setting up TOKEN_PRIMARY GROUP...");
+  
+  primaryGroupToken.PrimaryGroup = EveryoneSID();
+  
+  /*
+   * Setup object attributes
+   */
+  
+  memset(&oa, 0, sizeof(oa));
+
+  oa.Length = sizeof(oa);
+  
+  oa.SecurityQualityOfService = &sqos;
+
+  /*
+   * Setup TOKEN_DEFAULT_DACL part.
+   */
+  
+  debug("Setting up TOKEN_DEFAULT_DACL...");
+  
+  debug("Opening current process's token...");
+
+  FAIL(OpenProcessToken(GetCurrentProcess(),
+                            TOKEN_QUERY | TOKEN_QUERY_SOURCE, 
+                                &hProcToken) == FALSE);
+
+  debug("Retrieving TOKEN_DEFAULT_DACL...");
+
+  GetTokenInformation(hProcToken, TokenDefaultDacl, NULL, 0, &cbSize);
+  
+  pDaclToken = LocalAlloc(LPTR, cbSize);
+
+  FAIL(GetTokenInformation(hProcToken, TokenDefaultDacl,
+                               pDaclToken, cbSize, &cbSize) == FALSE);
+
+  /*
+   * Print debug info about parts
+   */
+  
+  //PrintPartsInfo(&token, TOKEN_ALL_ACCESS, &oa, 
+  //                            TokenPrimary, &authId, &expirationTime,
+  //                                &userToken, groupsToken, pPrivToken,
+  //                                    &ownerToken, &primaryGroupToken, 
+  //                                        pDaclToken, &sourceToken);
+
+  /*
+   * Retrieve address of NtCreateToken() function.
+   */
+
+  debug("Retrieving NtCreateToken() address...");
+  
+  hNtDll = GetModuleHandle("ntdll.dll");
+  
+  FAIL(hNtDll == NULL);
+
+  NtCreateToken = (NtCreateTokenPtr) GetProcAddress(hNtDll, "NtCreateToken");
+
+  FAIL(NtCreateToken == NULL);
+
+  /*
+   * Create new user acces token from parts setted up above.
+   */
+
+  debug("Creating token from parts...");
+  
+  ntStat = NtCreateToken(&token, TOKEN_ALL_ACCESS, &oa,
+                              TokenPrimary, &authId, &expirationTime,
+                                  &userToken, groupsToken, pPrivToken,
+                                      &ownerToken, &primaryGroupToken,
+                                          pDaclToken, &sourceToken);                         
+  FAIL(ntStat);
+
+  /*
+   * Add rights to use 'default' desktop and WinStation0.
+   */
+
+  if (AddRightsToDesktopBySid(userToken.User.Sid))
+  {
+    debug("WARNING. Cannot add rights to 'winsta0\\default'!");
+  }
+
+  exitCode = 0;
+  
+fail:
+
+  /*
+   * Free allocated memory
+   */
+  
+  debug2("Freeing groupsToken...");
+  
+  if (groupsToken)
+  {
+    /*
+     * We don't need to test were SIDs allocated correctly,
+     * becouse FreeSid() do it.
+     */
+    
+    for (i = 0; i < groupsToken -> GroupCount; i++)
+    {
+      FreeSid(groupsToken -> Groups[i].Sid);
+    }
+
+    LocalFree(groupsToken);
+  }
+  
+  debug2("Freeing local buffers...");
+  
+  LocalFree(userNameW);
+  LocalFree(pDaclToken);
+  LocalFree(pPrivToken);
+  
+  debug2("Freeing SIDs...");
+  
+  FreeSid(userToken.User.Sid);
+  FreeSid(ownerToken.Owner);
+  FreeSid(primaryGroupToken.PrimaryGroup);
+  
+  debug2("Closing hProcToken...");
+  
+  CloseHandle(hProcToken);
+
+  debug2("Closing hNtDll...");
+  
+  CloseHandle(hNtDll);
+  
+  /*
+   * Something was wrong.
+   */
+  
+  if (exitCode)
+  {
+    debug("ERROR. Cannot create user's acces token. (err = %u, ntStat = %x)",
+              GetLastError(), ntStat);
+  }
+
+  debug2("<- CreateUserToken()...");
+  
+  return token;
+}
+
+#endif
diff --git a/contrib/win32/win32compat/win32auth.h b/contrib/win32/win32compat/win32auth.h
new file mode 100644
index 0000000..17d1d2c
--- /dev/null
+++ b/contrib/win32/win32compat/win32auth.h
@@ -0,0 +1,98 @@
+/*
+ * Author: NoMachine <developers@nomachine.com>
+ *
+ * Copyright (c) 2009, 2011 NoMachine
+ * All rights reserved
+ *
+ * Support functions and system calls' replacements needed to let the
+ * software run on Win32 based operating systems.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef WIN32AUTH_H
+#define WIN32AUTH_H 1
+
+#include <windows.h>
+#include <winnt.h>
+#include <Lmcons.h>
+#include <Lm.h>
+#include <stdlib.h>
+#include <ntsecapi.h>
+#include <AccCtrl.h>
+#include <Aclapi.h>
+#include <ddk/ntstatus.h>
+#include "Debug.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef _MSC_VER
+typedef struct _OBJECT_ATTRIBUTES
+{
+  ULONG Length;
+
+  HANDLE RootDirectory;
+ 
+  PUNICODE_STRING ObjectName;
+ 
+  ULONG Attributes;
+
+  PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
+   
+  PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
+}
+OBJECT_ATTRIBUTES;
+
+typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;
+#endif
+
+#ifndef NYSYSAPI
+#define NTSYSAPI DECLSPEC_IMPORT
+#endif
+
+//
+// Prototype for undocumented NtCreateToken() function from 'ntdll.dll'
+//
+
+typedef NTSYSAPI NTSTATUS
+    (NTAPI *NtCreateTokenPtr) (PHANDLE, ACCESS_MASK,
+                                   POBJECT_ATTRIBUTES,
+                                       TOKEN_TYPE, PLUID, PLARGE_INTEGER, 
+                                           PTOKEN_USER, PTOKEN_GROUPS, 
+                                               PTOKEN_PRIVILEGES, PTOKEN_OWNER,
+                                                   PTOKEN_PRIMARY_GROUP, 
+                                                       PTOKEN_DEFAULT_DACL,
+                                                           PTOKEN_SOURCE);
+
+
+HANDLE CreateUserToken(const char *pUserName,
+                           const char *pDomainName, const char *pSourceName);
+
+int EnablePrivilege(const char *privName, int enabled);
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif /* WIN32AUTH_H */
diff --git a/contrib/win32/win32compat/win32compat.vcproj b/contrib/win32/win32compat/win32compat.vcproj
new file mode 100644
index 0000000..978d99a
--- /dev/null
+++ b/contrib/win32/win32compat/win32compat.vcproj
@@ -0,0 +1,311 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8.00"
+	Name="win32compat"
+	ProjectGUID="{8660C2FE-9874-432D-B047-E042BB41DBE0}"
+	RootNamespace="win32compat"
+	Keyword="Win32Proj"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..;..\..\..;.\includes;..\..\..\..\openssl-0.9.8e\build\include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="2"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="..;..\..\..;.\includes;..\..\..\..\openssl-0.9.8e\build\include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath=".\daemon.c"
+				>
+			</File>
+			<File
+				RelativePath=".\gettimeofday.c"
+				>
+			</File>
+			<File
+				RelativePath=".\isatty.c"
+				>
+			</File>
+			<File
+				RelativePath=".\pwd.c"
+				>
+			</File>
+			<File
+				RelativePath=".\startupneeds.c"
+				>
+			</File>
+			<File
+				RelativePath=".\strcasecmp.c"
+				>
+			</File>
+			<File
+				RelativePath=".\syslog.c"
+				>
+			</File>
+			<File
+				RelativePath=".\winsockhelp.c"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath=".\includes\grp.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\netinet\in.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\netinet\in_systm.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\arpa\inet.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\sys\ioctl.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\netinet\ip.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\arpa\nameser.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\netdb.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\sys\param.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\pwd.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\resolv.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\sys\resource.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\sys\select.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\sys\socket.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\syslog.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\netinet\tcp.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\termios.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\sys\time.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\sys\types.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\sys\uio.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\sys\un.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\unistd.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\sys\wait.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+		</Filter>
+		<File
+			RelativePath=".\Makefile.in"
+			>
+			<FileConfiguration
+				Name="Debug|Win32"
+				ExcludedFromBuild="true"
+				>
+				<Tool
+					Name="VCCustomBuildTool"
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Release|Win32"
+				ExcludedFromBuild="true"
+				>
+				<Tool
+					Name="VCCustomBuildTool"
+				/>
+			</FileConfiguration>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff --git a/defines.h b/defines.h
index e4ccc54..33b18e5 100644
--- a/defines.h
+++ b/defines.h
@@ -27,7 +27,6 @@
 
 /* $Id: defines.h,v 1.167 2011/06/03 01:17:49 tim Exp $ */
 
-
 /* Constants */
 
 #if defined(HAVE_DECL_SHUT_RD) && HAVE_DECL_SHUT_RD == 0
@@ -808,4 +807,9 @@ struct winsize {
 # endif
 #endif
 
+/* NX_WIN32_FIXME */
+#ifdef _WIN32
+# define CUSTOM_SYS_AUTH_PASSWD 1
+#endif
+
 #endif /* _DEFINES_H */
diff --git a/dns.c b/dns.c
index 131cb3d..21ae9ff 100644
--- a/dns.c
+++ b/dns.c
@@ -175,6 +175,7 @@ int
 verify_host_key_dns(const char *hostname, struct sockaddr *address,
     Key *hostkey, int *flags)
 {
+#ifndef NX_WIN32_FIXME
 	u_int counter;
 	int result;
 	struct rrsetinfo *fingerprints = NULL;
@@ -266,6 +267,9 @@ verify_host_key_dns(const char *hostname, struct sockaddr *address,
 		debug("no host key fingerprint found in DNS");
 
 	return 0;
+#else
+	return 0;
+#endif /* else !NX_WIN32_FIXME */
 }
 
 /*
diff --git a/groupaccess.c b/groupaccess.c
index 2381aeb..9609326 100644
--- a/groupaccess.c
+++ b/groupaccess.c
@@ -48,6 +48,7 @@ static char **groups_byname;
 int
 ga_init(const char *user, gid_t base)
 {
+#ifndef NX_WIN32_FIXME
 	gid_t *groups_bygid;
 	int i, j;
 	struct group *gr;
@@ -70,6 +71,9 @@ ga_init(const char *user, gid_t base)
 			groups_byname[j++] = xstrdup(gr->gr_name);
 	xfree(groups_bygid);
 	return (ngroups = j);
+#else
+	return -1;
+#endif /* else !NX_WIN32_FIXME */
 }
 
 /*
diff --git a/gss-serv-krb5.c b/gss-serv-krb5.c
index 5a625ac..1d990c7 100644
--- a/gss-serv-krb5.c
+++ b/gss-serv-krb5.c
@@ -26,6 +26,15 @@
 
 #include "includes.h"
 
+/*
+ * We support only client side kerberos on Windows.
+ */
+
+#ifdef NX_WIN32_FIXME
+  #undef GSSAPI
+  #undef KRB5
+#endif
+
 #ifdef GSSAPI
 #ifdef KRB5
 
diff --git a/gss-serv.c b/gss-serv.c
index c719c13..629dc7e 100644
--- a/gss-serv.c
+++ b/gss-serv.c
@@ -26,6 +26,15 @@
 
 #include "includes.h"
 
+/*
+ * We support only client side kerberos on Windows.
+ */
+
+#ifdef NX_WIN32_FIXME
+  #undef GSSAPI
+  #undef KRB5
+#endif
+
 #ifdef GSSAPI
 
 #include <sys/types.h>
diff --git a/includes.h b/includes.h
index b4c53d9..58a14ac 100644
--- a/includes.h
+++ b/includes.h
@@ -172,4 +172,12 @@
 
 #include "entropy.h"
 
+#ifdef NX_WIN32_FIXME
+
+  #define signal(X, Y)
+  #define alarm(X)
+  #define mysignal(X, Y)
+  
+#endif
+
 #endif /* INCLUDES_H */
diff --git a/kexdhs.c b/kexdhs.c
index f56e887..50301c2 100644
--- a/kexdhs.c
+++ b/kexdhs.c
@@ -25,6 +25,15 @@
 
 #include "includes.h"
 
+/*
+ * We support only client side kerberos on Windows.
+ */
+
+#ifdef NX_WIN32_FIXME
+  #undef GSSAPI
+  #undef KRB5
+#endif
+
 #include <sys/types.h>
 
 #include <stdarg.h>
diff --git a/kexgex.c b/kexgex.c
index b60ab5c..2e7599a 100644
--- a/kexgex.c
+++ b/kexgex.c
@@ -26,6 +26,15 @@
 
 #include "includes.h"
 
+/*
+ * We support only client side kerberos on Windows.
+ */
+
+#ifdef NX_WIN32_FIXME
+  #undef GSSAPI
+  #undef KRB5
+#endif
+
 #include <sys/types.h>
 
 #include <openssl/evp.h>
diff --git a/kexgexs.c b/kexgexs.c
index a5e3df7..fa71738 100644
--- a/kexgexs.c
+++ b/kexgexs.c
@@ -26,6 +26,15 @@
 
 #include "includes.h"
 
+/*
+ * We support only client side kerberos on Windows.
+ */
+
+#ifdef NX_WIN32_FIXME
+  #undef GSSAPI
+  #undef KRB5
+#endif
+
 #include <sys/param.h>
 
 #include <stdarg.h>
diff --git a/key.c b/key.c
index 498cf5a..add0d6e 100644
--- a/key.c
+++ b/key.c
@@ -40,7 +40,12 @@
 #include <sys/types.h>
 
 #include <openssl/evp.h>
+
+#ifndef NX_WIN32_FIXME
 #include <openbsd-compat/openssl-compat.h>
+#else
+#include "openbsd-compat/openssl-compat.h"
+#endif
 
 #include <stdarg.h>
 #include <stdio.h>
diff --git a/log.c b/log.c
index ad5a10b..f57d2ee 100644
--- a/log.c
+++ b/log.c
@@ -52,6 +52,17 @@
 #include "xmalloc.h"
 #include "log.h"
 
+#ifdef NX_WIN32_FIXME
+
+  #include <fcntl.h>
+  #include <Shlwapi.h>
+  
+  int logfd = 0;
+
+  #undef NX_DEBUG
+
+#endif
+
 static LogLevel log_level = SYSLOG_LEVEL_INFO;
 static int log_on_stderr = 1;
 static int log_facility = LOG_AUTH;
@@ -406,16 +417,44 @@ do_log(LogLevel level, const char *fmt, va_list args)
 	}
 	strnvis(fmtbuf, msgbuf, sizeof(fmtbuf),
 	    log_on_stderr ? LOG_STDERR_VIS : LOG_SYSLOG_VIS);
+
+#ifndef NX_WIN32_FIXME
 	if (log_handler != NULL) {
 		/* Avoid recursion */
 		tmp_handler = log_handler;
 		log_handler = NULL;
 		tmp_handler(level, fmtbuf, log_handler_ctx);
 		log_handler = tmp_handler;
-	} else if (log_on_stderr) {
+	} else
+#endif
+    if (log_on_stderr) {
 		snprintf(msgbuf, sizeof msgbuf, "%s\r\n", fmtbuf);
+    #ifdef NX_WIN32_FIXME
+    _write(STDERR_FILENO, msgbuf, strlen(msgbuf));
+    #else  
 		write(STDERR_FILENO, msgbuf, strlen(msgbuf));
+    #endif
 	} else {
+
+  #ifdef NX_WIN32_FIXME
+    
+    if (logfd > 0)
+    {
+      char msgbufTimestamp[MSGBUFSIZ];
+      
+      SYSTEMTIME st;
+      
+      GetLocalTime(&st);
+
+      snprintf(msgbufTimestamp, sizeof msgbufTimestamp, "%d %02d:%02d:%02d %03d %s\n",
+                   GetCurrentProcessId(), st.wHour, st.wMinute, st.wSecond, 
+                       st.wMilliseconds, msgbuf);
+      
+      _write(logfd, msgbufTimestamp, strlen(msgbufTimestamp));
+    }
+ 
+  #else 
+  
 #if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)
 		openlog_r(argv0 ? argv0 : __progname, LOG_PID, log_facility, &sdata);
 		syslog_r(pri, &sdata, "%.500s", fmtbuf);
@@ -425,6 +464,8 @@ do_log(LogLevel level, const char *fmt, va_list args)
 		syslog(pri, "%.500s", fmtbuf);
 		closelog();
 #endif
+
+  #endif
 	}
 	errno = saved_errno;
 }
diff --git a/misc.c b/misc.c
index 5f63090..00ac5d6 100644
--- a/misc.c
+++ b/misc.c
@@ -79,6 +79,16 @@ chop(char *s)
 int
 set_nonblock(int fd)
 {
+#ifdef NX_WIN32_FIXME
+  
+  int on = 1;
+  
+  ioctlsocket(fd, FIONBIO, &on);
+  
+  return 0;
+
+#else
+
 	int val;
 
 	val = fcntl(fd, F_GETFL, 0);
@@ -98,11 +108,22 @@ set_nonblock(int fd)
 		return (-1);
 	}
 	return (0);
+#endif /* else NX_WIN32_FIXME */
 }
 
 int
 unset_nonblock(int fd)
 {
+#ifdef NX_WIN32_FIXME
+  
+  int on = 0;
+  
+  ioctlsocket(fd, FIONBIO, &on);
+  
+  return 0;
+  
+#else
+
 	int val;
 
 	val = fcntl(fd, F_GETFL, 0);
@@ -122,6 +143,7 @@ unset_nonblock(int fd)
 		return (-1);
 	}
 	return (0);
+#endif
 }
 
 const char *
@@ -715,6 +737,7 @@ tun_open(int tun, int mode)
 void
 sanitise_stdfd(void)
 {
+#ifndef NX_WIN32_FIXME
 	int nullfd, dupfd;
 
 	if ((nullfd = dupfd = open(_PATH_DEVNULL, O_RDWR)) == -1) {
@@ -733,6 +756,7 @@ sanitise_stdfd(void)
 	}
 	if (nullfd > 2)
 		close(nullfd);
+#endif
 }
 
 char *
@@ -868,6 +892,7 @@ bandwidth_limit_init(struct bwlimit *bw, u_int64_t kbps, size_t buflen)
 void
 bandwidth_limit(struct bwlimit *bw, size_t read_len)
 {
+#ifndef NX_WIN32_FIXME
 	u_int64_t waitlen;
 	struct timespec ts, rm;
 
@@ -915,6 +940,7 @@ bandwidth_limit(struct bwlimit *bw, size_t read_len)
 
 	bw->lamt = 0;
 	gettimeofday(&bw->bwstart, NULL);
+#endif
 }
 
 /* Make a template filename for mk[sd]temp() */
diff --git a/monitor.c b/monitor.c
index a166fed..9bb69f3 100644
--- a/monitor.c
+++ b/monitor.c
@@ -27,6 +27,15 @@
 
 #include "includes.h"
 
+/*
+ * We support only client side kerberos on Windows.
+ */
+
+#ifdef NX_WIN32_FIXME
+  #undef GSSAPI
+  #undef KRB5
+#endif
+
 #include <sys/types.h>
 #include <sys/param.h>
 #include <sys/socket.h>
@@ -447,7 +456,9 @@ monitor_set_child_handler(pid_t pid)
 static void
 monitor_child_handler(int sig)
 {
+#ifndef NX_WIN32_FIXME
 	kill(monitor_child_pid, sig);
+#endif
 }
 
 void
@@ -1665,6 +1676,7 @@ mm_answer_rsa_response(int sock, Buffer *m)
 int
 mm_answer_term(int sock, Buffer *req)
 {
+#ifndef NX_WIN32_FIXME
 	extern struct monitor *pmonitor;
 	int res, status;
 
@@ -1686,8 +1698,12 @@ mm_answer_term(int sock, Buffer *req)
 
 	/* Terminate process */
 	exit(res);
+#else
+	exit(1);
+#endif
 }
 
+
 #ifdef SSH_AUDIT_EVENTS
 /* Report that an audit event occurred */
 int
@@ -1951,6 +1967,7 @@ mm_init_compression(struct mm_master *mm)
 static void
 monitor_openfds(struct monitor *mon, int do_logfds)
 {
+#ifndef NX_WIN32_FIXME
 	int pair[2];
 
 	if (socketpair(AF_UNIX, SOCK_STREAM, 0, pair) == -1)
@@ -1969,6 +1986,11 @@ monitor_openfds(struct monitor *mon, int do_logfds)
 		mon->m_log_sendfd = pair[1];
 	} else
 		mon->m_log_recvfd = mon->m_log_sendfd = -1;
+#else
+
+  fatal("monitor_openfds() not implemented on Win32.");
+  
+#endif
 }
 
 #define MM_MEMSIZE	65536
diff --git a/monitor_wrap.c b/monitor_wrap.c
index 1f60658..15bab4f 100644
--- a/monitor_wrap.c
+++ b/monitor_wrap.c
@@ -27,6 +27,15 @@
 
 #include "includes.h"
 
+/*
+ * We support only client side kerberos on Windows.
+ */
+
+#ifdef NX_WIN32_FIXME
+  #undef GSSAPI
+  #undef KRB5
+#endif
+
 #include <sys/types.h>
 #include <sys/uio.h>
 
diff --git a/mux.c b/mux.c
index add0e26..78056f5 100644
--- a/mux.c
+++ b/mux.c
@@ -305,6 +305,7 @@ process_mux_master_hello(u_int rid, Channel *c, Buffer *m, Buffer *r)
 static int
 process_mux_new_session(u_int rid, Channel *c, Buffer *m, Buffer *r)
 {
+#ifndef NX_WIN32_FIXME
 	Channel *nc;
 	struct mux_session_confirm_ctx *cctx;
 	char *reserved, *cmd, *cp;
@@ -473,11 +474,21 @@ process_mux_new_session(u_int rid, Channel *c, Buffer *m, Buffer *r)
 
 	/* reply is deferred, sent by mux_session_confirm */
 	return 0;
+#else
+
+  /*
+   * Not implemented on Win32.
+   */
+
+  return -1;
+  
+#endif
 }
 
 static int
 process_mux_alive_check(u_int rid, Channel *c, Buffer *m, Buffer *r)
 {
+#ifndef NX_WIN32_FIXME
 	debug2("%s: channel %d: alive check", __func__, c->self);
 
 	/* prepare reply */
@@ -486,11 +497,17 @@ process_mux_alive_check(u_int rid, Channel *c, Buffer *m, Buffer *r)
 	buffer_put_int(r, (u_int)getpid());
 
 	return 0;
+#else
+
+  return -1;
+
+#endif
 }
 
 static int
 process_mux_terminate(u_int rid, Channel *c, Buffer *m, Buffer *r)
 {
+#ifndef NX_WIN32_FIXME
 	debug2("%s: channel %d: terminate request", __func__, c->self);
 
 	if (options.control_master == SSHCTL_MASTER_ASK ||
@@ -510,6 +527,11 @@ process_mux_terminate(u_int rid, Channel *c, Buffer *m, Buffer *r)
 	buffer_put_int(r, rid);
 	/* XXX exit happens too soon - message never makes it to client */
 	return 0;
+#else
+
+  return -1; 
+
+#endif
 }
 
 static char *
@@ -1080,6 +1102,7 @@ mux_tty_alloc_failed(Channel *c)
 void
 muxserver_listen(void)
 {
+#ifndef NX_WIN32_FIXME
 	struct sockaddr_un addr;
 	socklen_t sun_len;
 	mode_t old_umask;
@@ -1173,6 +1196,7 @@ muxserver_listen(void)
 	mux_listener_channel->mux_rcb = mux_master_read_cb;
 	debug3("%s: mux listener channel %d fd %d", __func__,
 	    mux_listener_channel->self, mux_listener_channel->sock);
+#endif
 }
 
 /* Callback on open confirmation in mux master for a mux client session. */
@@ -1271,12 +1295,14 @@ control_client_sighandler(int signo)
 static void
 control_client_sigrelay(int signo)
 {
+#ifndef NX_WIN32_FIXME
 	int save_errno = errno;
 
 	if (muxserver_pid > 1)
 		kill(muxserver_pid, signo);
 
 	errno = save_errno;
+#endif
 }
 
 static int
@@ -1645,7 +1671,9 @@ mux_client_request_session(int fd)
 		return -1;
 	}
 
+#ifndef NX_WIN32_FIXME
 	signal(SIGPIPE, SIG_IGN);
+#endif
 
 	if (stdin_null_flag) {
 		if ((devnull = open(_PATH_DEVNULL, O_RDONLY)) == -1)
@@ -1727,10 +1755,12 @@ mux_client_request_session(int fd)
 	}
 	muxclient_request_id++;
 
+#ifndef NX_WIN32_FIXME
 	signal(SIGHUP, control_client_sighandler);
 	signal(SIGINT, control_client_sighandler);
 	signal(SIGTERM, control_client_sighandler);
 	signal(SIGWINCH, control_client_sigrelay);
+#endif
 
 	rawmode = tty_flag;
 	if (tty_flag)
@@ -1808,7 +1838,9 @@ mux_client_request_stdio_fwd(int fd)
 		return -1;
 	}
 
+#ifndef NX_WIN32_FIXME
 	signal(SIGPIPE, SIG_IGN);
+#endif
 
 	if (stdin_null_flag) {
 		if ((devnull = open(_PATH_DEVNULL, O_RDONLY)) == -1)
@@ -1871,10 +1903,12 @@ mux_client_request_stdio_fwd(int fd)
 	}
 	muxclient_request_id++;
 
+#ifndef NX_WIN32_FIXME
 	signal(SIGHUP, control_client_sighandler);
 	signal(SIGINT, control_client_sighandler);
 	signal(SIGTERM, control_client_sighandler);
 	signal(SIGWINCH, control_client_sigrelay);
+#endif
 
 	/*
 	 * Stick around until the controlee closes the client_fd.
diff --git a/nchan.c b/nchan.c
index 20f6a2f..beddcc5 100644
--- a/nchan.c
+++ b/nchan.c
@@ -74,6 +74,13 @@
 /*
  * ACTIONS: should never update the channel states
  */
+
+#ifdef NX_WIN32_FIXME      
+
+  void StopSocketThreads();
+
+#endif
+
 static void	chan_send_ieof1(Channel *);
 static void	chan_send_oclose1(Channel *);
 static void	chan_send_close2(Channel *);
@@ -114,6 +121,25 @@ static void
 chan_rcvd_oclose1(Channel *c)
 {
 	debug2("channel %d: rcvd oclose", c->self);
+
+  /*
+   * FIXME. This function forces stopping all socket threads 
+   * at next select. This workaround nivelate problem with
+   * infinite hangs up in below scenario:
+   * 
+   * a) read select start.
+   * b) write select start.
+   * c) read select ends: SSH2_MSG_CHANNEL_CLOSE received.
+   * d) close input channel.
+   * e) now write select may never ends.
+   */
+
+  #ifdef NX_WIN32_FIXME
+
+    StopSocketThreads();
+
+  #endif
+
 	switch (c->istate) {
 	case CHAN_INPUT_WAIT_OCLOSE:
 		chan_set_istate(c, CHAN_INPUT_CLOSED);
diff --git a/openbsd-compat/bsd-closefrom.c b/openbsd-compat/bsd-closefrom.c
index 9380b33..bae8c11 100644
--- a/openbsd-compat/bsd-closefrom.c
+++ b/openbsd-compat/bsd-closefrom.c
@@ -51,6 +51,10 @@
 # define OPEN_MAX	256
 #endif
 
+#ifdef NX_WIN32_FIXME
+#define getdtablesize() FD_SETSIZE
+#endif
+
 #if 0
 __unused static const char rcsid[] = "$Sudo: closefrom.c,v 1.11 2006/08/17 15:26:54 millert Exp $";
 #endif /* lint */
@@ -98,6 +102,7 @@ closefrom(int lowfd)
 #else
 	maxfd = getdtablesize();
 #endif /* HAVE_SYSCONF */
+
 	if (maxfd < 0)
 	    maxfd = OPEN_MAX;
 
diff --git a/openbsd-compat/bsd-misc.c b/openbsd-compat/bsd-misc.c
index 3ef373f..053a5e3 100644
--- a/openbsd-compat/bsd-misc.c
+++ b/openbsd-compat/bsd-misc.c
@@ -199,6 +199,7 @@ tcsendbreak(int fd, int duration)
 }
 #endif /* HAVE_TCSENDBREAK */
 
+#ifdef HAVE_SIGACTION /* NX */ /* Moved out of function definition */
 mysig_t
 mysignal(int sig, mysig_t act)
 {
@@ -225,6 +226,7 @@ mysignal(int sig, mysig_t act)
 	return (signal(sig, act));
 #endif
 }
+#endif
 
 #ifndef HAVE_STRDUP
 char *
diff --git a/openbsd-compat/bsd-misc.h b/openbsd-compat/bsd-misc.h
index e70c3f9..0891298 100644
--- a/openbsd-compat/bsd-misc.h
+++ b/openbsd-compat/bsd-misc.h
@@ -90,10 +90,12 @@ void unsetenv(const char *);
 #endif
 
 /* wrapper for signal interface */
+#ifdef HAVE_SIGACTION /* NX */
 typedef void (*mysig_t)(int);
 mysig_t mysignal(int sig, mysig_t act);
 
 #define signal(a,b) mysignal(a,b)
+#endif
 
 #ifndef HAVE_ISBLANK
 int	isblank(int);
diff --git a/openbsd-compat/bsd-waitpid.c b/openbsd-compat/bsd-waitpid.c
index 40e6ffa..95394f2 100644
--- a/openbsd-compat/bsd-waitpid.c
+++ b/openbsd-compat/bsd-waitpid.c
@@ -24,6 +24,8 @@
 
 #include "includes.h"
 
+#ifndef NX_WIN32_FIXME
+
 #ifndef HAVE_WAITPID 
 #include <errno.h>
 #include <sys/wait.h>
@@ -51,3 +53,5 @@ waitpid(int pid, int *stat_loc, int options)
 }
 
 #endif /* !HAVE_WAITPID */
+
+#endif /* NX_WIN32_FIXME */
diff --git a/openbsd-compat/getrrsetbyname.c b/openbsd-compat/getrrsetbyname.c
index 9887667..690af00 100644
--- a/openbsd-compat/getrrsetbyname.c
+++ b/openbsd-compat/getrrsetbyname.c
@@ -47,6 +47,8 @@
 
 #include "includes.h"
 
+#ifndef NX_WIN32_FIXME
+
 #ifndef HAVE_GETRRSETBYNAME
 
 #include <stdlib.h>
@@ -608,3 +610,5 @@ count_dns_rr(struct dns_rr *p, u_int16_t class, u_int16_t type)
 }
 
 #endif /* !defined(HAVE_GETRRSETBYNAME) */
+
+#endif /* !NX_WIN32_FIXME */
diff --git a/openbsd-compat/glob.c b/openbsd-compat/glob.c
index 0341225..11751aa 100644
--- a/openbsd-compat/glob.c
+++ b/openbsd-compat/glob.c
@@ -60,6 +60,8 @@
 
 #include "includes.h"
 
+#ifndef NX_WIN32_FIXME
+
 #include <sys/types.h>
 #include <sys/stat.h>
 
@@ -1012,3 +1014,5 @@ qprintf(const char *str, Char *s)
 
 #endif /* !defined(HAVE_GLOB) || !defined(GLOB_HAS_ALTDIRFUNC) ||
           !defined(GLOB_HAS_GL_MATCHC) || !defined(GLOB_HAS_GL_STATV) */
+
+#endif /* NX_WIN32_FIXME */
diff --git a/openbsd-compat/pwcache.c b/openbsd-compat/pwcache.c
index 5a8b788..06d0dbf 100644
--- a/openbsd-compat/pwcache.c
+++ b/openbsd-compat/pwcache.c
@@ -82,6 +82,7 @@ user_from_uid(uid_t uid, int nouser)
 char *
 group_from_gid(gid_t gid, int nogroup)
 {
+#ifndef NX_WIN32_FIXME
 	static struct ncache {
 		gid_t	gid;
 		char	*name;
@@ -110,5 +111,14 @@ group_from_gid(gid_t gid, int nogroup)
 		cp->name = strdup(gr ? gr->gr_name : nbuf);
 	}
 	return (cp->name);
+#else
+
+  /*
+   * Not implemented on Win32.
+   */
+   
+  return NULL;
+
+#endif
 }
 #endif
diff --git a/openbsd-compat/realpath.c b/openbsd-compat/realpath.c
index b6120d0..430ac8e 100644
--- a/openbsd-compat/realpath.c
+++ b/openbsd-compat/realpath.c
@@ -31,6 +31,8 @@
 
 #include "includes.h"
 
+#ifndef NX_WIN32_FIXME
+
 #if !defined(HAVE_REALPATH) || defined(BROKEN_REALPATH)
 
 #include <sys/param.h>
@@ -195,3 +197,38 @@ realpath(const char *path, char resolved[PATH_MAX])
 	return (resolved);
 }
 #endif /* !defined(HAVE_REALPATH) || defined(BROKEN_REALPATH) */
+
+#else
+
+char *realpathNx(const char *path, char resolved[PATH_MAX])
+{
+  size_t path_len;
+  unsigned int lastSlash;
+  char realpath[PATH_MAX];
+  char * pch;
+
+  path_len = strlcpy(realpath, path, sizeof(realpath));
+  pch = strrchr(realpath, '/');
+  lastSlash =  pch - realpath + 1;
+  if(path_len == lastSlash)
+  {
+    realpath[lastSlash-1] = '\0';
+  }	
+
+  pch = strrchr(realpath,'.');
+  if(pch != NULL)
+  {
+    if (realpath[pch-realpath - 1] == '.')
+    {
+      realpath[pch - realpath - 2] = '\0';	
+      pch = strrchr(realpath, '/');
+      if(pch != NULL)
+        realpath[pch - realpath] = '\0';
+    }
+  }
+
+  strncpy (resolved, realpath, sizeof(realpath));
+  return resolved;	
+}
+
+#endif /* NX_WIN32_FIXME */
diff --git a/packet.c b/packet.c
index ba93417..f5f76d3 100644
--- a/packet.c
+++ b/packet.c
@@ -1033,8 +1033,13 @@ packet_read_seqnr(u_int32_t *seqnr_p)
 
 	DBG(debug("packet_read()"));
 
+#ifndef NX_WIN32_FIXME
 	setp = (fd_set *)xcalloc(howmany(active_state->connection_in + 1,
 	    NFDBITS), sizeof(fd_mask));
+#else
+	setp = xmalloc(sizeof(fd_set));
+	FD_ZERO(setp);
+#endif
 
 	/* Since we are blocking, ensure that all written packets have been sent. */
 	packet_write_wait();
@@ -1058,8 +1063,12 @@ packet_read_seqnr(u_int32_t *seqnr_p)
 		 * Otherwise, wait for some data to arrive, add it to the
 		 * buffer, and try again.
 		 */
+#ifndef NX_WIN32_FIXME
 		memset(setp, 0, howmany(active_state->connection_in + 1,
 		    NFDBITS) * sizeof(fd_mask));
+#else
+		FD_ZERO(setp);
+#endif
 		FD_SET(active_state->connection_in, setp);
 
 		if (active_state->packet_timeout_ms > 0) {
@@ -1687,12 +1696,21 @@ packet_write_wait(void)
 	int ret, ms_remain;
 	struct timeval start, timeout, *timeoutp = NULL;
 
+#ifndef NX_WIN32_FIXME
 	setp = (fd_set *)xcalloc(howmany(active_state->connection_out + 1,
 	    NFDBITS), sizeof(fd_mask));
+#else
+	setp = (fd_set *)xmalloc(sizeof(fd_set));
+	FD_ZERO(setp);
+#endif
 	packet_write_poll();
 	while (packet_have_data_to_write()) {
+#ifndef NX_WIN32_FIXME
 		memset(setp, 0, howmany(active_state->connection_out + 1,
 		    NFDBITS) * sizeof(fd_mask));
+#else
+		FD_ZERO(setp);
+#endif
 		FD_SET(active_state->connection_out, setp);
 
 		if (active_state->packet_timeout_ms > 0) {
diff --git a/pathnames.h b/pathnames.h
index c3d9abf..542275c 100644
--- a/pathnames.h
+++ b/pathnames.h
@@ -34,6 +34,18 @@
  * Of these, ssh_host_key must be readable only by root, whereas ssh_config
  * should be world-readable.
  */
+#ifdef NX_WIN32_FIXME
+# define _PATH_SERVER_CONFIG_FILE  "sshd_config"
+# define _PATH_HOST_CONFIG_FILE    "ssh_config"
+# define _PATH_HOST_KEY_FILE       "ssh_host_key"
+# define _PATH_HOST_DSA_KEY_FILE   "ssh_host_dsa_key"
+# define _PATH_HOST_ECDSA_KEY_FILE "ssh_host_ecdsa_key"
+# define _PATH_HOST_RSA_KEY_FILE   "ssh_host_rsa_key"
+# define _PATH_DH_MODULI           "/moduli"
+# define _PATH_DH_PRIMES           "/primes"
+# define _PATH_SSH_PROGRAM         "nxssh.exe"
+
+#else
 #define _PATH_SERVER_CONFIG_FILE	SSHDIR "/sshd_config"
 #define _PATH_HOST_CONFIG_FILE		SSHDIR "/ssh_config"
 #define _PATH_HOST_KEY_FILE		SSHDIR "/ssh_host_key"
@@ -43,16 +55,20 @@
 #define _PATH_DH_MODULI			SSHDIR "/moduli"
 /* Backwards compatibility */
 #define _PATH_DH_PRIMES			SSHDIR "/primes"
-
 #ifndef _PATH_SSH_PROGRAM
 #define _PATH_SSH_PROGRAM		"/usr/bin/ssh"
 #endif
+#endif
 
 /*
  * The process id of the daemon listening for connections is saved here to
  * make it easier to kill the correct daemon when necessary.
  */
+#ifndef NX_WIN32_FIXME
 #define _PATH_SSH_DAEMON_PID_FILE	_PATH_SSH_PIDDIR "/sshd.pid"
+#else
+#define _PATH_SSH_DAEMON_PID_FILE "sshd.pid"
+#endif
 
 /*
  * The directory in user's home directory in which the files reside. The
@@ -134,8 +150,12 @@
 
 /* xauth for X11 forwarding */
 #ifndef _PATH_XAUTH
+#ifdef NX_WIN32_FIXME
+#define _PATH_XAUTH			"./nxauth.exe"
+#else
 #define _PATH_XAUTH			"/usr/X11R6/bin/xauth"
 #endif
+#endif
 
 /* UNIX domain socket for X11 server; displaynum will replace %u */
 #ifndef _PATH_UNIX_X
@@ -148,9 +168,15 @@
 #endif
 
 /* for sftp */
+#ifdef NX_WIN32_FIXME
+  #ifndef _PATH_SFTP_SERVER
+  #define _PATH_SFTP_SERVER "./nxsftp-server.exe"
+  #endif
+#else
 #ifndef _PATH_SFTP_SERVER
 #define _PATH_SFTP_SERVER		"/usr/libexec/sftp-server"
 #endif
+#endif /* else NX_WIN32_FIXME */
 
 /* chroot directory for unprivileged user when UsePrivilegeSeparation=yes */
 #ifndef _PATH_PRIVSEP_CHROOT_DIR
diff --git a/progressmeter.c b/progressmeter.c
index 0f95222..e39a16b 100644
--- a/progressmeter.c
+++ b/progressmeter.c
@@ -78,9 +78,13 @@ static volatile sig_atomic_t win_resized; /* for window resizing */
 static const char unit[] = " KMGT";
 
 static int
-can_output(void)
+can_output(void) 
 {
+#ifndef NX_WIN32_FIXME
 	return (getpgrp() == tcgetpgrp(STDOUT_FILENO));
+#else
+	return 1;
+#endif
 }
 
 static void
@@ -118,6 +122,8 @@ format_size(char *buf, int size, off_t bytes)
 void
 refresh_progress_meter(void)
 {
+#ifndef NX_WIN32_FIXME
+  
 	char buf[MAX_WINSIZE + 1];
 	time_t now;
 	off_t transferred;
@@ -224,6 +230,7 @@ refresh_progress_meter(void)
 
 	atomicio(vwrite, STDOUT_FILENO, buf, win_size - 1);
 	last_update = now;
+#endif
 }
 
 /*ARGSUSED*/
@@ -241,8 +248,10 @@ update_progress_meter(int ignore)
 	if (can_output())
 		refresh_progress_meter();
 
+#ifndef NX_WIN32_FIXME
 	signal(SIGALRM, update_progress_meter);
 	alarm(UPDATE_INTERVAL);
+#endif
 	errno = save_errno;
 }
 
@@ -261,14 +270,17 @@ start_progress_meter(char *f, off_t filesize, off_t *ctr)
 	if (can_output())
 		refresh_progress_meter();
 
+#ifndef NX_WIN32_FIXME
 	signal(SIGALRM, update_progress_meter);
 	signal(SIGWINCH, sig_winch);
 	alarm(UPDATE_INTERVAL);
+#endif
 }
 
 void
 stop_progress_meter(void)
 {
+#ifndef NX_WIN32_FIXME
 	alarm(0);
 
 	if (!can_output())
@@ -279,6 +291,7 @@ stop_progress_meter(void)
 		refresh_progress_meter();
 
 	atomicio(vwrite, STDOUT_FILENO, "\n", 1);
+#endif
 }
 
 /*ARGSUSED*/
@@ -291,6 +304,7 @@ sig_winch(int sig)
 static void
 setscreensize(void)
 {
+#ifndef NX_WIN32_FIXME
 	struct winsize winsize;
 
 	if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &winsize) != -1 &&
@@ -302,4 +316,5 @@ setscreensize(void)
 	} else
 		win_size = DEFAULT_WINSIZE;
 	win_size += 1;					/* trailing \0 */
+#endif
 }
diff --git a/readconf.c b/readconf.c
index 91dfa56..ad0ccbb 100644
--- a/readconf.c
+++ b/readconf.c
@@ -135,6 +135,14 @@ typedef enum {
 	oTunnel, oTunnelDevice, oLocalCommand, oPermitLocalCommand,
 	oVisualHostKey, oUseRoaming, oZeroKnowledgePasswordAuthentication,
 	oKexAlgorithms, oIPQoS, oRequestTTY,
+
+  #ifdef NX_WIN32_FIXME
+  
+  oPassInputHandle,
+  oPassOutputHandle,
+  
+  #endif
+  
 	oDeprecated, oUnsupported
 } OpCodes;
 
@@ -247,6 +255,13 @@ static struct {
 	{ "ipqos", oIPQoS },
 	{ "requesttty", oRequestTTY },
 
+  #ifdef NX_WIN32_FIXME
+
+  {"passinputhandle", oPassInputHandle},
+  {"passoutputhandle", oPassOutputHandle},
+  
+  #endif
+
 	{ NULL, oBadOption }
 };
 
@@ -1043,6 +1058,28 @@ parse_int:
 			*intptr = value;
 		break;
 
+    #ifdef NX_WIN32_FIXME
+    
+    case oPassInputHandle:
+    {
+      arg = strdelim(&s);
+      
+      options -> passInputHandle_ = atoi(arg);
+    
+      break;
+    }
+
+    case oPassOutputHandle:
+    {
+      arg = strdelim(&s);
+      
+      options -> passOutputHandle_ = atoi(arg);      
+      
+      break;
+    }
+    
+    #endif
+
 	case oDeprecated:
 		debug("%s line %d: Deprecated option \"%s\"",
 		    filename, linenum, keyword);
@@ -1089,9 +1126,11 @@ read_config_file(const char *filename, const char *host, Options *options,
 
 		if (fstat(fileno(f), &sb) == -1)
 			fatal("fstat %s: %s", filename, strerror(errno));
+#ifndef NX_WIN32_FIXME
 		if (((sb.st_uid != 0 && sb.st_uid != getuid()) ||
 		    (sb.st_mode & 022) != 0))
 			fatal("Bad owner or permissions on %s", filename);
+#endif
 	}
 
 	debug("Reading configuration data %.200s", filename);
@@ -1202,6 +1241,13 @@ initialize_options(Options * options)
 	options->ip_qos_interactive = -1;
 	options->ip_qos_bulk = -1;
 	options->request_tty = -1;
+
+  #ifdef NX_WIN32_FIXME
+
+  options -> passInputHandle_  = NULL;
+  options -> passOutputHandle_ = NULL;
+  
+  #endif
 }
 
 /*
diff --git a/readconf.h b/readconf.h
index 5944cff..531ffd8 100644
--- a/readconf.h
+++ b/readconf.h
@@ -134,6 +134,13 @@ typedef struct {
 	int	use_roaming;
 
 	int	request_tty;
+
+  #ifdef NX_WIN32_FIXME
+
+  HANDLE passInputHandle_;
+  HANDLE passOutputHandle_;
+  
+  #endif
 }       Options;
 
 #define SSHCTL_MASTER_NO	0
diff --git a/readpass.c b/readpass.c
index 599c8ef..a8d4f2b 100644
--- a/readpass.c
+++ b/readpass.c
@@ -47,9 +47,27 @@
 #include "ssh.h"
 #include "uidswap.h"
 
+/* NX */
+#ifdef NX_WIN32_FIXME
+
+  #include <conio.h>
+  #include <sys/socket.h>
+  
+  extern int PassInputFd;
+  extern int PassOutputFd;
+
+#endif
+
+
 static char *
 ssh_askpass(char *askpass, const char *msg)
 {
+#ifndef NX_WIN32_FIXME
+
+  /*
+   * Original openssh code.
+   */
+
 	pid_t pid, ret;
 	size_t len;
 	char *pass;
@@ -107,6 +125,117 @@ ssh_askpass(char *askpass, const char *msg)
 	pass = xstrdup(buf);
 	memset(buf, 0, sizeof(buf));
 	return pass;
+#else
+
+  /*
+   * Win32 code.
+   */
+   
+  HANDLE g_hChildStd_OUT_Rd = NULL;
+  HANDLE g_hChildStd_OUT_Wr = NULL;
+
+  SECURITY_ATTRIBUTES saAttr; 
+  
+  PROCESS_INFORMATION piProcInfo; 
+  
+  STARTUPINFO siStartInfo;
+  
+  BOOL bSuccess = FALSE;
+  
+  DWORD dwRead; 
+  
+  CHAR buf[1024]; 
+  
+  int length = 8192;
+  
+  CHAR command[length];
+  
+  char *pass = NULL;
+  
+  saAttr.nLength              = sizeof(SECURITY_ATTRIBUTES); 
+  saAttr.bInheritHandle       = TRUE; 
+  saAttr.lpSecurityDescriptor = NULL; 
+
+  if (!CreatePipe(&g_hChildStd_OUT_Rd, &g_hChildStd_OUT_Wr, &saAttr, 0))
+  {
+    DWORD dw = GetLastError();
+ 
+    error("ssh_askpass: failed to create pipe: %d", (int) dw);
+    
+    return NULL;
+  }
+
+  if (!SetHandleInformation(g_hChildStd_OUT_Rd, HANDLE_FLAG_INHERIT, 0))
+  {
+    DWORD dw = GetLastError();
+    
+    error("ssh_askpass: failed to set pipe for inherit: %d", (int) dw);
+    
+    return NULL;
+  }
+
+  snprintf(command, length, "\"%s\" \"%s\"", askpass, msg);
+
+  ZeroMemory(&piProcInfo, sizeof(PROCESS_INFORMATION));
+  ZeroMemory(&siStartInfo, sizeof(STARTUPINFO));
+  
+  siStartInfo.cb         = sizeof(STARTUPINFO); 
+  siStartInfo.hStdOutput = g_hChildStd_OUT_Wr;
+  siStartInfo.dwFlags   |= STARTF_USESTDHANDLES;
+
+  bSuccess = CreateProcess(NULL, command, NULL, NULL, TRUE, 0,
+                               NULL, NULL, &siStartInfo, &piProcInfo);
+  
+  if (!bSuccess)
+  {
+    DWORD dw = GetLastError();
+
+    error("ssh_askpass: CreateProcess failed: %d", (int) dw);
+    
+    return NULL;
+  }
+  else 
+  {
+    CloseHandle(piProcInfo.hProcess);
+    CloseHandle(piProcInfo.hThread);
+  }
+    
+  if (!CloseHandle(g_hChildStd_OUT_Wr)) 
+  {
+    DWORD dw = GetLastError();
+
+    error("ssh_askpass: failed to close write end of pipe: %d", (int) dw);
+    
+    return NULL;
+  }
+
+  bSuccess = ReadFile(g_hChildStd_OUT_Rd, buf, 1024, &dwRead, NULL);
+  
+  if (!bSuccess)
+  {
+    DWORD dw = GetLastError();
+   
+    error("ssh_askpass: failed to read from child: %d", (int) dw);
+    
+    return NULL;
+  }  
+  
+  if (dwRead == 0)
+  {
+    error("ssh_askpass: read 0 bytes from child");
+    
+    return NULL;
+  }    
+
+  buf[strcspn(buf, "\r\n")] = '\0';
+
+  pass = xstrdup(buf);
+  
+  memset(buf, 0, sizeof(buf));
+  
+  return pass;
+  
+#endif
 }
 
 /*
@@ -118,6 +247,12 @@ ssh_askpass(char *askpass, const char *msg)
 char *
 read_passphrase(const char *prompt, int flags)
 {
+#ifndef NX_WIN32_FIXME
+
+  /*
+   * Original openssh code.
+   */
+
 	char *askpass = NULL, *ret, buf[1024];
 	int rppflags, use_askpass = 0, ttyfd;
 
@@ -164,6 +299,138 @@ read_passphrase(const char *prompt, int flags)
 	ret = xstrdup(buf);
 	memset(buf, 'x', sizeof buf);
 	return ret;
+
+  /*
+   * Win32 code.
+   */
+   
+#else
+
+  char *askpass  = NULL;
+  char *ret      = NULL;
+  char buf[1024] = {0};
+        
+  size_t len = 0;
+
+  int retr = 0;
+        
+  if (getenv(SSH_ASKPASS_ENV))
+  {
+    askpass = getenv(SSH_ASKPASS_ENV);
+    
+    if ((ret = ssh_askpass(askpass, prompt)) == NULL)
+    {
+      if (!(flags & RP_ALLOW_EOF))
+      {
+        return xstrdup("");
+      }
+    }
+   
+    return ret;                
+  }        
+
+  /*
+   * Show prompt for user.
+   */
+
+  _write(PassOutputFd, prompt, strlen(prompt));
+
+  /*
+   * Read pass from stdin socket.
+   */
+
+  len = retr = 0;
+  
+  do
+  {
+    retr = _read(PassInputFd, buf + len, sizeof(buf) - 1 - len);
+    
+    /*
+     * If read error.
+     */
+    
+    if (retr == -1)
+    {
+      int winerr = GetLastError();
+      
+      /*
+       * Non fatal. Only write message and try again.
+       */
+      
+      if (errno == EINTR || errno == EAGAIN ||
+              winerr == WSAENOTSOCK || winerr == WSAEWOULDBLOCK)
+      {
+        debug("ERROR. read_passphrase() : [errno = %d, winerr = %d], "
+                  "trying again...\n", errno, winerr);
+      
+        fflush(stderr);        
+      }
+      
+      /*
+       * Fatal error. Break loop with empty string.
+       */
+
+      else
+      {
+        error("ERROR. read_passphrase() : fatal error"
+                  " [errno = %d, winerr = %d]...\n", errno, winerr);
+      
+        fflush(stderr);
+      
+        buf[0] = 0;
+      
+        len = 1;
+      
+        break;
+      }  
+    }
+
+    /*
+     * No error.
+     */
+    
+    else
+    {
+      len += retr;
+    }
+  } while (len < sizeof(buf) - 1 && buf[len] == '\r');
+
+  /*
+   * Put zero at string end.
+   */
+
+  if (len > 0)
+  {
+    buf[len - 1] = '\0';
+  }
+  else
+  {
+    buf[0] = '\0';
+  }
+  
+  _write(PassOutputFd, "\n", strlen("\n"));
+
+  len = strlen(buf);
+  
+  while (len > 0 && buf[len - 1] == 0xa || buf[len - 1] == 0xd)
+  {
+    buf[len - 1] = 0;
+    
+    len --;
+  }
+  
+  /*
+   * Return copy of pass readed from stdin.
+   */
+  
+  ret = xstrdup(buf);
+
+  memset(buf, 'x', sizeof(buf));
+  
+  return ret;
+  
+#endif
+
 }
 
 int
diff --git a/roaming_client.c b/roaming_client.c
index cea8e73..8ac32fc 100644
--- a/roaming_client.c
+++ b/roaming_client.c
@@ -254,7 +254,9 @@ wait_for_roaming_reconnect(void)
 	/* TODO Perhaps we should read from tty here */
 	while ((c = fgetc(stdin)) != EOF) {
 		if (c == 'Z' - 64) {
+#ifndef NX_WIN32_FIXME
 			kill(getpid(), SIGTSTP);
+#endif
 			continue;
 		}
 		if (c != '\n' && c != '\r')
diff --git a/roaming_common.c b/roaming_common.c
index 9adbe56..e41cf31 100644
--- a/roaming_common.c
+++ b/roaming_common.c
@@ -37,6 +37,13 @@
 #include "buffer.h"
 #include "roaming.h"
 
+#ifdef NX_WIN32_FIXME
+
+  #define ECONNABORTED WSAECONNABORTED
+  #define ECONNREFUSED WSAECONNREFUSED
+  
+#endif
+
 static size_t out_buf_size = 0;
 static char *out_buf = NULL;
 static size_t out_start;
diff --git a/servconf.c b/servconf.c
index 91986e5..3ae3a44 100644
--- a/servconf.c
+++ b/servconf.c
@@ -12,6 +12,15 @@
 
 #include "includes.h"
 
+/*
+ * We support only client side kerberos on Windows.
+ */
+
+#ifdef NX_WIN32_FIXME
+  #undef GSSAPI
+  #undef KRB5
+#endif
+
 #include <sys/types.h>
 #include <sys/socket.h>
 
@@ -138,6 +147,9 @@ initialize_server_options(ServerOptions *options)
 	options->authorized_principals_file = NULL;
 	options->ip_qos_interactive = -1;
 	options->ip_qos_bulk = -1;
+#ifdef NX_WIN32_FIXME
+	options->i_am_a_fake_fork = 0;
+#endif
 }
 
 void
@@ -166,6 +178,7 @@ fill_default_server_options(ServerOptions *options)
 #endif
 		}
 	}
+
 	/* No certificates by default */
 	if (options->num_ports == 0)
 		options->ports[options->num_ports++] = SSH_DEFAULT_PORT;
@@ -489,7 +502,11 @@ derelativise_path(const char *path)
 	char *expanded, *ret, cwd[MAXPATHLEN];
 
 	expanded = tilde_expand_filename(path, getuid());
+#ifdef NX_WIN32_FIXME
+	if (expanded[1] == ':')
+#else
 	if (*expanded == '/')
+#endif
 		return expanded;
 	if (getcwd(cwd, sizeof(cwd)) == NULL)
 		fatal("%s: getcwd: %s", __func__, strerror(errno));
diff --git a/servconf.h b/servconf.h
index 89f38e2..7c6947b 100644
--- a/servconf.h
+++ b/servconf.h
@@ -166,7 +166,11 @@ typedef struct {
 	char   *revoked_keys_file;
 	char   *trusted_user_ca_keys;
 	char   *authorized_principals_file;
-}       ServerOptions;
+  
+  #ifdef NX_WIN32_FIXME
+  int i_am_a_fake_fork;
+  #endif
+} ServerOptions;
 
 /*
  * These are string config options that must be copied between the
diff --git a/serverloop.c b/serverloop.c
index 19b84ff..c8d167f 100644
--- a/serverloop.c
+++ b/serverloop.c
@@ -80,6 +80,11 @@
 #include "misc.h"
 #include "roaming.h"
 
+/* NX */
+#ifdef NX_WIN32_FIXME
+#define isatty(a) WSHELPisatty(a)
+#endif
+
 extern ServerOptions options;
 
 /* XXX */
@@ -129,6 +134,7 @@ static int notify_pipe[2];
 static void
 notify_setup(void)
 {
+#ifndef NX_WIN32_FIXME /* This was causing heap corruption */
 	if (pipe(notify_pipe) < 0) {
 		error("pipe(notify_pipe) failed %s", strerror(errno));
 	} else if ((fcntl(notify_pipe[0], F_SETFD, FD_CLOEXEC) == -1) ||
@@ -141,6 +147,7 @@ notify_setup(void)
 		set_nonblock(notify_pipe[1]);
 		return;
 	}
+#endif
 	notify_pipe[0] = -1;	/* read end */
 	notify_pipe[1] = -1;	/* write end */
 }
@@ -485,6 +492,7 @@ process_output(fd_set *writeset)
 			fdin = -1;
 		} else {
 			/* Successful write. */
+#ifndef NX_WIN32_FIXME
 			if (fdin_is_tty && dlen >= 1 && data[0] != '\r' &&
 			    tcgetattr(fdin, &tio) == 0 &&
 			    !(tio.c_lflag & ECHO) && (tio.c_lflag & ICANON)) {
@@ -495,6 +503,7 @@ process_output(fd_set *writeset)
 				packet_send_ignore(len);
 				packet_send();
 			}
+#endif
 			/* Consume the data from the buffer. */
 			buffer_consume(&stdin_buffer, len);
 			/* Update the count of bytes written to the program. */
@@ -564,6 +573,7 @@ server_loop(pid_t pid, int fdin_arg, int fdout_arg, int fderr_arg)
 
 	debug("Entering interactive session.");
 
+#ifndef NX_WIN32_FIXME
 	/* Initialize the SIGCHLD kludge. */
 	child_terminated = 0;
 	mysignal(SIGCHLD, sigchld_handler);
@@ -573,6 +583,7 @@ server_loop(pid_t pid, int fdin_arg, int fdout_arg, int fderr_arg)
 		signal(SIGINT, sigterm_handler);
 		signal(SIGQUIT, sigterm_handler);
 	}
+#endif
 
 	/* Initialize our global variables. */
 	fdin = fdin_arg;
@@ -749,6 +760,7 @@ server_loop(pid_t pid, int fdin_arg, int fdout_arg, int fderr_arg)
 
 	channel_free_all();
 
+#ifndef NX_WIN32_FIXME
 	/* We no longer want our SIGCHLD handler to be called. */
 	mysignal(SIGCHLD, SIG_DFL);
 
@@ -758,6 +770,13 @@ server_loop(pid_t pid, int fdin_arg, int fdout_arg, int fderr_arg)
 	if (wait_pid != pid)
 		error("Strange, wait returned pid %ld, expected %ld",
 		    (long)wait_pid, (long)pid);
+#else
+	if (WaitForSingleObject(pid, 0) == 0) {
+		wait_status = 0;
+	} else {
+		packet_disconnect("wait: %d", GetLastError());
+	}
+#endif
 
 	/* Check if it exited normally. */
 	if (WIFEXITED(wait_status)) {
@@ -796,6 +815,12 @@ server_loop(pid_t pid, int fdin_arg, int fdout_arg, int fderr_arg)
 static void
 collect_children(void)
 {
+#ifndef NX_WIN32_FIXME
+
+  /*
+   * Original OpenSSH code.
+   */
+   
 	pid_t pid;
 	sigset_t oset, nset;
 	int status;
@@ -813,6 +838,43 @@ collect_children(void)
 		child_terminated = 0;
 	}
 	sigprocmask(SIG_SETMASK, &oset, NULL);
+#else
+
+  /*
+   * Win32 code.
+   */
+   
+  HANDLE process;
+  
+  int status = 0;
+
+  int i = 0;
+  
+  Session *s;
+  
+  do
+  {
+    s = session_get(&i);
+    
+    if (s != NULL) 
+    {
+      if (WaitForSingleObject(s -> pid, 0) == 0) 
+      {
+        debug("Received SIGCHLD.");
+        
+        process = s->pid;
+        
+        session_close_by_pid(s->pid, status);
+        
+        CloseHandle(process);
+      }
+    }
+  } while (i > 0);
+  
+  child_terminated = 0;
+
+#endif
+
 }
 
 void
@@ -878,6 +940,16 @@ server_loop2(Authctxt *authctxt)
 	if (writeset)
 		xfree(writeset);
 
+  /*
+   * Wait until all output has been sent to the client.
+   */
+  
+  #ifdef NX_WIN32_FIXME
+  
+  drain_output();
+  
+  #endif
+
 	/* free all channels, no more reads and writes */
 	channel_free_all();
 
diff --git a/session.c b/session.c
index 6a70400..91e75b8 100644
--- a/session.c
+++ b/session.c
@@ -35,6 +35,16 @@
 
 #include "includes.h"
 
+/*
+ * We support only client side kerberos on Windows.
+ */
+
+#ifdef NX_WIN32_FIXME
+  #undef GSSAPI
+  #undef KRB5
+  #define NX_USE_AUTH 1
+#endif
+
 #include <sys/types.h>
 #include <sys/param.h>
 #ifdef HAVE_SYS_STAT_H
@@ -92,6 +102,20 @@
 #include "monitor_wrap.h"
 #include "sftp.h"
 
+#ifdef NX_WIN32_FIXME
+/*
+FIXME: GFPZR: Function stat() may be undeclared.
+*/
+#include <sys/stat.h>
+#include <winbase.h>
+
+#include <Userenv.h>
+#include <shlobj.h>
+
+extern char HomeDirLsa[MAX_PATH];
+
+#endif
+
 #if defined(KRB5) && defined(USE_AFS)
 #include <kafs.h>
 #endif
@@ -162,6 +186,44 @@ static int is_child = 0;
 static char *auth_sock_name = NULL;
 static char *auth_sock_dir = NULL;
 
+#ifdef NX_WIN32_FIXME
+Session *session_get(int *index)
+{
+  Session *session;
+
+  if (!index)
+  {
+    return NULL;
+  }  
+  
+  if (*index >= sessions_nalloc)
+  {
+    *index = -1;
+    return NULL;
+  }
+
+  /* 
+   * If not used, return next index 
+   */
+  
+  if (!sessions[*index].used) 
+  {
+    (*index)++;
+    return NULL;
+  }
+
+  /*
+   * If used, return session and next index 
+   */
+  
+  session = &sessions[*index];
+  
+  (*index)++;
+  return session;
+}
+
+#endif /* NX_WIN32_FIXME */
+
 /* removes the agent forwarding socket */
 
 static void
@@ -179,6 +241,7 @@ auth_sock_cleanup_proc(struct passwd *pw)
 static int
 auth_input_request_forwarding(struct passwd * pw)
 {
+#ifndef NX_WIN32_FIXME
 	Channel *nc;
 	int sock = -1;
 	struct sockaddr_un sunaddr;
@@ -255,6 +318,9 @@ auth_input_request_forwarding(struct passwd * pw)
 	auth_sock_name = NULL;
 	auth_sock_dir = NULL;
 	return 0;
+#else
+	return 0;
+#endif
 }
 
 static void
@@ -438,15 +504,367 @@ do_authenticated1(Authctxt *authctxt)
 	}
 }
 
-#define USE_PIPES
 /*
  * This is called to fork and execute a command when we have no tty.  This
  * will call do_child from the child, and server_loop from the parent after
  * setting up file descriptors and such.
  */
-int
-do_exec_no_pty(Session *s, const char *command)
+
+int do_exec_no_pty(Session *s, const char *command)
 {
+  #ifdef NX_WIN32_FIXME
+  
+  /*
+   * Win32 code.
+   */
+
+  PROCESS_INFORMATION pi;
+  STARTUPINFO si;
+  
+  int sockin[2];
+  int sockout[2];
+  int sockerr[2];
+  
+  BOOL b;
+  
+  HANDLE hToken = INVALID_HANDLE_VALUE;
+  
+  int do_xauth;
+  
+  FILE *f = NULL;
+  
+  char cmd[1024];
+  char *exec_command;
+  char *laddr;
+  char buf[256];
+
+  if (!command)
+  {
+    exec_command = s->pw->pw_shell;
+  }  
+  else
+  {
+    exec_command = command;
+  }  
+
+  do_xauth = s -> display != NULL && s -> auth_proto != NULL && s -> auth_data != NULL;
+
+  /*
+   * Create three socket pairs for stdin, stdout and stderr 
+   */
+   
+  socketpair(sockin);
+  socketpair(sockout);
+  socketpair(sockerr);
+
+  debug3("sockin[0]: %d sockin[1]: %d", sockin[0], sockin[1]);
+  debug3("sockout[0]: %d sockout[1]: %d", sockout[0], sockout[1]);
+  debug3("sockerr[0]: %d sockerr[1]: %d", sockerr[0], sockerr[1]);
+
+  crlf_sfd(sockin[1]);
+  crlf_sfd(sockout[1]);
+
+  /*
+   * Assign sockets to StartupInfo 
+   */
+  
+  memset(&si, 0 , sizeof(STARTUPINFO));
+  
+  si.cb = sizeof(STARTUPINFO);
+  si.hStdInput = (HANDLE) sfd_to_handle(sockin[0]);
+  si.hStdOutput = (HANDLE) sfd_to_handle(sockout[0]);
+  si.hStdError = (HANDLE) sfd_to_handle(sockerr[0]);
+  si.wShowWindow = SW_HIDE;
+  si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
+  si.lpDesktop = "winsta0\\default";
+
+  SetEnvironmentVariable("USER", s->pw->pw_name);
+  SetEnvironmentVariable("LOGNAME", s->pw->pw_name);
+
+  /*
+   * Setup xauth if needed 
+   */
+   
+  if (do_xauth && options.xauth_location != NULL) 
+  {
+    /*
+     * Add authority data to .Xauthority if appropriate. 
+     */
+  
+    if (debug_flag) 
+    {
+      fprintf(stderr, "Running %.500s remove %.100s\n",
+                  options.xauth_location, s->auth_display);
+      
+      fprintf(stderr, "%.500s add %.100s %.100s %.100s\n", options.xauth_location, 
+                  s -> auth_display, s -> auth_proto, s -> auth_data);
+    }
+    
+    snprintf(cmd, sizeof cmd, "%s -q -", options.xauth_location);
+    
+    f = _popen(cmd, "w");
+    
+    if (f) 
+    {
+      fprintf(f, "remove %s\n", s -> auth_display);
+
+      fprintf(f, "add %s %s %s\n", s -> auth_display, s -> auth_proto, s -> auth_data);
+      
+      _pclose(f);
+    } 
+    else 
+    {
+      fprintf(stderr, "Could not run %s\n", cmd);
+    }
+  }
+
+  #if 0
+  
+  set_nonblock(sockin[0]);
+  set_nonblock(sockin[1]);
+  set_nonblock(sockout[0]);
+  set_nonblock(sockout[1]);
+  set_nonblock(sockerr[0]);
+  set_nonblock(sockerr[1]);
+  
+  #endif
+
+  /* 
+   * If we get this far, the user has already been authenticated 
+   * We should either have a user token in authctxt -> methoddata 
+   * (e.g. for password auth) or we need to create a more restrictive
+   * token using CreateUserToken for non-password auth mechanisms.
+   */
+  
+  /*
+   * Try LSA token first.
+   */
+    
+  if (s -> authctxt -> hTokenLsa_)
+  {
+    debug("Using token from nxlsa...");
+      
+    hToken = s -> authctxt -> hTokenLsa_;
+      
+    AddRightsToDesktop(hToken);
+  }
+    
+  #ifdef NX_USE_NTCREATETOKEN
+    
+  /*
+   * Next try to get an NtCreateToken token if enabled.
+   */
+    
+  else
+  {
+    debug("Using token from NtCreateToken()...");
+      
+    hToken = (HANDLE) PwdCreateUserToken(s -> authctxt -> user, NULL, "sshd");
+  }
+    
+  #endif
+    
+  /*
+   * Next try pass-auth token.
+   */
+  
+  else
+  {
+    debug("Using token from LogonUser()...");
+    
+    hToken = s -> authctxt -> methoddata;
+
+    /*
+     * Clear this value out because we're going to release
+     * the token in this function
+     */
+    
+    s -> authctxt -> methoddata = INVALID_HANDLE_VALUE;
+
+    AddRightsToDesktop(hToken);
+  }
+
+  /*
+   * Set display if needed
+   */
+  
+  if (s -> display)
+  {
+    SetEnvironmentVariable("DISPLAY", s -> display);
+  }
+
+  /*
+   * Get user homedir if needed.
+   */
+  
+  if (s -> pw -> pw_dir == NULL || s -> pw -> pw_dir[0] == '\0')
+  {
+    /*
+     * If there is homedir from LSA use it.
+     */
+
+    if (HomeDirLsa[0] != '\0')
+    {
+      s -> pw -> pw_dir = HomeDirLsa;
+    }
+    
+    /*
+     * If not get homedir from token.
+     */
+    
+    else
+    {
+      s -> pw -> pw_dir = GetHomeDirFromToken(s -> pw -> pw_name, hToken);
+    }
+  }
+
+  /*
+   * Change to users home directory
+   */
+
+  _chdir(s -> pw -> pw_dir);
+
+  SetEnvironmentVariable("HOME", s -> pw -> pw_dir);
+  SetEnvironmentVariable("USERPROFILE", s -> pw -> pw_dir);
+  
+  /*
+   * Set SSH_CLIENT variable.
+   */
+  
+  snprintf(buf, sizeof buf, "%.50s %d %d",
+               get_remote_ipaddr(), get_remote_port(), get_local_port());
+  
+  SetEnvironmentVariable("SSH_CLIENT", buf);
+
+  /*
+   * Set SSH_CONNECTION variable.
+   */
+  
+  laddr = get_local_ipaddr(packet_get_connection_in());
+
+  snprintf(buf, sizeof buf, "%.50s %d %.50s %d",
+               get_remote_ipaddr(), get_remote_port(), laddr, get_local_port());
+               
+  xfree(laddr);
+  
+  SetEnvironmentVariable("SSH_CONNECTION", buf);
+
+  /*
+   * Get the current user's name (associated with nxsshd thread).
+   */
+
+  debug3("Home path before CreateProcessAsUser [%s]", s -> pw -> pw_dir);
+  
+  DWORD size = 256;
+  
+  char name[size];
+  
+  GetUserName(name, &size);
+
+  /*
+   * Create new process as other user using access token object.
+   */
+  
+  debug("Executing command: %s", exec_command);
+
+  /*
+   * Create the child process 
+   */
+ 
+  b = CreateProcessAsUser(hToken, NULL, exec_command, NULL, NULL, TRUE,
+                              CREATE_NEW_PROCESS_GROUP, NULL, s -> pw -> pw_dir,
+                                  &si, &pi);
+  /*
+   * If CreateProcessAsUser() fails we will try CreateProcess()
+   * but only if current user and login user are the same.
+   */
+
+  if ((!b) && (strcmp(name, s -> pw -> pw_name) == 0))
+  {
+    b = CreateProcess(NULL, exec_command, NULL, NULL, TRUE, 
+                          CREATE_NEW_PROCESS_GROUP, NULL, s -> pw -> pw_dir,
+                              &si, &pi);
+  }
+
+  if (!b)
+  {
+    debug("ERROR. Cannot create process as new user (%u).\n", GetLastError());
+    
+    CloseHandle(hToken);
+    
+    exit(1);
+  }
+  
+  /* 
+   * Close the security handle, this instance is done with this user 
+   */
+  
+  CloseHandle(hToken);
+
+  /* 
+   * Close child thread and process handles so it can go away 
+   */
+   
+  CloseHandle(pi.hThread);
+  
+  // CloseHandle(pi.hProcess); 
+
+  /*
+   * Log the process handle (fake it as the pid) for termination lookups 
+   */
+   
+  s -> pid = pi.hProcess;
+  s -> processId = pi.dwProcessId;
+
+  /* 
+   * Set interactive/non-interactive mode. 
+   */
+  
+  packet_set_interactive(s -> display != NULL, options.ip_qos_interactive, 
+                             options.ip_qos_bulk);
+
+  /* 
+   * We are the parent.  Close the child sides of the socket pairs. 
+   */
+  
+  close(sockin[0]);
+  close(sockout[0]);
+  close(sockerr[0]);
+
+  /*
+   * Clear loginmsg, since it's the child's responsibility to display
+   * it to the user, otherwise multiple sessions may accumulate
+   * multiple copies of the login messages.
+   */
+  
+  buffer_clear(&loginmsg);
+
+  /*
+   * Enter the interactive session.  Note: server_loop must be able to
+   * handle the case that fdin and fdout are the same.
+   */
+   
+  if (compat20) 
+  {  
+    session_set_fds(s, sockin[1], sockout[1], sockerr[1], s -> is_subsystem, 0);
+  } 
+  else 
+  {
+    server_loop(pi.hProcess, sockin[1], sockout[1], sockerr[1]);
+    
+    /* 
+     * server_loop has closed inout[0] and err[0]. 
+     */
+  }
+  
+  return 0;
+
+  #else
+  
+  /*
+   * Original OpenSSH code.
+   */
+
 	pid_t pid;
 
 #ifdef USE_PIPES
@@ -631,6 +1049,8 @@ do_exec_no_pty(Session *s, const char *command)
 	}
 #endif
 	return 0;
+  
+  #endif /* else NX_WIN32_FIXME */
 }
 
 /*
@@ -642,6 +1062,12 @@ do_exec_no_pty(Session *s, const char *command)
 int
 do_exec_pty(Session *s, const char *command)
 {
+#ifndef NX_WIN32_FIXME
+
+  /*
+   * Original OpenSSH code.
+   */
+   
 	int fdout, ptyfd, ttyfd, ptymaster;
 	pid_t pid;
 
@@ -753,6 +1179,15 @@ do_exec_pty(Session *s, const char *command)
 		/* server_loop _has_ closed ptyfd and fdout. */
 	}
 	return 0;
+#else
+
+  /*
+   * Win32 code.
+   */
+   
+  return 0;
+
+#endif  
 }
 
 #ifdef LOGIN_NEEDS_UTMPX
@@ -1317,6 +1752,7 @@ do_setup_env(Session *s, const char *shell)
 static void
 do_rc_files(Session *s, const char *shell)
 {
+#ifndef NX_WIN32_FIXME
 	FILE *f = NULL;
 	char cmd[1024];
 	int do_xauth;
@@ -1380,6 +1816,7 @@ do_rc_files(Session *s, const char *shell)
 			    cmd);
 		}
 	}
+#endif
 }
 
 static void
@@ -1473,6 +1910,7 @@ safely_chroot(const char *path, uid_t uid)
 void
 do_setusercontext(struct passwd *pw)
 {
+#ifndef NX_WIN32_FIXME
 	char *chroot_path, *tmp;
 
 	platform_setusercontext(pw);
@@ -1525,11 +1963,13 @@ do_setusercontext(struct passwd *pw)
 
 	if (getuid() != pw->pw_uid || geteuid() != pw->pw_uid)
 		fatal("Failed to set uids to %u.", (u_int) pw->pw_uid);
+#endif /* !NX_WIN32_FIXME */
 }
 
 static void
 do_pwchange(Session *s)
 {
+#ifndef NX_WIN32_FIXME
 	fflush(NULL);
 	fprintf(stderr, "WARNING: Your password has expired.\n");
 	if (s->ttyfd != -1) {
@@ -1550,11 +1990,13 @@ do_pwchange(Session *s)
 		    "Password change required but no TTY available.\n");
 	}
 	exit(1);
+#endif /* !NX_WIN32_FIXME */
 }
 
 static void
 launch_login(struct passwd *pw, const char *hostname)
 {
+#ifndef NX_WIN32_FIXME
 	/* Launch login(1). */
 
 	execl(LOGIN_PROGRAM, "login", "-h", hostname,
@@ -1571,11 +2013,13 @@ launch_login(struct passwd *pw, const char *hostname)
 
 	perror("login");
 	exit(1);
+#endif /* !NX_WIN32_FIXME */
 }
 
 static void
 child_close_fds(void)
 {
+#ifndef NX_WIN32_FIXME
 	if (packet_get_connection_in() == packet_get_connection_out())
 		close(packet_get_connection_in());
 	else {
@@ -1602,6 +2046,7 @@ child_close_fds(void)
 	 * descriptors open.
 	 */
 	closefrom(STDERR_FILENO + 1);
+#endif /* !NX_WIN32_FIXME */
 }
 
 /*
@@ -1613,6 +2058,7 @@ child_close_fds(void)
 void
 do_child(Session *s, const char *command)
 {
+#ifndef NX_WIN32_FIXME
 	extern char **environ;
 	char **env;
 	char *argv[ARGV_MAX];
@@ -1829,6 +2275,7 @@ do_child(Session *s, const char *command)
 	execve(shell, argv, env);
 	perror(shell);
 	exit(1);
+#endif /* !NX_WIN32_FIXME */
 }
 
 void
@@ -2298,6 +2745,47 @@ session_pty_cleanup2(Session *s)
 	if (s->ttyfd == -1)
 		return;
 
+  #ifdef NX_WIN32_FIXME
+
+  /*
+   * Send exit signal to child 'cmd.exe' process.
+   */
+  
+  if (s -> pid != NULL)
+  {
+
+    debug("Sending exit signal to child process [pid = %u]...", s -> pid);
+
+    if (!GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT, s -> processId))
+    {
+      debug("ERROR. Cannot send signal to process.");
+    }
+  
+    /*
+     * Try wait 100 ms until child finished.
+     */
+
+    if (WaitForSingleObject(s -> pid, 100) == WAIT_TIMEOUT)
+    {
+      /*
+       * If still not closed, kill 'cmd.exe' process.
+       */
+    
+      if (TerminateProcess(s -> pid, 1) == TRUE)
+      {
+        debug("Process %u terminated.", s -> pid);
+      }
+      else
+      {
+        debug("ERROR. Cannot terminate %u process.", s -> pid);
+      }
+    }
+    
+    CloseHandle(s -> pid);
+  }
+ 
+  #endif
+
 	debug("session_pty_cleanup: session %d release %s", s->self, s->tty);
 
 	/* Record that the user has logged out. */
@@ -2330,6 +2818,7 @@ session_pty_cleanup(Session *s)
 static char *
 sig2name(int sig)
 {
+#ifndef NX_WIN32_FIXME
 #define SSH_SIG(x) if (sig == SIG ## x) return #x
 	SSH_SIG(ABRT);
 	SSH_SIG(ALRM);
@@ -2345,6 +2834,7 @@ sig2name(int sig)
 	SSH_SIG(USR1);
 	SSH_SIG(USR2);
 #undef	SSH_SIG
+#endif
 	return "SIG@openssh.com";
 }
 
@@ -2460,6 +2950,46 @@ session_close(Session *s)
 {
 	u_int i;
 
+  #ifdef NX_WIN32_FIXME
+  
+  /*
+   * Send exit signal to child 'cmd.exe' process.
+   */
+  
+    if (s -> pid != NULL)
+    {
+      debug("Sending exit signal to child process [pid = %u]...", s -> pid);
+
+      if (!GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT, s -> processId))
+      {
+        debug("ERROR. Cannot send signal to process.");
+      }  
+  
+      /*
+       * Try wait 100 ms until child finished.
+       */
+
+      if (WaitForSingleObject(s -> pid, 100) == WAIT_TIMEOUT)
+      {
+        /* 
+         * If still not closed, kill 'cmd.exe' process.
+         */
+    
+        if (TerminateProcess(s -> pid, 1) == TRUE)
+        {
+          debug("Process %u terminated.", s -> pid);
+        }
+        else
+        {
+          debug("ERROR. Cannot terminate %u process.", s -> pid);
+        } 
+      }
+    
+      CloseHandle(s -> pid);
+    }
+  
+  #endif
+
 	debug("session_close: session %d pid %ld", s->self, (long)s->pid);
 	if (s->ttyfd != -1)
 		session_pty_cleanup(s);
@@ -2649,7 +3179,11 @@ session_setup_x11fwd(Session *s)
 		    s->display_number, s->screen);
 		snprintf(auth_display, sizeof auth_display, "unix:%u.%u",
 		    s->display_number, s->screen);
+#ifdef NX_WIN32_FIXME
 		s->display = xstrdup(display);
+#else
+		s->auth_display = xstrdup(auth_display);
+#endif
 		s->auth_display = xstrdup(auth_display);
 	} else {
 #ifdef IPADDR_IN_DISPLAY
diff --git a/session.h b/session.h
index cbb8e3a..ec0162f 100644
--- a/session.h
+++ b/session.h
@@ -36,6 +36,10 @@ struct Session {
 	Authctxt *authctxt;
 	pid_t	pid;
 
+  #ifdef NX_WIN32_FIXME
+  DWORD processId;
+  #endif
+
 	/* tty */
 	char	*term;
 	int	ptyfd, ttyfd, ptymaster;
diff --git a/sftp-client.c b/sftp-client.c
index caa384b..8c2f20a 100644
--- a/sftp-client.c
+++ b/sftp-client.c
@@ -56,6 +56,104 @@
 #include "sftp-common.h"
 #include "sftp-client.h"
 
+#ifdef NX_WIN32_FIXME
+  
+  #include <sys/socket.h>
+  
+  #define mkdir(a, b) _mkdir(a)
+
+  #define lstat(PATH, BUF) _stat(PATH, BUF)
+  
+  /*
+   * Don't use fstat() function redefined
+   * in socket.h ported header. It is wrong
+   * in this context.
+   */
+
+  #ifdef fstat
+  #undef fstat
+  #endif
+
+  int glob(const char *pattern, int flags, int (*errfunc)(const char *epath, int eerrno),
+               glob_t *pglob)
+  {
+    if (strchr(pattern, '*') || strchr(pattern, '?'))
+    {
+      error("Match pattern not implemented on Win32.\n");
+      
+      return -1;
+    }
+    else
+    {
+      pglob -> gl_pathc    = 2;
+      pglob -> gl_pathv    = malloc(2 * sizeof(char *));
+      pglob -> gl_pathv[0] = strdup(pattern);
+      pglob -> gl_pathv[1] = NULL;
+      pglob -> gl_offs     = 0;
+    }
+    
+    return 0;
+  }
+  
+  void globfree(glob_t *pglob)
+  {
+    if (pglob)
+    {
+      int i = 0;
+      
+      if (pglob -> gl_pathv)
+      {
+        for (i = 0; i < pglob -> gl_pathc; i++)
+        {
+          if (pglob -> gl_pathv[i])
+          {
+            free(pglob -> gl_pathv[i]);
+          }
+        }
+          
+        free(pglob -> gl_pathv);
+      }
+      
+      //free(pglob);
+    }
+  }
+  
+  pid_t waitpid(pid_t pid, int *stat_loc, int options)
+  {
+    return 0;
+  }
+  
+  /*
+   * Write array of buffers to file descriptor.
+   *
+   * fd      - file descriptor to write (IN).
+   * iovec   - array of iovec with buffers to send (IN).
+   * iovecnt - number of buffers in iovec (IN).
+   *
+   * RETURNS: Number of bytes written or -1 if error.
+   */
+ 
+  int writev(int fd, struct iovec *iov, int iovcnt)
+  {
+    int written = 0;
+
+    int i = 0;
+    
+    for (i = 0; i < iovcnt; i++)
+    {
+      int ret = write(fd, iov[i].iov_base, iov[i].iov_len);
+
+      if (ret > 0)
+      {
+        written += ret;
+      }
+    }  
+    
+    return written;
+  }
+
+#endif
+
 extern volatile sig_atomic_t interrupted;
 extern int showprogress;
 
@@ -347,7 +445,9 @@ do_init(int fd_in, int fd_out, u_int transfer_buflen, u_int num_requests,
 
 	buffer_init(&msg);
 	buffer_put_char(&msg, SSH2_FXP_INIT);
+
 	buffer_put_int(&msg, SSH2_FILEXFER_VERSION);
+
 	send_msg(ret, &msg);
 
 	buffer_clear(&msg);
@@ -367,6 +467,7 @@ do_init(int fd_in, int fd_out, u_int transfer_buflen, u_int num_requests,
 
 	/* Check for extensions */
 	while (buffer_len(&msg) > 0) {
+  
 		char *name = buffer_get_string(&msg, NULL);
 		char *value = buffer_get_string(&msg, NULL);
 		int known = 0;
@@ -411,7 +512,7 @@ do_init(int fd_in, int fd_out, u_int transfer_buflen, u_int num_requests,
 		bandwidth_limit_init(&ret->bwlimit_out, ret->limit_kbps,
 		    ret->transfer_buflen);
 	}
-
+  
 	return ret;
 }
 
@@ -1047,8 +1148,17 @@ do_download(struct sftp_conn *conn, char *remote_path, char *local_path,
 		return(-1);
 	}
 
+  #ifdef NX_WIN32_FIXME
+
+  local_fd = _open(local_path, O_WRONLY | O_CREAT | O_TRUNC, mode | S_IWRITE);
+
+  #else
+
 	local_fd = open(local_path, O_WRONLY | O_CREAT | O_TRUNC,
 	    mode | S_IWRITE);
+
+  #endif
+  
 	if (local_fd == -1) {
 		error("Couldn't open local file \"%s\" for writing: %s",
 		    local_path, strerror(errno));
@@ -1130,7 +1240,17 @@ do_download(struct sftp_conn *conn, char *remote_path, char *local_path,
 				fatal("Received more data than asked for "
 				    "%u > %u", len, req->len);
 			if ((lseek(local_fd, req->offset, SEEK_SET) == -1 ||
+
+      #ifdef NX_WIN32_FIXME
+
+      atomicio(_write, local_fd, data, len) != len) &&
+
+      #else
+
 			    atomicio(vwrite, local_fd, data, len) != len) &&
+
+      #endif
+
 			    !write_error) {
 				write_errno = errno;
 				write_error = 1;
@@ -1215,7 +1335,17 @@ do_download(struct sftp_conn *conn, char *remote_path, char *local_path,
 				    local_path, strerror(errno));
 		}
 	}
+
+  #ifdef NX_WIN32_FIXME
+  
+  _close(local_fd);
+  
+  #else
+
 	close(local_fd);
+  
+  #endif
+  
 	buffer_free(&msg);
 	xfree(handle);
 
@@ -1355,7 +1485,16 @@ do_upload(struct sftp_conn *conn, char *local_path, char *remote_path,
 
 	TAILQ_INIT(&acks);
 
-	if ((local_fd = open(local_path, O_RDONLY, 0)) == -1) {
+  #ifdef NX_WIN32_FIXME
+
+  if ((local_fd = _open(local_path, O_RDONLY, 0)) == -1) {
+
+  #else
+
+	if ((local_fd = open(local_path, O_RDONLY, 0)) == -1) {  
+
+  #endif
+  
 		error("Couldn't open local file \"%s\" for reading: %s",
 		    local_path, strerror(errno));
 		return(-1);
@@ -1368,7 +1507,17 @@ do_upload(struct sftp_conn *conn, char *local_path, char *remote_path,
 	}
 	if (!S_ISREG(sb.st_mode)) {
 		error("%s is not a regular file", local_path);
+
+    #ifdef NX_WIN32_FIXME
+    
+    _close(local_fd);
+    
+    #else
+    
 		close(local_fd);
+
+    #endif
+    
 		return(-1);
 	}
 	stat_to_attrib(&sb, &a);
@@ -1396,7 +1545,17 @@ do_upload(struct sftp_conn *conn, char *local_path, char *remote_path,
 	handle = get_handle(conn, id, &handle_len,
 	    "remote open(\"%s\")", remote_path);
 	if (handle == NULL) {
+
+    #ifdef NX_WIN32_FIXME
+
+    _close(local_fd);
+    
+    #else
+    
 		close(local_fd);
+
+    #endif
+    
 		buffer_free(&msg);
 		return -1;
 	}
@@ -1421,7 +1580,17 @@ do_upload(struct sftp_conn *conn, char *local_path, char *remote_path,
 		if (interrupted || status != SSH2_FX_OK)
 			len = 0;
 		else do
+
+      #ifdef NX_WIN32_FIXME
+      
+      len = _read(local_fd, data, conn->transfer_buflen);
+      
+      #else
+
 			len = read(local_fd, data, conn->transfer_buflen);
+
+      #endif
+
 		while ((len == -1) &&
 		    (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK));
 
@@ -1496,7 +1665,17 @@ do_upload(struct sftp_conn *conn, char *local_path, char *remote_path,
 		status = -1;
 	}
 
+  #ifdef NX_WIN32_FIXME
+
+  if (_close(local_fd) == -1) 
+  {
+
+  #else
+
 	if (close(local_fd) == -1) {
+
+  #endif
+  
 		error("Couldn't close local file \"%s\": %s", local_path,
 		    strerror(errno));
 		status = -1;
@@ -1635,4 +1814,3 @@ path_append(char *p1, char *p2)
 
 	return(ret);
 }
-
diff --git a/sftp-common.c b/sftp-common.c
index a042875..a7797b1 100644
--- a/sftp-common.c
+++ b/sftp-common.c
@@ -195,19 +195,31 @@ ls_file(const char *name, const struct stat *st, int remote, int si_units)
 	char buf[1024], mode[11+1], tbuf[12+1], ubuf[11+1], gbuf[11+1];
 	char sbuf[FMT_SCALED_STRSIZE];
 
+#ifndef NX_WIN32_FIXME
 	strmode(st->st_mode, mode);
+#endif
 	if (!remote) {
 		user = user_from_uid(st->st_uid, 0);
 	} else {
 		snprintf(ubuf, sizeof ubuf, "%u", (u_int)st->st_uid);
 		user = ubuf;
-	}
+
+#ifdef NX_WIN32_FIXME
+  
+  snprintf(gbuf, sizeof gbuf, "%u", (u_int) st -> st_gid);
+  
+  group = gbuf;
+
+#else
 	if (!remote) {
 		group = group_from_gid(st->st_gid, 0);
 	} else {
 		snprintf(gbuf, sizeof gbuf, "%u", (u_int)st->st_gid);
 		group = gbuf;
 	}
+#endif
+
+	}
 	if (ltime != NULL) {
 		if (time(NULL) - st->st_mtime < (365*24*60*60)/2)
 			sz = strftime(tbuf, sizeof tbuf, "%b %e %H:%M", ltime);
@@ -228,5 +240,6 @@ ls_file(const char *name, const struct stat *st, int remote, int si_units)
 		    (u_int)st->st_nlink, ulen, user, glen, group,
 		    (unsigned long long)st->st_size, tbuf, name);
 	}
+  
 	return xstrdup(buf);
 }
diff --git a/sftp-server.c b/sftp-server.c
index 9d01c7d..16ac91d 100644
--- a/sftp-server.c
+++ b/sftp-server.c
@@ -51,6 +51,54 @@
 #include "sftp.h"
 #include "sftp-common.h"
 
+/* NX */
+#ifdef NX_WIN32_FIXME
+
+  #include <sys/stat.h>
+
+  #define isatty(a) WSHELPisatty(a)
+  
+  #define mkdir(a, b) _mkdir(a)
+
+  #define open(NAME, FLAGS, MODE) _open(NAME, FLAGS | O_BINARY, MODE)
+
+  #define close(FD) _close(FD)
+
+  #define write(FD, BUF, LEN) _write(FD, BUF, LEN)
+
+  #define read(FD, BUF, LEN) _read(FD, BUF, LEN)
+  
+  #define lstat(PATH, BUF) _stat(PATH, BUF)
+
+  #define stat(PATH, BUF) _stat(PATH, BUF)
+
+  /*
+   * Function to cut last slash (windows
+   * stat requires paths 
+   * without slash at the end).
+   */
+
+  #define realpath realpathNx
+
+  /*
+   * Don't use fstat() function redefined
+   * in socket.h ported header. It is wrong
+   * in this context.
+   */
+
+  #ifdef fstat
+  #undef fstat
+  #endif
+
+  /*
+   * Handle to log file.
+   */
+   
+  extern int logfd;
+  extern int sfd_start;
+
+#endif /* NX_WIN32_FIXME */
+
 /* helper */
 #define get_int64()			buffer_get_int64(&iqueue);
 #define get_int()			buffer_get_int(&iqueue);
@@ -95,7 +143,9 @@ errno_to_portable(int unixerrno)
 	case ENOENT:
 	case ENOTDIR:
 	case EBADF:
+#ifndef NX_WIN32_FIXME
 	case ELOOP:
+#endif
 		ret = SSH2_FX_NO_SUCH_FILE;
 		break;
 	case EPERM:
@@ -563,7 +613,7 @@ process_open(void)
 	    ((flags & O_ACCMODE) == O_WRONLY || (flags & O_ACCMODE) == O_RDWR))
 		status = SSH2_FX_PERMISSION_DENIED;
 	else {
-		fd = open(name, flags, mode);
+	fd = open(name, flags, mode);
 		if (fd < 0) {
 			status = errno_to_portable(errno);
 		} else {
@@ -689,13 +739,32 @@ process_do_stat(int do_lstat)
 	struct stat st;
 	u_int32_t id;
 	char *name;
+
+  #ifdef NX_WIN32_FIXME
+  char resolvedname[MAXPATHLEN];
+  #endif
+
 	int ret, status = SSH2_FX_FAILURE;
 
 	id = get_int();
+  
+  #ifdef NX_WIN32_FIXME
+  
+  name = get_string(NULL);
+  name = realpathNx(name, resolvedname);
+  debug3("request %u: %sstat", id, do_lstat ? "l" : "");
+  verbose("%sstat name \"%s\"", do_lstat ? "l" : "", name);
+  ret = stat(name, &st);
+  
+  #else
+
 	name = get_string(NULL);
 	debug3("request %u: %sstat", id, do_lstat ? "l" : "");
 	verbose("%sstat name \"%s\"", do_lstat ? "l" : "", name);
 	ret = do_lstat ? lstat(name, &st) : stat(name, &st);
+
+  #endif
+
 	if (ret < 0) {
 		status = errno_to_portable(errno);
 	} else {
@@ -778,9 +847,11 @@ process_setstat(void)
 	if (a->flags & SSH2_FILEXFER_ATTR_SIZE) {
 		logit("set \"%s\" size %llu",
 		    name, (unsigned long long)a->size);
+#ifndef NX_WIN32_FIXME
 		ret = truncate(name, a->size);
 		if (ret == -1)
 			status = errno_to_portable(errno);
+#endif
 	}
 	if (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {
 		logit("set \"%s\" mode %04o", name, a->perm);
@@ -802,9 +873,11 @@ process_setstat(void)
 	if (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {
 		logit("set \"%s\" owner %lu group %lu", name,
 		    (u_long)a->uid, (u_long)a->gid);
+#ifndef NX_WIN32_FIXME
 		ret = chown(name, a->uid, a->gid);
 		if (ret == -1)
 			status = errno_to_portable(errno);
+#endif
 	}
 	send_status(id, status);
 	xfree(name);
@@ -833,9 +906,11 @@ process_fsetstat(void)
 		if (a->flags & SSH2_FILEXFER_ATTR_SIZE) {
 			logit("set \"%s\" size %llu",
 			    name, (unsigned long long)a->size);
+#ifndef NX_WIN32_FIXME
 			ret = ftruncate(fd, a->size);
 			if (ret == -1)
 				status = errno_to_portable(errno);
+#endif
 		}
 		if (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {
 			logit("set \"%s\" mode %04o", name, a->perm);
@@ -865,6 +940,7 @@ process_fsetstat(void)
 		if (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {
 			logit("set \"%s\" owner %lu group %lu", name,
 			    (u_long)a->uid, (u_long)a->gid);
+#ifndef NX_WIN32_FIXME
 #ifdef HAVE_FCHOWN
 			ret = fchown(fd, a->uid, a->gid);
 #else
@@ -872,6 +948,7 @@ process_fsetstat(void)
 #endif
 			if (ret == -1)
 				status = errno_to_portable(errno);
+#endif
 		}
 	}
 	send_status(id, status);
@@ -1075,6 +1152,7 @@ process_rename(void)
 		status = SSH2_FX_PERMISSION_DENIED;
 	else if (lstat(oldpath, &sb) == -1)
 		status = errno_to_portable(errno);
+#ifndef NX_WIN32_FIXME
 	else if (S_ISREG(sb.st_mode)) {
 		/* Race-free rename of regular files */
 		if (link(oldpath, newpath) == -1) {
@@ -1108,7 +1186,9 @@ process_rename(void)
 			unlink(newpath);
 		} else
 			status = SSH2_FX_OK;
-	} else if (stat(newpath, &sb) == -1) {
+	}
+#endif /* !NX_WIN32_FIXME */
+	else if (stat(newpath, &sb) == -1) {
 		if (rename(oldpath, newpath) == -1)
 			status = errno_to_portable(errno);
 		else
@@ -1122,6 +1202,30 @@ process_rename(void)
 static void
 process_readlink(void)
 {
+  #ifdef NX_WIN32_FIXME
+  
+  /*
+   * Win32 code.
+   */
+   
+  u_int32_t id;
+  
+  char *request;
+
+  id = get_int();
+  
+  request = get_string(NULL);
+  
+  send_status(id, SSH2_FX_OP_UNSUPPORTED);
+  
+  xfree(request);
+  
+  #else  
+
+  /*
+   * Original OpenSSH code.
+   */
+   
 	u_int32_t id;
 	int len;
 	char buf[MAXPATHLEN];
@@ -1142,11 +1246,36 @@ process_readlink(void)
 		send_names(id, 1, &s);
 	}
 	xfree(path);
+  #endif /* NX_WIN32_FIXME */
 }
 
 static void
 process_symlink(void)
 {
+  #ifdef NX_WIN32_FIXME
+  
+  /*
+   * Win32 code.
+   */
+   
+  u_int32_t id;
+  
+  char *request;
+
+  id = get_int();
+  
+  request = get_string(NULL);
+  
+  send_status(id, SSH2_FX_OP_UNSUPPORTED);
+  
+  xfree(request);
+  
+  #else
+
+  /*
+   *  Original OpenSSH code.
+   */
+  
 	u_int32_t id;
 	char *oldpath, *newpath;
 	int ret, status;
@@ -1166,6 +1295,7 @@ process_symlink(void)
 	send_status(id, status);
 	xfree(oldpath);
 	xfree(newpath);
+  #endif
 }
 
 static void
@@ -1237,10 +1367,12 @@ process_extended_hardlink(u_int32_t id)
 	logit("hardlink old \"%s\" new \"%s\"", oldpath, newpath);
 	if (readonly)
 		status = SSH2_FX_PERMISSION_DENIED;
+#ifndef NX_WIN32_FIXME
 	else {
 		ret = link(oldpath, newpath);
 		status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
 	}
+#endif
 	send_status(id, status);
 	xfree(oldpath);
 	xfree(newpath);
@@ -1407,10 +1539,65 @@ sftp_server_main(int argc, char **argv, struct passwd *user_pw)
 
 	extern char *optarg;
 	extern char *__progname;
+  
+  #ifdef NX_WIN32_FIXME
+    
+    /*
+     * Initialize Win32 log.
+     */
+     
+    sfd_start = 3;
+
+    TCHAR szPath2[MAX_PATH];
+    
+    if (GetModuleFileName(NULL, szPath2, MAX_PATH))
+    {
+      char *p = NULL;
+
+      p = strrchr(szPath2, '\\');
+      
+      if (p)
+      {
+        *p = '\0';
+      }
+      
+      p = strrchr(szPath2, '\\');
+      
+      if (p)
+      {
+        *p = '\0';
+      }
+      
+      char logpath[MAX_PATH];
+      
+      snprintf(logpath, MAX_PATH, "%s\\var\\log\\sftp-server.log", szPath2);
+      
+      logfd = _open(logpath, O_WRONLY | O_CREAT | O_APPEND , S_IREAD | S_IWRITE);
+      
+      log_level = SYSLOG_LEVEL_DEBUG3;
+
+      __progname = ssh_get_progname(argv[0]);
+    
+      log_init(__progname, log_level, log_facility, log_stderr);
+    }  
+
+    /*
+     * Initialize Win32 I/O wrapper.
+     */
+     
+    WSHELPinitialize();
+
+    allocate_standard_descriptor(STDIN_FILENO);
+    allocate_standard_descriptor(STDOUT_FILENO);
+    allocate_standard_descriptor(STDERR_FILENO);
+
+  #else
 
 	__progname = ssh_get_progname(argv[0]);
 	log_init(__progname, log_level, log_facility, log_stderr);
 
+  #endif
+
 	while (!skipargs && (ch = getopt(argc, argv, "f:l:u:cehR")) != -1) {
 		switch (ch) {
 		case 'R':
@@ -1450,7 +1637,9 @@ sftp_server_main(int argc, char **argv, struct passwd *user_pw)
 		}
 	}
 
+#ifndef NX_WIN32_FIXME
 	log_init(__progname, log_level, log_facility, log_stderr);
+#endif
 
 	if ((cp = getenv("SSH_CONNECTION")) != NULL) {
 		client_addr = xstrdup(cp);
@@ -1471,10 +1660,15 @@ sftp_server_main(int argc, char **argv, struct passwd *user_pw)
 	in = STDIN_FILENO;
 	out = STDOUT_FILENO;
 
+#ifdef NX_WIN32_FIXME
+  setmode(in, O_BINARY);
+  setmode(out, O_BINARY);
+#else
 #ifdef HAVE_CYGWIN
 	setmode(in, O_BINARY);
 	setmode(out, O_BINARY);
 #endif
+#endif
 
 	max = 0;
 	if (in > max)
@@ -1485,13 +1679,25 @@ sftp_server_main(int argc, char **argv, struct passwd *user_pw)
 	buffer_init(&iqueue);
 	buffer_init(&oqueue);
 
+#ifdef NX_WIN32_FIXME
+  rset = (fd_set *)xmalloc(sizeof(fd_set));
+  wset = (fd_set *)xmalloc(sizeof(fd_set));
+#else
 	set_size = howmany(max + 1, NFDBITS) * sizeof(fd_mask);
 	rset = (fd_set *)xmalloc(set_size);
 	wset = (fd_set *)xmalloc(set_size);
+#endif
 
 	for (;;) {
+#ifdef NX_WIN32_FIXME
+    
+    FD_ZERO(rset);
+    FD_ZERO(wset);
+    
+#else
 		memset(rset, 0, set_size);
 		memset(wset, 0, set_size);
+#endif
 
 		/*
 		 * Ensure that we can read a full buffer and handle
diff --git a/sftp-server.c.SSH.original_old b/sftp-server.c.SSH.original_old
new file mode 100644
index 0000000..76edebc
--- /dev/null
+++ b/sftp-server.c.SSH.original_old
@@ -0,0 +1,1353 @@
+/* $OpenBSD: sftp-server.c,v 1.73 2007/05/17 07:55:29 djm Exp $ */
+/*
+ * Copyright (c) 2000-2004 Markus Friedl.  All rights reserved.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "includes.h"
+
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/stat.h>
+#ifdef HAVE_SYS_TIME_H
+# include <sys/time.h>
+#endif
+
+#include <dirent.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <pwd.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <pwd.h>
+#include <time.h>
+#include <unistd.h>
+#include <stdarg.h>
+
+#include "xmalloc.h"
+#include "buffer.h"
+#include "log.h"
+#include "misc.h"
+#include "uidswap.h"
+
+#include "sftp.h"
+#include "sftp-common.h"
+
+/* helper */
+#define get_int64()			buffer_get_int64(&iqueue);
+#define get_int()			buffer_get_int(&iqueue);
+#define get_string(lenp)		buffer_get_string(&iqueue, lenp);
+
+/* Our verbosity */
+LogLevel log_level = SYSLOG_LEVEL_ERROR;
+
+/* Our client */
+struct passwd *pw = NULL;
+char *client_addr = NULL;
+
+/* input and output queue */
+Buffer iqueue;
+Buffer oqueue;
+
+/* Version of client */
+int version;
+
+/* portable attributes, etc. */
+
+typedef struct Stat Stat;
+
+struct Stat {
+	char *name;
+	char *long_name;
+	Attrib attrib;
+};
+
+static int
+errno_to_portable(int unixerrno)
+{
+	int ret = 0;
+
+	switch (unixerrno) {
+	case 0:
+		ret = SSH2_FX_OK;
+		break;
+	case ENOENT:
+	case ENOTDIR:
+	case EBADF:
+	case ELOOP:
+		ret = SSH2_FX_NO_SUCH_FILE;
+		break;
+	case EPERM:
+	case EACCES:
+	case EFAULT:
+		ret = SSH2_FX_PERMISSION_DENIED;
+		break;
+	case ENAMETOOLONG:
+	case EINVAL:
+		ret = SSH2_FX_BAD_MESSAGE;
+		break;
+	default:
+		ret = SSH2_FX_FAILURE;
+		break;
+	}
+	return ret;
+}
+
+static int
+flags_from_portable(int pflags)
+{
+	int flags = 0;
+
+	if ((pflags & SSH2_FXF_READ) &&
+	    (pflags & SSH2_FXF_WRITE)) {
+		flags = O_RDWR;
+	} else if (pflags & SSH2_FXF_READ) {
+		flags = O_RDONLY;
+	} else if (pflags & SSH2_FXF_WRITE) {
+		flags = O_WRONLY;
+	}
+	if (pflags & SSH2_FXF_CREAT)
+		flags |= O_CREAT;
+	if (pflags & SSH2_FXF_TRUNC)
+		flags |= O_TRUNC;
+	if (pflags & SSH2_FXF_EXCL)
+		flags |= O_EXCL;
+	return flags;
+}
+
+static const char *
+string_from_portable(int pflags)
+{
+	static char ret[128];
+
+	*ret = '\0';
+
+#define PAPPEND(str)	{				\
+		if (*ret != '\0')			\
+			strlcat(ret, ",", sizeof(ret));	\
+		strlcat(ret, str, sizeof(ret));		\
+	}
+
+	if (pflags & SSH2_FXF_READ)
+		PAPPEND("READ")
+	if (pflags & SSH2_FXF_WRITE)
+		PAPPEND("WRITE")
+	if (pflags & SSH2_FXF_CREAT)
+		PAPPEND("CREATE")
+	if (pflags & SSH2_FXF_TRUNC)
+		PAPPEND("TRUNCATE")
+	if (pflags & SSH2_FXF_EXCL)
+		PAPPEND("EXCL")
+
+	return ret;
+}
+
+static Attrib *
+get_attrib(void)
+{
+	return decode_attrib(&iqueue);
+}
+
+/* handle handles */
+
+typedef struct Handle Handle;
+struct Handle {
+	int use;
+	DIR *dirp;
+	int fd;
+	char *name;
+	u_int64_t bytes_read, bytes_write;
+};
+
+enum {
+	HANDLE_UNUSED,
+	HANDLE_DIR,
+	HANDLE_FILE
+};
+
+Handle	handles[100];
+
+static void
+handle_init(void)
+{
+	u_int i;
+
+	for (i = 0; i < sizeof(handles)/sizeof(Handle); i++)
+		handles[i].use = HANDLE_UNUSED;
+}
+
+static int
+handle_new(int use, const char *name, int fd, DIR *dirp)
+{
+	u_int i;
+
+	for (i = 0; i < sizeof(handles)/sizeof(Handle); i++) {
+		if (handles[i].use == HANDLE_UNUSED) {
+			handles[i].use = use;
+			handles[i].dirp = dirp;
+			handles[i].fd = fd;
+			handles[i].name = xstrdup(name);
+			handles[i].bytes_read = handles[i].bytes_write = 0;
+			return i;
+		}
+	}
+	return -1;
+}
+
+static int
+handle_is_ok(int i, int type)
+{
+	return i >= 0 && (u_int)i < sizeof(handles)/sizeof(Handle) &&
+	    handles[i].use == type;
+}
+
+static int
+handle_to_string(int handle, char **stringp, int *hlenp)
+{
+	if (stringp == NULL || hlenp == NULL)
+		return -1;
+	*stringp = xmalloc(sizeof(int32_t));
+	put_u32(*stringp, handle);
+	*hlenp = sizeof(int32_t);
+	return 0;
+}
+
+static int
+handle_from_string(const char *handle, u_int hlen)
+{
+	int val;
+
+	if (hlen != sizeof(int32_t))
+		return -1;
+	val = get_u32(handle);
+	if (handle_is_ok(val, HANDLE_FILE) ||
+	    handle_is_ok(val, HANDLE_DIR))
+		return val;
+	return -1;
+}
+
+static char *
+handle_to_name(int handle)
+{
+	if (handle_is_ok(handle, HANDLE_DIR)||
+	    handle_is_ok(handle, HANDLE_FILE))
+		return handles[handle].name;
+	return NULL;
+}
+
+static DIR *
+handle_to_dir(int handle)
+{
+	if (handle_is_ok(handle, HANDLE_DIR))
+		return handles[handle].dirp;
+	return NULL;
+}
+
+static int
+handle_to_fd(int handle)
+{
+	if (handle_is_ok(handle, HANDLE_FILE))
+		return handles[handle].fd;
+	return -1;
+}
+
+static void
+handle_update_read(int handle, ssize_t bytes)
+{
+	if (handle_is_ok(handle, HANDLE_FILE) && bytes > 0)
+		handles[handle].bytes_read += bytes;
+}
+
+static void
+handle_update_write(int handle, ssize_t bytes)
+{
+	if (handle_is_ok(handle, HANDLE_FILE) && bytes > 0)
+		handles[handle].bytes_write += bytes;
+}
+
+static u_int64_t
+handle_bytes_read(int handle)
+{
+	if (handle_is_ok(handle, HANDLE_FILE))
+		return (handles[handle].bytes_read);
+	return 0;
+}
+
+static u_int64_t
+handle_bytes_write(int handle)
+{
+	if (handle_is_ok(handle, HANDLE_FILE))
+		return (handles[handle].bytes_write);
+	return 0;
+}
+
+static int
+handle_close(int handle)
+{
+	int ret = -1;
+
+	if (handle_is_ok(handle, HANDLE_FILE)) {
+		ret = close(handles[handle].fd);
+		handles[handle].use = HANDLE_UNUSED;
+		xfree(handles[handle].name);
+	} else if (handle_is_ok(handle, HANDLE_DIR)) {
+		ret = closedir(handles[handle].dirp);
+		handles[handle].use = HANDLE_UNUSED;
+		xfree(handles[handle].name);
+	} else {
+		errno = ENOENT;
+	}
+	return ret;
+}
+
+static void
+handle_log_close(int handle, char *emsg)
+{
+	if (handle_is_ok(handle, HANDLE_FILE)) {
+		logit("%s%sclose \"%s\" bytes read %llu written %llu",
+		    emsg == NULL ? "" : emsg, emsg == NULL ? "" : " ",
+		    handle_to_name(handle),
+		    (unsigned long long)handle_bytes_read(handle),
+		    (unsigned long long)handle_bytes_write(handle));
+	} else {
+		logit("%s%sclosedir \"%s\"",
+		    emsg == NULL ? "" : emsg, emsg == NULL ? "" : " ",
+		    handle_to_name(handle));
+	}
+}
+
+static void
+handle_log_exit(void)
+{
+	u_int i;
+
+	for (i = 0; i < sizeof(handles)/sizeof(Handle); i++)
+		if (handles[i].use != HANDLE_UNUSED)
+			handle_log_close(i, "forced");
+}
+
+static int
+get_handle(void)
+{
+	char *handle;
+	int val = -1;
+	u_int hlen;
+
+	handle = get_string(&hlen);
+	if (hlen < 256)
+		val = handle_from_string(handle, hlen);
+	xfree(handle);
+	return val;
+}
+
+/* send replies */
+
+static void
+send_msg(Buffer *m)
+{
+	int mlen = buffer_len(m);
+
+	buffer_put_int(&oqueue, mlen);
+	buffer_append(&oqueue, buffer_ptr(m), mlen);
+	buffer_consume(m, mlen);
+}
+
+static const char *
+status_to_message(u_int32_t status)
+{
+	const char *status_messages[] = {
+		"Success",			/* SSH_FX_OK */
+		"End of file",			/* SSH_FX_EOF */
+		"No such file",			/* SSH_FX_NO_SUCH_FILE */
+		"Permission denied",		/* SSH_FX_PERMISSION_DENIED */
+		"Failure",			/* SSH_FX_FAILURE */
+		"Bad message",			/* SSH_FX_BAD_MESSAGE */
+		"No connection",		/* SSH_FX_NO_CONNECTION */
+		"Connection lost",		/* SSH_FX_CONNECTION_LOST */
+		"Operation unsupported",	/* SSH_FX_OP_UNSUPPORTED */
+		"Unknown error"			/* Others */
+	};
+	return (status_messages[MIN(status,SSH2_FX_MAX)]);
+}
+
+static void
+send_status(u_int32_t id, u_int32_t status)
+{
+	Buffer msg;
+
+	debug3("request %u: sent status %u", id, status);
+	if (log_level > SYSLOG_LEVEL_VERBOSE ||
+	    (status != SSH2_FX_OK && status != SSH2_FX_EOF))
+		logit("sent status %s", status_to_message(status));
+	buffer_init(&msg);
+	buffer_put_char(&msg, SSH2_FXP_STATUS);
+	buffer_put_int(&msg, id);
+	buffer_put_int(&msg, status);
+	if (version >= 3) {
+		buffer_put_cstring(&msg, status_to_message(status));
+		buffer_put_cstring(&msg, "");
+	}
+	send_msg(&msg);
+	buffer_free(&msg);
+}
+static void
+send_data_or_handle(char type, u_int32_t id, const char *data, int dlen)
+{
+	Buffer msg;
+
+	buffer_init(&msg);
+	buffer_put_char(&msg, type);
+	buffer_put_int(&msg, id);
+	buffer_put_string(&msg, data, dlen);
+	send_msg(&msg);
+	buffer_free(&msg);
+}
+
+static void
+send_data(u_int32_t id, const char *data, int dlen)
+{
+	debug("request %u: sent data len %d", id, dlen);
+	send_data_or_handle(SSH2_FXP_DATA, id, data, dlen);
+}
+
+static void
+send_handle(u_int32_t id, int handle)
+{
+	char *string;
+	int hlen;
+
+	handle_to_string(handle, &string, &hlen);
+	debug("request %u: sent handle handle %d", id, handle);
+	send_data_or_handle(SSH2_FXP_HANDLE, id, string, hlen);
+	xfree(string);
+}
+
+static void
+send_names(u_int32_t id, int count, const Stat *stats)
+{
+	Buffer msg;
+	int i;
+
+	buffer_init(&msg);
+	buffer_put_char(&msg, SSH2_FXP_NAME);
+	buffer_put_int(&msg, id);
+	buffer_put_int(&msg, count);
+	debug("request %u: sent names count %d", id, count);
+	for (i = 0; i < count; i++) {
+		buffer_put_cstring(&msg, stats[i].name);
+		buffer_put_cstring(&msg, stats[i].long_name);
+		encode_attrib(&msg, &stats[i].attrib);
+	}
+	send_msg(&msg);
+	buffer_free(&msg);
+}
+
+static void
+send_attrib(u_int32_t id, const Attrib *a)
+{
+	Buffer msg;
+
+	debug("request %u: sent attrib have 0x%x", id, a->flags);
+	buffer_init(&msg);
+	buffer_put_char(&msg, SSH2_FXP_ATTRS);
+	buffer_put_int(&msg, id);
+	encode_attrib(&msg, a);
+	send_msg(&msg);
+	buffer_free(&msg);
+}
+
+/* parse incoming */
+
+static void
+process_init(void)
+{
+	Buffer msg;
+
+	version = get_int();
+	verbose("received client version %d", version);
+	buffer_init(&msg);
+	buffer_put_char(&msg, SSH2_FXP_VERSION);
+	buffer_put_int(&msg, SSH2_FILEXFER_VERSION);
+	send_msg(&msg);
+	buffer_free(&msg);
+}
+
+static void
+process_open(void)
+{
+	u_int32_t id, pflags;
+	Attrib *a;
+	char *name;
+	int handle, fd, flags, mode, status = SSH2_FX_FAILURE;
+
+	id = get_int();
+	name = get_string(NULL);
+	pflags = get_int();		/* portable flags */
+	debug3("request %u: open flags %d", id, pflags);
+	a = get_attrib();
+	flags = flags_from_portable(pflags);
+	mode = (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a->perm : 0666;
+	logit("open \"%s\" flags %s mode 0%o",
+	    name, string_from_portable(pflags), mode);
+	fd = open(name, flags, mode);
+	if (fd < 0) {
+		status = errno_to_portable(errno);
+	} else {
+		handle = handle_new(HANDLE_FILE, name, fd, NULL);
+		if (handle < 0) {
+			close(fd);
+		} else {
+			send_handle(id, handle);
+			status = SSH2_FX_OK;
+		}
+	}
+	if (status != SSH2_FX_OK)
+		send_status(id, status);
+	xfree(name);
+}
+
+static void
+process_close(void)
+{
+	u_int32_t id;
+	int handle, ret, status = SSH2_FX_FAILURE;
+
+	id = get_int();
+	handle = get_handle();
+	debug3("request %u: close handle %u", id, handle);
+	handle_log_close(handle, NULL);
+	ret = handle_close(handle);
+	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
+	send_status(id, status);
+}
+
+static void
+process_read(void)
+{
+	char buf[64*1024];
+	u_int32_t id, len;
+	int handle, fd, ret, status = SSH2_FX_FAILURE;
+	u_int64_t off;
+
+	id = get_int();
+	handle = get_handle();
+	off = get_int64();
+	len = get_int();
+
+	debug("request %u: read \"%s\" (handle %d) off %llu len %d",
+	    id, handle_to_name(handle), handle, (unsigned long long)off, len);
+	if (len > sizeof buf) {
+		len = sizeof buf;
+		debug2("read change len %d", len);
+	}
+	fd = handle_to_fd(handle);
+	if (fd >= 0) {
+		if (lseek(fd, off, SEEK_SET) < 0) {
+			error("process_read: seek failed");
+			status = errno_to_portable(errno);
+		} else {
+			ret = read(fd, buf, len);
+			if (ret < 0) {
+				status = errno_to_portable(errno);
+			} else if (ret == 0) {
+				status = SSH2_FX_EOF;
+			} else {
+				send_data(id, buf, ret);
+				status = SSH2_FX_OK;
+				handle_update_read(handle, ret);
+			}
+		}
+	}
+	if (status != SSH2_FX_OK)
+		send_status(id, status);
+}
+
+static void
+process_write(void)
+{
+	u_int32_t id;
+	u_int64_t off;
+	u_int len;
+	int handle, fd, ret, status = SSH2_FX_FAILURE;
+	char *data;
+
+	id = get_int();
+	handle = get_handle();
+	off = get_int64();
+	data = get_string(&len);
+
+	debug("request %u: write \"%s\" (handle %d) off %llu len %d",
+	    id, handle_to_name(handle), handle, (unsigned long long)off, len);
+	fd = handle_to_fd(handle);
+	if (fd >= 0) {
+		if (lseek(fd, off, SEEK_SET) < 0) {
+			status = errno_to_portable(errno);
+			error("process_write: seek failed");
+		} else {
+/* XXX ATOMICIO ? */
+			ret = write(fd, data, len);
+			if (ret < 0) {
+				error("process_write: write failed");
+				status = errno_to_portable(errno);
+			} else if ((size_t)ret == len) {
+				status = SSH2_FX_OK;
+				handle_update_write(handle, ret);
+			} else {
+				debug2("nothing at all written");
+			}
+		}
+	}
+	send_status(id, status);
+	xfree(data);
+}
+
+static void
+process_do_stat(int do_lstat)
+{
+	Attrib a;
+	struct stat st;
+	u_int32_t id;
+	char *name;
+	int ret, status = SSH2_FX_FAILURE;
+
+	id = get_int();
+	name = get_string(NULL);
+	debug3("request %u: %sstat", id, do_lstat ? "l" : "");
+	verbose("%sstat name \"%s\"", do_lstat ? "l" : "", name);
+	ret = do_lstat ? lstat(name, &st) : stat(name, &st);
+	if (ret < 0) {
+		status = errno_to_portable(errno);
+	} else {
+		stat_to_attrib(&st, &a);
+		send_attrib(id, &a);
+		status = SSH2_FX_OK;
+	}
+	if (status != SSH2_FX_OK)
+		send_status(id, status);
+	xfree(name);
+}
+
+static void
+process_stat(void)
+{
+	process_do_stat(0);
+}
+
+static void
+process_lstat(void)
+{
+	process_do_stat(1);
+}
+
+static void
+process_fstat(void)
+{
+	Attrib a;
+	struct stat st;
+	u_int32_t id;
+	int fd, ret, handle, status = SSH2_FX_FAILURE;
+
+	id = get_int();
+	handle = get_handle();
+	debug("request %u: fstat \"%s\" (handle %u)",
+	    id, handle_to_name(handle), handle);
+	fd = handle_to_fd(handle);
+	if (fd >= 0) {
+		ret = fstat(fd, &st);
+		if (ret < 0) {
+			status = errno_to_portable(errno);
+		} else {
+			stat_to_attrib(&st, &a);
+			send_attrib(id, &a);
+			status = SSH2_FX_OK;
+		}
+	}
+	if (status != SSH2_FX_OK)
+		send_status(id, status);
+}
+
+static struct timeval *
+attrib_to_tv(const Attrib *a)
+{
+	static struct timeval tv[2];
+
+	tv[0].tv_sec = a->atime;
+	tv[0].tv_usec = 0;
+	tv[1].tv_sec = a->mtime;
+	tv[1].tv_usec = 0;
+	return tv;
+}
+
+static void
+process_setstat(void)
+{
+	Attrib *a;
+	u_int32_t id;
+	char *name;
+	int status = SSH2_FX_OK, ret;
+
+	id = get_int();
+	name = get_string(NULL);
+	a = get_attrib();
+	debug("request %u: setstat name \"%s\"", id, name);
+	if (a->flags & SSH2_FILEXFER_ATTR_SIZE) {
+		logit("set \"%s\" size %llu",
+		    name, (unsigned long long)a->size);
+		ret = truncate(name, a->size);
+		if (ret == -1)
+			status = errno_to_portable(errno);
+	}
+	if (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {
+		logit("set \"%s\" mode %04o", name, a->perm);
+		ret = chmod(name, a->perm & 0777);
+		if (ret == -1)
+			status = errno_to_portable(errno);
+	}
+	if (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {
+		char buf[64];
+		time_t t = a->mtime;
+
+		strftime(buf, sizeof(buf), "%Y%m%d-%H:%M:%S",
+		    localtime(&t));
+		logit("set \"%s\" modtime %s", name, buf);
+		ret = utimes(name, attrib_to_tv(a));
+		if (ret == -1)
+			status = errno_to_portable(errno);
+	}
+	if (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {
+		logit("set \"%s\" owner %lu group %lu", name,
+		    (u_long)a->uid, (u_long)a->gid);
+		ret = chown(name, a->uid, a->gid);
+		if (ret == -1)
+			status = errno_to_portable(errno);
+	}
+	send_status(id, status);
+	xfree(name);
+}
+
+static void
+process_fsetstat(void)
+{
+	Attrib *a;
+	u_int32_t id;
+	int handle, fd, ret;
+	int status = SSH2_FX_OK;
+
+	id = get_int();
+	handle = get_handle();
+	a = get_attrib();
+	debug("request %u: fsetstat handle %d", id, handle);
+	fd = handle_to_fd(handle);
+	if (fd < 0) {
+		status = SSH2_FX_FAILURE;
+	} else {
+		char *name = handle_to_name(handle);
+
+		if (a->flags & SSH2_FILEXFER_ATTR_SIZE) {
+			logit("set \"%s\" size %llu",
+			    name, (unsigned long long)a->size);
+			ret = ftruncate(fd, a->size);
+			if (ret == -1)
+				status = errno_to_portable(errno);
+		}
+		if (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {
+			logit("set \"%s\" mode %04o", name, a->perm);
+#ifdef HAVE_FCHMOD
+			ret = fchmod(fd, a->perm & 0777);
+#else
+			ret = chmod(name, a->perm & 0777);
+#endif
+			if (ret == -1)
+				status = errno_to_portable(errno);
+		}
+		if (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {
+			char buf[64];
+			time_t t = a->mtime;
+
+			strftime(buf, sizeof(buf), "%Y%m%d-%H:%M:%S",
+			    localtime(&t));
+			logit("set \"%s\" modtime %s", name, buf);
+#ifdef HAVE_FUTIMES
+			ret = futimes(fd, attrib_to_tv(a));
+#else
+			ret = utimes(name, attrib_to_tv(a));
+#endif
+			if (ret == -1)
+				status = errno_to_portable(errno);
+		}
+		if (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {
+			logit("set \"%s\" owner %lu group %lu", name,
+			    (u_long)a->uid, (u_long)a->gid);
+#ifdef HAVE_FCHOWN
+			ret = fchown(fd, a->uid, a->gid);
+#else
+			ret = chown(name, a->uid, a->gid);
+#endif
+			if (ret == -1)
+				status = errno_to_portable(errno);
+		}
+	}
+	send_status(id, status);
+}
+
+static void
+process_opendir(void)
+{
+	DIR *dirp = NULL;
+	char *path;
+	int handle, status = SSH2_FX_FAILURE;
+	u_int32_t id;
+
+	id = get_int();
+	path = get_string(NULL);
+	debug3("request %u: opendir", id);
+	logit("opendir \"%s\"", path);
+	dirp = opendir(path);
+	if (dirp == NULL) {
+		status = errno_to_portable(errno);
+	} else {
+		handle = handle_new(HANDLE_DIR, path, 0, dirp);
+		if (handle < 0) {
+			closedir(dirp);
+		} else {
+			send_handle(id, handle);
+			status = SSH2_FX_OK;
+		}
+
+	}
+	if (status != SSH2_FX_OK)
+		send_status(id, status);
+	xfree(path);
+}
+
+static void
+process_readdir(void)
+{
+	DIR *dirp;
+	struct dirent *dp;
+	char *path;
+	int handle;
+	u_int32_t id;
+
+	id = get_int();
+	handle = get_handle();
+	debug("request %u: readdir \"%s\" (handle %d)", id,
+	    handle_to_name(handle), handle);
+	dirp = handle_to_dir(handle);
+	path = handle_to_name(handle);
+	if (dirp == NULL || path == NULL) {
+		send_status(id, SSH2_FX_FAILURE);
+	} else {
+		struct stat st;
+		char pathname[MAXPATHLEN];
+		Stat *stats;
+		int nstats = 10, count = 0, i;
+
+		stats = xcalloc(nstats, sizeof(Stat));
+		while ((dp = readdir(dirp)) != NULL) {
+			if (count >= nstats) {
+				nstats *= 2;
+				stats = xrealloc(stats, nstats, sizeof(Stat));
+			}
+/* XXX OVERFLOW ? */
+			snprintf(pathname, sizeof pathname, "%s%s%s", path,
+			    strcmp(path, "/") ? "/" : "", dp->d_name);
+			if (lstat(pathname, &st) < 0)
+				continue;
+			stat_to_attrib(&st, &(stats[count].attrib));
+			stats[count].name = xstrdup(dp->d_name);
+			stats[count].long_name = ls_file(dp->d_name, &st, 0);
+			count++;
+			/* send up to 100 entries in one message */
+			/* XXX check packet size instead */
+			if (count == 100)
+				break;
+		}
+		if (count > 0) {
+			send_names(id, count, stats);
+			for (i = 0; i < count; i++) {
+				xfree(stats[i].name);
+				xfree(stats[i].long_name);
+			}
+		} else {
+			send_status(id, SSH2_FX_EOF);
+		}
+		xfree(stats);
+	}
+}
+
+static void
+process_remove(void)
+{
+	char *name;
+	u_int32_t id;
+	int status = SSH2_FX_FAILURE;
+	int ret;
+
+	id = get_int();
+	name = get_string(NULL);
+	debug3("request %u: remove", id);
+	logit("remove name \"%s\"", name);
+	ret = unlink(name);
+	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
+	send_status(id, status);
+	xfree(name);
+}
+
+static void
+process_mkdir(void)
+{
+	Attrib *a;
+	u_int32_t id;
+	char *name;
+	int ret, mode, status = SSH2_FX_FAILURE;
+
+	id = get_int();
+	name = get_string(NULL);
+	a = get_attrib();
+	mode = (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ?
+	    a->perm & 0777 : 0777;
+	debug3("request %u: mkdir", id);
+	logit("mkdir name \"%s\" mode 0%o", name, mode);
+	ret = mkdir(name, mode);
+	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
+	send_status(id, status);
+	xfree(name);
+}
+
+static void
+process_rmdir(void)
+{
+	u_int32_t id;
+	char *name;
+	int ret, status;
+
+	id = get_int();
+	name = get_string(NULL);
+	debug3("request %u: rmdir", id);
+	logit("rmdir name \"%s\"", name);
+	ret = rmdir(name);
+	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
+	send_status(id, status);
+	xfree(name);
+}
+
+static void
+process_realpath(void)
+{
+	char resolvedname[MAXPATHLEN];
+	u_int32_t id;
+	char *path;
+
+	id = get_int();
+	path = get_string(NULL);
+	if (path[0] == '\0') {
+		xfree(path);
+		path = xstrdup(".");
+	}
+	debug3("request %u: realpath", id);
+	verbose("realpath \"%s\"", path);
+	if (realpath(path, resolvedname) == NULL) {
+		send_status(id, errno_to_portable(errno));
+	} else {
+		Stat s;
+		attrib_clear(&s.attrib);
+		s.name = s.long_name = resolvedname;
+		send_names(id, 1, &s);
+	}
+	xfree(path);
+}
+
+static void
+process_rename(void)
+{
+	u_int32_t id;
+	char *oldpath, *newpath;
+	int status;
+	struct stat sb;
+
+	id = get_int();
+	oldpath = get_string(NULL);
+	newpath = get_string(NULL);
+	debug3("request %u: rename", id);
+	logit("rename old \"%s\" new \"%s\"", oldpath, newpath);
+	status = SSH2_FX_FAILURE;
+	if (lstat(oldpath, &sb) == -1)
+		status = errno_to_portable(errno);
+	else if (S_ISREG(sb.st_mode)) {
+		/* Race-free rename of regular files */
+		if (link(oldpath, newpath) == -1) {
+			if (errno == EOPNOTSUPP
+#ifdef LINK_OPNOTSUPP_ERRNO
+			    || errno == LINK_OPNOTSUPP_ERRNO
+#endif
+			    ) {
+				struct stat st;
+
+				/*
+				 * fs doesn't support links, so fall back to
+				 * stat+rename.  This is racy.
+				 */
+				if (stat(newpath, &st) == -1) {
+					if (rename(oldpath, newpath) == -1)
+						status =
+						    errno_to_portable(errno);
+					else
+						status = SSH2_FX_OK;
+				}
+			} else {
+				status = errno_to_portable(errno);
+			}
+		} else if (unlink(oldpath) == -1) {
+			status = errno_to_portable(errno);
+			/* clean spare link */
+			unlink(newpath);
+		} else
+			status = SSH2_FX_OK;
+	} else if (stat(newpath, &sb) == -1) {
+		if (rename(oldpath, newpath) == -1)
+			status = errno_to_portable(errno);
+		else
+			status = SSH2_FX_OK;
+	}
+	send_status(id, status);
+	xfree(oldpath);
+	xfree(newpath);
+}
+
+static void
+process_readlink(void)
+{
+	u_int32_t id;
+	int len;
+	char buf[MAXPATHLEN];
+	char *path;
+
+	id = get_int();
+	path = get_string(NULL);
+	debug3("request %u: readlink", id);
+	verbose("readlink \"%s\"", path);
+	if ((len = readlink(path, buf, sizeof(buf) - 1)) == -1)
+		send_status(id, errno_to_portable(errno));
+	else {
+		Stat s;
+
+		buf[len] = '\0';
+		attrib_clear(&s.attrib);
+		s.name = s.long_name = buf;
+		send_names(id, 1, &s);
+	}
+	xfree(path);
+}
+
+static void
+process_symlink(void)
+{
+	u_int32_t id;
+	char *oldpath, *newpath;
+	int ret, status;
+
+	id = get_int();
+	oldpath = get_string(NULL);
+	newpath = get_string(NULL);
+	debug3("request %u: symlink", id);
+	logit("symlink old \"%s\" new \"%s\"", oldpath, newpath);
+	/* this will fail if 'newpath' exists */
+	ret = symlink(oldpath, newpath);
+	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
+	send_status(id, status);
+	xfree(oldpath);
+	xfree(newpath);
+}
+
+static void
+process_extended(void)
+{
+	u_int32_t id;
+	char *request;
+
+	id = get_int();
+	request = get_string(NULL);
+	send_status(id, SSH2_FX_OP_UNSUPPORTED);		/* MUST */
+	xfree(request);
+}
+
+/* stolen from ssh-agent */
+
+static void
+process(void)
+{
+	u_int msg_len;
+	u_int buf_len;
+	u_int consumed;
+	u_int type;
+	u_char *cp;
+
+	buf_len = buffer_len(&iqueue);
+	if (buf_len < 5)
+		return;		/* Incomplete message. */
+	cp = buffer_ptr(&iqueue);
+	msg_len = get_u32(cp);
+	if (msg_len > SFTP_MAX_MSG_LENGTH) {
+		error("bad message from %s local user %s",
+		    client_addr, pw->pw_name);
+		cleanup_exit(11);
+	}
+	if (buf_len < msg_len + 4)
+		return;
+	buffer_consume(&iqueue, 4);
+	buf_len -= 4;
+	type = buffer_get_char(&iqueue);
+	switch (type) {
+	case SSH2_FXP_INIT:
+		process_init();
+		break;
+	case SSH2_FXP_OPEN:
+		process_open();
+		break;
+	case SSH2_FXP_CLOSE:
+		process_close();
+		break;
+	case SSH2_FXP_READ:
+		process_read();
+		break;
+	case SSH2_FXP_WRITE:
+		process_write();
+		break;
+	case SSH2_FXP_LSTAT:
+		process_lstat();
+		break;
+	case SSH2_FXP_FSTAT:
+		process_fstat();
+		break;
+	case SSH2_FXP_SETSTAT:
+		process_setstat();
+		break;
+	case SSH2_FXP_FSETSTAT:
+		process_fsetstat();
+		break;
+	case SSH2_FXP_OPENDIR:
+		process_opendir();
+		break;
+	case SSH2_FXP_READDIR:
+		process_readdir();
+		break;
+	case SSH2_FXP_REMOVE:
+		process_remove();
+		break;
+	case SSH2_FXP_MKDIR:
+		process_mkdir();
+		break;
+	case SSH2_FXP_RMDIR:
+		process_rmdir();
+		break;
+	case SSH2_FXP_REALPATH:
+		process_realpath();
+		break;
+	case SSH2_FXP_STAT:
+		process_stat();
+		break;
+	case SSH2_FXP_RENAME:
+		process_rename();
+		break;
+	case SSH2_FXP_READLINK:
+		process_readlink();
+		break;
+	case SSH2_FXP_SYMLINK:
+		process_symlink();
+		break;
+	case SSH2_FXP_EXTENDED:
+		process_extended();
+		break;
+	default:
+		error("Unknown message %d", type);
+		break;
+	}
+	/* discard the remaining bytes from the current packet */
+	if (buf_len < buffer_len(&iqueue))
+		fatal("iqueue grew unexpectedly");
+	consumed = buf_len - buffer_len(&iqueue);
+	if (msg_len < consumed)
+		fatal("msg_len %d < consumed %d", msg_len, consumed);
+	if (msg_len > consumed)
+		buffer_consume(&iqueue, msg_len - consumed);
+}
+
+/* Cleanup handler that logs active handles upon normal exit */
+void
+cleanup_exit(int i)
+{
+	if (pw != NULL && client_addr != NULL) {
+		handle_log_exit();
+		logit("session closed for local user %s from [%s]",
+		    pw->pw_name, client_addr);
+	}
+	_exit(i);
+}
+
+static void
+usage(void)
+{
+	extern char *__progname;
+
+	fprintf(stderr,
+	    "usage: %s [-he] [-l log_level] [-f log_facility]\n", __progname);
+	exit(1);
+}
+
+int
+main(int argc, char **argv)
+{
+	fd_set *rset, *wset;
+	int in, out, max, ch, skipargs = 0, log_stderr = 0;
+	ssize_t len, olen, set_size;
+	SyslogFacility log_facility = SYSLOG_FACILITY_AUTH;
+	char *cp, buf[4*4096];
+
+	extern char *optarg;
+	extern char *__progname;
+
+	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
+	sanitise_stdfd();
+
+	__progname = ssh_get_progname(argv[0]);
+	log_init(__progname, log_level, log_facility, log_stderr);
+
+	while (!skipargs && (ch = getopt(argc, argv, "C:f:l:che")) != -1) {
+		switch (ch) {
+		case 'c':
+			/*
+			 * Ignore all arguments if we are invoked as a
+			 * shell using "sftp-server -c command"
+			 */
+			skipargs = 1;
+			break;
+		case 'e':
+			log_stderr = 1;
+			break;
+		case 'l':
+			log_level = log_level_number(optarg);
+			if (log_level == SYSLOG_LEVEL_NOT_SET)
+				error("Invalid log level \"%s\"", optarg);
+			break;
+		case 'f':
+			log_facility = log_facility_number(optarg);
+			if (log_level == SYSLOG_FACILITY_NOT_SET)
+				error("Invalid log facility \"%s\"", optarg);
+			break;
+		case 'h':
+		default:
+			usage();
+		}
+	}
+
+	log_init(__progname, log_level, log_facility, log_stderr);
+
+	if ((cp = getenv("SSH_CONNECTION")) != NULL) {
+		client_addr = xstrdup(cp);
+		if ((cp = strchr(client_addr, ' ')) == NULL)
+			fatal("Malformed SSH_CONNECTION variable: \"%s\"",
+			    getenv("SSH_CONNECTION"));
+		*cp = '\0';
+	} else
+		client_addr = xstrdup("UNKNOWN");
+
+	if ((pw = getpwuid(getuid())) == NULL)
+		fatal("No user found for uid %lu", (u_long)getuid());
+	pw = pwcopy(pw);
+
+	logit("session opened for local user %s from [%s]",
+	    pw->pw_name, client_addr);
+
+	handle_init();
+
+	in = dup(STDIN_FILENO);
+	out = dup(STDOUT_FILENO);
+
+#ifdef HAVE_CYGWIN
+	setmode(in, O_BINARY);
+	setmode(out, O_BINARY);
+#endif
+
+	max = 0;
+	if (in > max)
+		max = in;
+	if (out > max)
+		max = out;
+
+	buffer_init(&iqueue);
+	buffer_init(&oqueue);
+
+	set_size = howmany(max + 1, NFDBITS) * sizeof(fd_mask);
+	rset = (fd_set *)xmalloc(set_size);
+	wset = (fd_set *)xmalloc(set_size);
+
+	for (;;) {
+		memset(rset, 0, set_size);
+		memset(wset, 0, set_size);
+
+		/*
+		 * Ensure that we can read a full buffer and handle
+		 * the worst-case length packet it can generate,
+		 * otherwise apply backpressure by stopping reads.
+		 */
+		if (buffer_check_alloc(&iqueue, sizeof(buf)) &&
+		    buffer_check_alloc(&oqueue, SFTP_MAX_MSG_LENGTH))
+			FD_SET(in, rset);
+
+		olen = buffer_len(&oqueue);
+		if (olen > 0)
+			FD_SET(out, wset);
+
+		if (select(max+1, rset, wset, NULL, NULL) < 0) {
+			if (errno == EINTR)
+				continue;
+			error("select: %s", strerror(errno));
+			cleanup_exit(2);
+		}
+
+		/* copy stdin to iqueue */
+		if (FD_ISSET(in, rset)) {
+			len = read(in, buf, sizeof buf);
+			if (len == 0) {
+				debug("read eof");
+				cleanup_exit(0);
+			} else if (len < 0) {
+				error("read: %s", strerror(errno));
+				cleanup_exit(1);
+			} else {
+				buffer_append(&iqueue, buf, len);
+			}
+		}
+		/* send oqueue to stdout */
+		if (FD_ISSET(out, wset)) {
+			len = write(out, buffer_ptr(&oqueue), olen);
+			if (len < 0) {
+				error("write: %s", strerror(errno));
+				cleanup_exit(1);
+			} else {
+				buffer_consume(&oqueue, len);
+			}
+		}
+
+		/*
+		 * Process requests from client if we can fit the results
+		 * into the output buffer, otherwise stop processing input
+		 * and let the output queue drain.
+		 */
+		if (buffer_check_alloc(&oqueue, SFTP_MAX_MSG_LENGTH))
+			process();
+	}
+}
diff --git a/sftp.c b/sftp.c
index ab667f5..aa8501f 100644
--- a/sftp.c
+++ b/sftp.c
@@ -71,6 +71,16 @@ typedef void EditLine;
 #define DEFAULT_COPY_BUFLEN	32768	/* Size of buffer for up/download */
 #define DEFAULT_NUM_REQUESTS	64	/* # concurrent outstanding requests */
 
+#ifdef NX_WIN32_FIXME
+  
+  #define mkdir(a, b) _mkdir(a)
+
+  #define FAIL(X) if (X) goto fail
+
+  extern int sfd_start;
+  
+#endif
+
 /* File to read commands from */
 FILE* infile;
 
@@ -263,6 +273,20 @@ help(void)
 static void
 local_do_shell(const char *args)
 {
+  #ifdef NX_WIN32_FIXME
+
+  /*
+   * Not implemented on native Win32.
+   */
+  
+  fprintf(stderr, "Local shell is not implemented on Win32.\n");
+  
+  #else
+  
+  /*
+   * Original OpenSSH code.
+   */
+  
 	int status;
 	char *shell;
 	pid_t pid;
@@ -296,6 +320,8 @@ local_do_shell(const char *args)
 		error("Shell exited abnormally");
 	else if (WEXITSTATUS(status))
 		error("Shell exited with status %d", WEXITSTATUS(status));
+
+  #endif
 }
 
 static void
@@ -720,8 +746,10 @@ do_ls_dir(struct sftp_conn *conn, char *path, char *strip_path, int lflag)
 		m += strlen(tmp);
 		xfree(tmp);
 
+#ifndef NX_WIN32_FIXME
 		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)
 			width = ws.ws_col;
+#endif
 
 		columns = width / (m + 2);
 		columns = MAX(columns, 1);
@@ -815,8 +843,10 @@ do_globbed_ls(struct sftp_conn *conn, char *path, char *strip_path,
 		return err;
 	}
 
+#ifndef NX_WIN32_FIXME
 	if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)
 		width = ws.ws_col;
+#endif
 
 	if (!(lflag & LS_SHORT_VIEW)) {
 		/* Count entries for sort and find longest filename */
@@ -2006,6 +2036,183 @@ interactive_loop(struct sftp_conn *conn, char *file1, char *file2)
 static void
 connect_to_server(char *path, char **args, int *in, int *out)
 {
+  #ifdef NX_WIN32_FIXME
+  
+    /*
+     * Win32 code.
+     */
+  
+    int exitCode = -1;
+    
+    int sockin[2]  = {-1, -1};
+    int sockout[2] = {-1, -1};
+    
+    HANDLE childInput  = NULL;
+    HANDLE childOutput = NULL;
+
+    int i = 0;
+  
+    char fullCmd[MAX_PATH] = {0};
+
+    char ioArg[1024] = {0};
+    
+    PROCESS_INFORMATION pi = {0};
+  
+    STARTUPINFO si = {0};
+
+    /*
+     * Create socket pairs to communicate with child ssh process.
+     */
+
+    debug3("Creating socket pairs for child ssh process...");
+
+    socketpair(sockin);
+    socketpair(sockout);
+    
+    debug3("sockin[0]: %d sockin[1]: %d", sockin[0], sockin[1]);
+    debug3("sockout[0]: %d sockout[1]: %d", sockout[0], sockout[1]);
+    
+    /*
+     * Forbid inheritance of parent's side sockets.
+     */
+
+    debug3("Clearing INHERIT flag on parent side sockets...\n");
+
+    FAIL(SetHandleInformation(sfd_to_handle(sockout[1]),
+                                  HANDLE_FLAG_INHERIT, 0) == FALSE);
+
+    FAIL(SetHandleInformation(sfd_to_handle(sockin[0]),
+                                  HANDLE_FLAG_INHERIT, 0) == FALSE);
+
+    /*
+     * Duplicate sockets for child process.
+     */
+     
+    
+    debug3("Duplicating stdin sockets for child ssh process...\n");
+
+    /*
+    FAIL(DuplicateHandle(GetCurrentProcess(), sfd_to_handle(sockout[0]),
+                             GetCurrentProcess(), &childInput, 0, 
+                                 TRUE, DUPLICATE_SAME_ACCESS) == FALSE);
+
+    debug3("Duplicating stdout sockets for child ssh process...\n");
+    
+    FAIL(DuplicateHandle(GetCurrentProcess(), sfd_to_handle(sockin[1]),
+                             GetCurrentProcess(), &childOutput, 0, 
+                                 TRUE, DUPLICATE_SAME_ACCESS) == FALSE);
+    */
+
+    FAIL(DuplicateHandle(GetCurrentProcess(), sfd_to_handle(STDIN_FILENO),
+                             GetCurrentProcess(), &childInput, 0, 
+                                 TRUE, DUPLICATE_SAME_ACCESS) == FALSE);
+
+    debug3("Duplicating stdout sockets for child ssh process...\n");
+    
+    FAIL(DuplicateHandle(GetCurrentProcess(), sfd_to_handle(STDOUT_FILENO),
+                             GetCurrentProcess(), &childOutput, 0,
+                                 TRUE, DUPLICATE_SAME_ACCESS) == FALSE);
+    
+    
+    //childInput  = sfd_to_handle(STDIN_FILENO);
+    //childOutput = sfd_to_handle(STDOUT_FILENO);
+    
+    /*
+     * Create command to run ssh-client.
+     */
+     
+    debug3("Generating ssh-client command...");
+    
+    strncat(fullCmd, path, MAX_PATH);
+    
+    //sprintf(ioArg, " -oPassInputHandle=%d -oPassOutputHandle=%d", 
+    //            childInput, childOutput);
+                
+//                sfd_to_handle(sockout[0]), sfd_to_handle(sockin[1]));
+                
+    //strncat(fullCmd, ioArg, MAX_PATH);                
+    
+    
+    for (i = 1; args[i]; i++)
+    {
+      strncat(fullCmd, " ", MAX_PATH);
+      strncat(fullCmd, args[i], MAX_PATH);
+    }
+
+    /*
+     * Assign sockets to StartupInfo.
+     */
+     
+    si.cb          = sizeof(STARTUPINFO);
+    si.hStdInput   = sfd_to_handle(sockout[0]);
+    si.hStdOutput  = sfd_to_handle(sockin[1]);//GetStdHandle(STD_OUTPUT_HANDLE);//sfd_to_handle(sockin[1]);
+    si.hStdError   = GetStdHandle(STD_ERROR_HANDLE);
+    si.wShowWindow = SW_HIDE;
+    si.dwFlags     = STARTF_USESTDHANDLES;
+    si.lpDesktop   = NULL;
+
+    /*               
+     * Create child ssh process with given stdout/stdin.
+     */
+    
+    debug("Executing ssh client: \"%.500s\"...\n", fullCmd);
+
+    FAIL(CreateProcess(NULL, fullCmd, NULL, NULL, TRUE,
+                           NORMAL_PRIORITY_CLASS, NULL, 
+                               NULL, &si, &pi) == FALSE);
+
+    /*
+     * Return parent side of socket.
+     */
+     
+    *out = sockout[1];
+    *in  = sockin[0];
+     
+    //write(*out, "dupa", 4);
+    
+    /*
+     * Clean up.
+     */
+     
+    exitCode = 0;
+    
+    fail:
+  
+    if (exitCode)
+    {
+      error("ERROR. Cannot create ssh client process."
+                " Error code is: %u.\n", GetLastError());
+    
+      /*
+       * Clean parent's side resources on error.
+       */
+      
+      close(sockin[0]);
+      close(sockout[1]);
+      
+      CloseHandle(pi.hProcess);      
+    }
+    
+    /*
+     * Close child's side resources.
+     */
+     
+    close(sockout[0]);
+    close(sockin[1]);
+
+    //CloseHandle(childInput);
+    //CloseHandle(childOutput);
+
+    CloseHandle(pi.hThread);
+    
+    return;
+      
+  #else
+  
+  /*
+   * Original OpenSSH code.
+   */
+
 	int c_in, c_out;
 
 #ifdef USE_PIPES
@@ -2058,6 +2265,8 @@ connect_to_server(char *path, char **args, int *in, int *out)
 	signal(SIGHUP, killchild);
 	close(c_in);
 	close(c_out);
+
+  #endif
 }
 
 static void
@@ -2097,6 +2306,60 @@ main(int argc, char **argv)
 	size_t num_requests = DEFAULT_NUM_REQUESTS;
 	long long limit_kbps = 0;
 
+  #ifdef NX_WIN32_FIXME
+
+    /*
+     * Initialize I/O wrappers.
+     */
+     
+    WSHELPinitialize();
+    
+    allocate_standard_descriptor(STDIN_FILENO);
+    allocate_standard_descriptor(STDOUT_FILENO);
+    allocate_standard_descriptor(STDERR_FILENO);
+    
+    LoadLibrary("exchndl.dll");
+    
+    //sfd_start = 3;
+    
+    /*
+     *  FIXME. Test.
+     */
+    
+    /*
+    
+    memset(&args, '\0', sizeof(args));
+    
+    args.list = NULL;
+    
+    addargs(&args, "%s", ssh_program);
+
+    addargs(&args, "-i test_rsa -s dzik@10.0.0.6 sftp");
+
+    connect_to_server(ssh_program, args.list, &in, &out);    
+    
+    conn = do_init(in, out, 32768, 64, 0);
+
+    if (conn == NULL)
+    {
+      fatal("Couldn't initialise connection to server");
+    }  
+
+    //err = interactive_loop(conn, NULL, NULL);
+    //do_download(conn, "/home/dzik/unity_run", "c:/tmp/unity_run", NULL, 0);
+    
+    do_ls_dir(conn, "/home/dzik", "", 0);
+    
+    exit(0);
+    
+    */
+    
+    /*
+     *  End of test.
+     */    
+    
+  #endif
+
 	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
 	sanitise_stdfd();
 
@@ -2104,11 +2367,23 @@ main(int argc, char **argv)
 	memset(&args, '\0', sizeof(args));
 	args.list = NULL;
 	addargs(&args, "%s", ssh_program);
+  
+  #ifdef NX_WIN32_FIXME
+
+    addargs(&args, "-oForwardX11=no");
+    addargs(&args, "-oForwardAgent=no");
+    addargs(&args, "-oPermitLocalCommand=no");
+    addargs(&args, "-oClearAllForwardings=yes");
+  
+  #else
+  
 	addargs(&args, "-oForwardX11 no");
 	addargs(&args, "-oForwardAgent no");
 	addargs(&args, "-oPermitLocalCommand no");
 	addargs(&args, "-oClearAllForwardings yes");
 
+  #endif
+
 	ll = SYSLOG_LEVEL_INFO;
 	infile = stdin;
 
@@ -2134,7 +2409,17 @@ main(int argc, char **argv)
 			addargs(&args, "-%c", ch);
 			break;
 		case 'P':
+      
+      #ifdef NX_WIN32_FIXME
+      
+      addargs(&args, "-oPort=%s", optarg);      
+      
+      #else
+
 			addargs(&args, "-oPort %s", optarg);
+
+      #endif
+      
 			break;
 		case 'v':
 			if (debug_level < 3) {
@@ -2166,7 +2451,17 @@ main(int argc, char **argv)
 				fatal("%s (%s).", strerror(errno), optarg);
 			showprogress = 0;
 			batchmode = 1;
+
+      #ifdef NX_WIN32_FIXME
+
+      addargs(&args, "-obatchmode=yes");
+      
+      #else
+
 			addargs(&args, "-obatchmode yes");
+      
+      #endif
+      
 			break;
 		case 'p':
 			global_pflag = 1;
@@ -2238,7 +2533,15 @@ main(int argc, char **argv)
 			usage();
 		}
 
+    #ifdef NX_WIN32_FIXME
+
+    addargs(&args, "-oProtocol=%d", sshver);
+    
+    #else
+
 		addargs(&args, "-oProtocol %d", sshver);
+ 
+    #endif
 
 		/* no subsystem if the server-spec contains a '/' */
 		if (sftp_server == NULL || strchr(sftp_server, '/') == NULL)
@@ -2253,12 +2556,13 @@ main(int argc, char **argv)
 	} else {
 		args.list = NULL;
 		addargs(&args, "sftp-server");
-
+    
 		connect_to_server(sftp_direct, args.list, &in, &out);
 	}
 	freeargs(&args);
-
+    
 	conn = do_init(in, out, copy_buffer_len, num_requests, limit_kbps);
+
 	if (conn == NULL)
 		fatal("Couldn't initialise connection to server");
 
@@ -2268,7 +2572,7 @@ main(int argc, char **argv)
 		else
 			fprintf(stderr, "Attached to %s.\n", sftp_direct);
 	}
-
+  
 	err = interactive_loop(conn, file1, file2);
 
 #if !defined(USE_PIPES)
diff --git a/ssh-add.c b/ssh-add.c
index 6d5e2a9..eda4abf 100644
--- a/ssh-add.c
+++ b/ssh-add.c
@@ -385,6 +385,18 @@ main(int argc, char **argv)
 	char *pkcs11provider = NULL;
 	int i, ch, deleting = 0, ret = 0;
 
+  #ifdef NX_WIN32_FIXME
+    
+    /*
+     * Allocate stdio inside our wrapper function.
+     */
+     
+    allocate_standard_descriptor(STDIN_FILENO);
+    allocate_standard_descriptor(STDOUT_FILENO);
+    allocate_standard_descriptor(STDERR_FILENO);
+
+  #endif
+
 	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
 	sanitise_stdfd();
 
diff --git a/ssh-agent.c b/ssh-agent.c
index b9498e6..002208a 100644
--- a/ssh-agent.c
+++ b/ssh-agent.c
@@ -137,6 +137,290 @@ extern char *__progname;
 /* Default lifetime (0 == forever) */
 static int lifetime = 0;
 
+#ifdef NX_WIN32_FIXME
+
+  #include <windows.h>
+  #include <tlhelp32.h>
+  
+  #undef   NX_DEBUG
+  
+  #ifdef NX_DEBUG
+    #define DBG_MSG(...) fprintf(stderr, __VA_ARGS__)
+  #else
+    #define DBG_MSG(...)
+  #endif
+
+  #define FAIL(X) if (X) goto fail
+  
+  /*
+   * This flag is setted for child processes only (fake fork).
+   */
+  
+  static int InsideChild = 0;
+  
+  /*
+   * Save args for forked child.
+   */
+   
+  static int ArgsCount = 0;
+
+  static char **ArgsVector = NULL;
+  
+  static int Socket = -1;
+
+  /*
+   * We create full path to directory, where socket files will be stored.
+   *
+   * buf     - buffer, where to store path. (OUT)
+   * bufSize - size of output buffer. (IN)
+   */
+   
+  void GetSocketDir(char *buf, int bufSize)
+  {
+    if (bufSize > 0 && buf)
+    {
+      buf[0] = 0;
+      
+      strncat(buf, getenv("HOMEDRIVE"), bufSize);
+      strncat(buf, getenv("HOMEPATH"), bufSize);
+      strncat(buf, "/.ssh", bufSize);
+    
+      /*
+       * Make sure does path already exist.
+       */
+     
+      CreateDirectory(buf, NULL);
+    }
+  }
+    
+  /*
+   * Iterate all socket files and delete if unused by anyone.
+   * This is workaround for bad scenarios like hardware failure
+   * or terminate ssh-agent by third-part process.
+   */
+   
+  int CleanUpSocketFiles()
+  {
+    int exitCode = -1;
+  
+    HANDLE hFind = INVALID_HANDLE_VALUE;
+
+    WIN32_FIND_DATA ffd;
+
+    char path[MAX_PATH] = {0};
+    char mask[MAX_PATH] = {0};
+  
+    int pathSize = 0;
+
+    /*
+     * Generate path, where socket files stored.
+     */
+   
+    sprintf(path, "%s%s\\.ssh\\", getenv("HOMEDRIVE"), getenv("HOMEPATH"));
+  
+    pathSize = strlen(path);
+  
+    sprintf(mask, "%sagent-*", path);
+
+    /*
+     * Find first socket file.
+     */
+  
+    hFind = FindFirstFile(mask, &ffd);
+  
+    FAIL(hFind == INVALID_HANDLE_VALUE);
+
+    /*
+     * Delete unused socket files.
+     */
+   
+    do
+    {
+      strcpy(path + pathSize, ffd.cFileName);
+      
+      if (DeleteFile(path))
+      {
+        DBG_MSG("Socket file [%s] deleted.\n", path);
+      }
+    } while (FindNextFile(hFind, &ffd));
+
+    FAIL(GetLastError() != ERROR_NO_MORE_FILES);
+  
+    /*
+     * Error handler.
+     */
+     
+    exitCode = 0;
+
+    fail:
+
+    FindClose(hFind);
+
+    if (exitCode)
+    {
+      DBG_MSG("ERROR. Cannot clean up socket files."
+                  " Error code is %u.\n", GetLastError());
+    }
+  
+    return exitCode;
+  }
+
+  /*
+   * Terminate process, used for kill forked child.
+   *
+   * pid    - ProcessId retrieved from CreateProcess (IN)
+   * unused - For compatibility with linux kill only.
+   *
+   * RETURNS: 0 if OK.
+   */
+   
+  static int kill(int pid, int unused)
+  {
+    int exitCode = -1;
+    
+    HANDLE hProcess = NULL;
+    
+    /*
+     * Send SIGINT first.
+     */
+     
+    if (GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT, pid) == FALSE)
+    {
+      DBG_MSG("WARNING. Cannot send exit signal to child [%u]. "
+                  "Error code is %u.\n", pid, (unsigned int) GetLastError());
+
+      /*
+       * Cannot send SIGINT, terminate.
+       */
+      
+      DBG_MSG("Opening child process [pid = %u]...\n");
+      
+      hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
+
+      FAIL(hProcess == NULL);
+
+      DBG_MSG("Terminating child process [pid = %u]...\n", pid);
+      
+      FAIL(TerminateProcess(hProcess, 0) == FALSE);
+      
+      CleanUpSocketFiles();
+    }
+    
+    exitCode = 0;
+  
+    fail:
+    
+    return exitCode;
+  }
+  
+  /*
+   * This is fake fork for Windows. It creates child ssh-agent
+   * process with '-f' flag for make difference between child
+   * and parent. 
+   *
+   * RETURNS: 0 if already inside children. (Do nothing in this case).
+   *          Pid of new, created process, elsewhere.
+   */
+
+  static int fork()
+  {
+    /*
+     * Already inside child. Do nothing, return 0 like POSIX fork() does.
+     */
+
+    if (InsideChild)
+    {
+      return 0;
+    }
+
+    /*
+     * Creates new child.
+     */
+     
+    else
+    {
+      STARTUPINFO si = {0};
+
+      PROCESS_INFORMATION pi = {0};
+  
+      char cmd[MAX_PATH + 64] = {0};
+      
+      int i = 0;
+      
+      /*
+       * Prepare command for run forked child. Copy args 
+       * from parrent.
+       */
+       
+      for (i = 0; i < ArgsCount; i++)
+      {
+        strncat(cmd, ArgsVector[i], sizeof(cmd));
+        strncat(cmd, " ", sizeof(cmd));
+      }
+      
+      /*
+       * Add '-f' to existing args to signal that is child process.
+       */
+       
+      strncat(cmd, "-f ", sizeof(cmd));
+      
+      /*
+       * Give name of socket file. Note that, parent doesn't create socket
+       * on Windows, but only generate name for it and pass it to child.
+       */
+      
+      strncat(cmd, "-a \"", sizeof(cmd));
+      strncat(cmd, socket_name, sizeof(cmd));
+      strncat(cmd, "\"", sizeof(cmd));
+      
+      /*
+       * Create child process.
+       */
+
+      si.cb = sizeof(STARTUPINFO);
+      
+      DBG_MSG("Creating child process [cmd = %s]...\n", cmd);
+      
+      FAIL(CreateProcess(NULL, cmd, NULL, NULL, TRUE, 
+                             NORMAL_PRIORITY_CLASS | CREATE_NEW_PROCESS_GROUP,
+                                 NULL, NULL, &si, &pi) == FALSE);
+  
+      DBG_MSG("Child created with PID = %u.\n", pi.dwProcessId);
+      
+      return pi.dwProcessId;
+    }
+  
+    /*
+     * Error handler.
+     */
+     
+    fail:
+  
+    DBG_MSG("ERROR. Cannot create child process. Exit code is %u.\n", 
+                (unsigned int) GetLastError());
+    
+    return -1;  
+  }
+  
+  /*
+   * This function handles SIGINT signal.
+   */
+
+  BOOL WINAPI CtrlHandlerRoutine(DWORD dwCtrlType)
+  {
+    DBG_MSG("Exit signal received...\n");
+
+    cleanup_exit(0);
+
+    /*
+     * For make compiler happy only.
+     */
+     
+    return TRUE;
+  }
+ 
+#endif
+
 static void
 close_socket(SocketEntry *e)
 {
@@ -1070,6 +1354,14 @@ after_select(fd_set *readset, fd_set *writeset)
 static void
 cleanup_socket(void)
 {
+  #ifdef NX_WIN32_FIXME
+
+  close(Socket);
+  
+  CleanUpSocketFiles();
+  
+  #endif
+
 	if (socket_name[0])
 		unlink(socket_name);
 	if (socket_dir[0])
@@ -1097,6 +1389,7 @@ cleanup_handler(int sig)
 static void
 check_parent_exists(void)
 {
+#ifndef NX_WIN32_FIXME
 	/*
 	 * If our parent has exited then getppid() will return (pid_t)1,
 	 * so testing for that should be safe.
@@ -1106,6 +1399,7 @@ check_parent_exists(void)
 		cleanup_socket();
 		_exit(2);
 	}
+#endif
 }
 
 static void
@@ -1143,6 +1437,39 @@ main(int ac, char **av)
 	struct timeval *tvp = NULL;
 	size_t len;
 
+  #ifdef NX_WIN32_FIXME
+
+    /*
+     * Save oryginal arguments for forked child.
+     */
+
+    ArgsCount  = ac;
+    ArgsVector = av;
+    
+    int f_flag = 0;
+    
+    /*
+     * Random numbers needed to generate cokie.
+     */
+     
+    srand(time(0));
+
+    /*
+     * Handler for clean up socket file.
+     */
+     
+    SetConsoleCtrlHandler(CtrlHandlerRoutine, TRUE);
+    
+    /*
+     * Allocate stdio inside our wrapper function.
+     */
+     
+    allocate_standard_descriptor(STDIN_FILENO);
+    allocate_standard_descriptor(STDOUT_FILENO);
+    allocate_standard_descriptor(STDERR_FILENO);
+
+  #endif
+
 	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
 	sanitise_stdfd();
 
@@ -1160,7 +1487,7 @@ main(int ac, char **av)
 	__progname = ssh_get_progname(av[0]);
 	seed_rng();
 
-	while ((ch = getopt(ac, av, "cdksa:t:")) != -1) {
+	while ((ch = getopt(ac, av, "cdksa:t:f")) != -1) {
 		switch (ch) {
 		case 'c':
 			if (s_flag)
@@ -1189,6 +1516,26 @@ main(int ac, char **av)
 				usage();
 			}
 			break;
+
+    #ifdef NX_WIN32_FIXME
+    
+    /*
+     * -f means forked process. Used to difference parent and childs.
+     */
+     
+    case 'f':
+    {
+      DBG_MSG("Hello from children [PID = %u]...\n", GetCurrentProcessId());
+      
+      InsideChild = 1;
+      
+      f_flag++;
+      
+      break;
+    }
+    
+    #endif
+
 		default:
 			usage();
 		}
@@ -1196,7 +1543,12 @@ main(int ac, char **av)
 	ac -= optind;
 	av += optind;
 
-	if (ac > 0 && (c_flag || k_flag || s_flag || d_flag))
+	if (ac > 0 && (c_flag || k_flag || s_flag || d_flag
+  #ifdef NX_WIN32_FIXME
+         || f_flag
+  #endif       
+  ))
+  
 		usage();
 
 	if (ac == 0 && !c_flag && !s_flag) {
@@ -1234,6 +1586,20 @@ main(int ac, char **av)
 	parent_pid = getpid();
 
 	if (agentsocket == NULL) {
+
+#ifdef NX_WIN32_FIXME
+    
+    /*
+     * On Windows we store sockets in "$HOME/.ssh/".
+     */
+   
+     GetSocketDir(socket_dir, sizeof(socket_dir));
+  
+     snprintf(socket_name, sizeof socket_name, "%s/agent-%d.%d", 
+                  socket_dir, rand(), parent_pid);
+   
+#else              
+
 		/* Create private directory for agent socket */
 		mktemp_proto(socket_dir, sizeof(socket_dir));
 		if (mkdtemp(socket_dir) == NULL) {
@@ -1242,6 +1608,7 @@ main(int ac, char **av)
 		}
 		snprintf(socket_name, sizeof socket_name, "%s/agent.%ld", socket_dir,
 		    (long)parent_pid);
+#endif /* else NX_WIN32_FIXME */
 	} else {
 		/* Try to use specified agent socket */
 		socket_dir[0] = '\0';
@@ -1252,7 +1619,30 @@ main(int ac, char **av)
 	 * Create socket early so it will exist before command gets run from
 	 * the parent.
 	 */
+
+#ifdef NX_WIN32_FIXME
+
+  /*
+   * On Windows parent process only generate name for socket file. Socket
+   * is realy created in child process.
+   *
+   * d_flag means debug mode. In this case there is no child process, all
+   * work is done in parent, so we creates socket too.
+   */
+ 
+  if (InsideChild || d_flag)
+  {
+  
+#endif /* !NX_WIN32_FIXME */
+
 	sock = socket(AF_UNIX, SOCK_STREAM, 0);
+
+#ifdef NX_WIN32_FIXME
+    
+  Socket = sock;
+  
+#endif /* !NX_WIN32_FIXME */
+
 	if (sock < 0) {
 		perror("socket");
 		*socket_name = '\0'; /* Don't unlink any existing file */
@@ -1274,13 +1664,23 @@ main(int ac, char **av)
 		cleanup_exit(1);
 	}
 
+#ifdef NX_WIN32_FIXME
+  }
+#endif
+
 	/*
 	 * Fork, and have the parent execute the command, if any, or present
 	 * the socket data.  The child continues as the authentication agent.
 	 */
 	if (d_flag) {
 		log_init(__progname, SYSLOG_LEVEL_DEBUG1, SYSLOG_FACILITY_AUTH, 1);
+
+#ifdef NX_WIN32_FIXME
+    format = c_flag ? "setenv %s %s;\n" : "set %s=%s\n";    
+#else
 		format = c_flag ? "setenv %s %s;\n" : "%s=%s; export %s;\n";
+#endif
+
 		printf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,
 		    SSH_AUTHSOCKET_ENV_NAME);
 		printf("echo Agent pid %ld;\n", (long)parent_pid);
@@ -1295,7 +1695,13 @@ main(int ac, char **av)
 		close(sock);
 		snprintf(pidstrbuf, sizeof pidstrbuf, "%ld", (long)pid);
 		if (ac == 0) {
+
+#ifdef NX_WIN32_FIXME
+      format = c_flag ? "setenv %s %s;\n" : "set %s=%s\n";
+#else
 			format = c_flag ? "setenv %s %s;\n" : "%s=%s; export %s;\n";
+#endif
+
 			printf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,
 			    SSH_AUTHSOCKET_ENV_NAME);
 			printf(format, SSH_AGENTPID_ENV_NAME, pidstrbuf,
@@ -1308,17 +1714,25 @@ main(int ac, char **av)
 			perror("setenv");
 			exit(1);
 		}
+
+#ifdef NX_WIN32_FIXME
+   _execvp((const char *) av[0], (const char **) av);
+#else
 		execvp(av[0], av);
+#endif
+
 		perror(av[0]);
 		exit(1);
 	}
 	/* child */
 	log_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);
 
+#ifndef NX_WIN32_FIXME
 	if (setsid() == -1) {
 		error("setsid: %s", strerror(errno));
 		cleanup_exit(1);
 	}
+#endif
 
 	(void)chdir("/");
 	if ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {
@@ -1348,11 +1762,15 @@ skip:
 	if (ac > 0)
 		parent_alive_interval = 10;
 	idtab_init();
+
+#ifndef NX_WIN32_FIXME
 	if (!d_flag)
 		signal(SIGINT, SIG_IGN);
 	signal(SIGPIPE, SIG_IGN);
 	signal(SIGHUP, cleanup_handler);
 	signal(SIGTERM, cleanup_handler);
+#endif
+
 	nalloc = 0;
 
 	while (1) {
diff --git a/ssh-gss.h b/ssh-gss.h
index c29a1b7..f9dcd13 100644
--- a/ssh-gss.h
+++ b/ssh-gss.h
@@ -28,6 +28,10 @@
 
 #ifdef GSSAPI
 
+#ifdef NX_WIN32_FIXME
+#  include "kfwfix.h"
+#endif
+
 #ifdef HAVE_GSSAPI_H
 #include <gssapi.h>
 #elif defined(HAVE_GSSAPI_GSSAPI_H)
diff --git a/ssh-keygen.c b/ssh-keygen.c
index 4b6218b..5c74666 100644
--- a/ssh-keygen.c
+++ b/ssh-keygen.c
@@ -51,6 +51,11 @@
 #include "ssh2.h"
 #include "ssh-pkcs11.h"
 
+/* NX */
+#ifdef NX_WIN32_FIXME
+#define mkdir(a, b) _mkdir(a)
+#endif
+
 /* Number of bits in the RSA/DSA key.  This value can be set on the command line. */
 #define DEFAULT_BITS		2048
 #define DEFAULT_BITS_DSA	1024
@@ -969,6 +974,16 @@ printhost(FILE *f, const char *name, Key *public, int ca, int hash)
 static void
 do_known_hosts(struct passwd *pw, const char *name)
 {
+  #ifdef NX_WIN32_FIXME
+  
+  /*
+   * Not implemented on Win32 yet.
+   */
+   
+  fatal("Unimplemented");
+
+  #else
+
 	FILE *in, *out = stdout;
 	Key *pub;
 	char *cp, *cp2, *kp, *kp2;
@@ -1168,6 +1183,8 @@ do_known_hosts(struct passwd *pw, const char *name)
 	}
 
 	exit(0);
+
+  #endif /* else NX_WIN32_FIXME */
 }
 
 /*
@@ -1934,6 +1951,95 @@ main(int argc, char **argv)
 	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
 	sanitise_stdfd();
 
+  #ifdef NX_WIN32_FIXME
+  
+    /*
+     * Init wrapped stdio.
+     */
+     
+    WSHELPinitialize();
+    
+    allocate_standard_descriptor(STDIN_FILENO);
+    allocate_standard_descriptor(STDOUT_FILENO);
+    allocate_standard_descriptor(STDERR_FILENO);
+  
+    /*
+     * -rand option used for generate random password.
+     */
+     
+    if ((argc == 2) && ((strncmp(argv[1], "-rand", 5) == 0)))
+    {
+      BIO *out = BIO_new(BIO_s_file());
+      
+      if (out == NULL)
+      {
+        printf("Main: ERROR! Failed to create a new BIO for out.\n");
+        
+        if (out)
+        {
+          BIO_free_all(out);
+        }
+        
+        exit(1);
+      }
+ 
+      int r = BIO_set_fp(out, stdout, BIO_NOCLOSE | BIO_FP_TEXT);
+
+      if (r <= 0)
+      {
+        printf("Main: ERROR! Failed to set stdout for out.\n");
+      
+        if (out)
+        {
+          BIO_free_all(out);
+        }
+        
+        exit(1);
+      }
+
+      BIO *b64 = BIO_new(BIO_f_base64());
+
+      if (b64 == NULL)
+      {
+        printf("Main: ERROR! Failed to create a new BIO for b64.\n");
+ 
+        if (out)
+        {
+          BIO_free_all(out);
+        }
+        
+        exit(1);
+      }
+    
+      out = BIO_push(b64, out);
+
+      unsigned char buf[4096];
+      
+      int num = 8;
+    
+      r = RAND_bytes(buf, num);
+      
+      if (r <= 0)
+      {
+        printf("Main: ERROR! Failed to generate random bytes.\n");
+      
+        if (out)
+        {
+          BIO_free_all(out);
+        }
+        
+        exit(1);
+      }
+   
+      BIO_write(out, buf, num);
+
+      (void) BIO_flush(out);
+    
+      exit(0);
+    }
+
+  #endif
+
 	__progname = ssh_get_progname(argv[0]);
 
 	OpenSSL_add_all_algorithms();
@@ -1948,8 +2054,23 @@ main(int argc, char **argv)
 		exit(1);
 	}
 	if (gethostname(hostname, sizeof(hostname)) < 0) {
+
+  #ifdef NX_WIN32_FIXME
+    
+    DWORD local_len = sizeof(hostname);
+    
+    if (!GetComputerNameA(hostname, &local_len))
+    {
+  
+  #endif
+  
 		perror("gethostname");
 		exit(1);
+
+  #ifdef NX_WIN32_FIXME
+    }
+  #endif
+
 	}
 
 	while ((opt = getopt(argc, argv, "AegiqpclBHLhvxXyF:b:f:t:D:I:P:m:N:n:"
diff --git a/ssh-pkcs11-client.c b/ssh-pkcs11-client.c
index 650c373..755483f 100644
--- a/ssh-pkcs11-client.c
+++ b/ssh-pkcs11-client.c
@@ -153,6 +153,15 @@ pkcs11_start_helper(void)
 {
 	int pair[2];
 
+  #ifdef NX_WIN32_FIXME
+  if (socketpair(pair) == -1) 
+  {
+    error("socketpair: %s", strerror(errno));
+    return (-1);
+  }
+
+  #else
+
 	if (socketpair(AF_UNIX, SOCK_STREAM, 0, pair) == -1) {
 		error("socketpair: %s", strerror(errno));
 		return (-1);
@@ -174,6 +183,9 @@ pkcs11_start_helper(void)
 		    strerror(errno));
 		_exit(1);
 	}
+
+  #endif /*NX_WIN32_FIXME*/
+
 	close(pair[1]);
 	fd = pair[0];
 	return (0);
diff --git a/ssh-pkcs11.c b/ssh-pkcs11.c
index 1f4c1c8..9741062 100644
--- a/ssh-pkcs11.c
+++ b/ssh-pkcs11.c
@@ -27,7 +27,12 @@
 #include <stdio.h>
 
 #include <string.h>
+
+#ifdef NX_WIN32_FIXME
+#include <Winbase.h>
+#else
 #include <dlfcn.h>
+#endif /*NX_WIN32_FIXME*/
 
 #include "openbsd-compat/sys-queue.h"
 
@@ -59,6 +64,7 @@ struct pkcs11_provider {
 	TAILQ_ENTRY(pkcs11_provider) next;
 };
 
+
 TAILQ_HEAD(, pkcs11_provider) pkcs11_providers;
 
 struct pkcs11_key {
@@ -106,7 +112,12 @@ pkcs11_provider_finalize(struct pkcs11_provider *p)
 		error("C_Finalize failed: %lu", rv);
 	p->valid = 0;
 	p->function_list = NULL;
+
+  #ifdef NX_WIN32_FIXME
+    FreeLibrary(p -> handle);
+  #else
 	dlclose(p->handle);
+  #endif /*NX_WIN32_FIXME*/
 }
 
 /*
@@ -496,6 +507,29 @@ pkcs11_add_provider(char *provider_id, char *pin, Key ***keyp)
 		goto fail;
 	}
 	/* open shared pkcs11-libarary */
+
+  #ifdef NX_WIN32_FIXME
+
+    handle = LoadLibrary(provider_id);
+
+    if (handle == NULL)
+    {
+      error("Cannot load OpenSC library. Error code is: %u.\n"
+                "Please ensure that path to these libraries is properly "
+                    "set in your PATH variable.\n", GetLastError());
+      goto fail;
+    }
+
+    getfunctionlist = GetProcAddress(handle, "C_GetFunctionList");
+
+    if (getfunctionlist == NULL)
+    {
+      error("Cannot load OpenSC library. Error code is: %u.\n", GetLastError());
+
+      goto fail;
+    }
+
+  #else
 	if ((handle = dlopen(provider_id, RTLD_NOW)) == NULL) {
 		error("dlopen %s failed: %s", provider_id, dlerror());
 		goto fail;
@@ -504,6 +538,8 @@ pkcs11_add_provider(char *provider_id, char *pin, Key ***keyp)
 		error("dlsym(C_GetFunctionList) failed: %s", dlerror());
 		goto fail;
 	}
+  #endif /*NX_WIN32_FIXME*/
+
 	p = xcalloc(1, sizeof(*p));
 	p->name = xstrdup(provider_id);
 	p->handle = handle;
@@ -586,7 +622,13 @@ fail:
 		xfree(p);
 	}
 	if (handle)
+
+  #ifdef NX_WIN32_FIXME
+    FreeLibrary(handle);
+  #else
 		dlclose(handle);
+  #endif/*NX_WIN32_FIXME*/
+
 	return (-1);
 }
 
diff --git a/ssh.c b/ssh.c
index c717dcf..becbf48 100644
--- a/ssh.c
+++ b/ssh.c
@@ -109,6 +109,23 @@
 #include "ssh-pkcs11.h"
 #endif
 
+/* NX */
+#ifdef NX_WIN32_FIXME
+
+  #include <sys/stat.h>
+  #define isatty(a) WSHELPisatty(a)
+  #define mkdir(a, b) _mkdir(a)
+
+  #undef NX_DEBUG
+
+  extern HANDLE proxy_command_handle;
+  extern DWORD proxy_command_pid;
+  
+  extern int PassInputFd;
+  extern int PassOutputFd;
+
+#endif /* NX_WIN32_FIXME */
+
 extern char *__progname;
 
 /* Saves a copy of argv for setproctitle emulation */
@@ -231,6 +248,75 @@ tilde_expand_paths(char **paths, u_int num_paths)
 	}
 }
 
+#ifdef NX_WIN32_FIXME
+
+/*
+ * This function send CTRL_BREAK_EVENT (equivalent of SIGINT) to
+ * child proxy process.
+ *
+ * If process still alive terminates it.
+ */
+
+static void CleanUpProxyProcess()
+{
+  if (proxy_command_handle)
+  {
+    if (GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT, proxy_command_pid) == FALSE)
+    {
+      debug("ERROR. Cannot send exit signal to childs (%u).", 
+                (unsigned int) GetLastError());
+    }
+
+    /*
+     * Try wait up to 100 ms until proxy process finished.
+     */
+
+    if (WaitForSingleObject(proxy_command_handle, 100) == WAIT_TIMEOUT)
+    {
+      /*
+       * If still not closed, kill proxy process.
+       */
+    
+      if (TerminateProcess(proxy_command_handle, 1) == TRUE)
+      {
+        debug("Process %u terminated.", (unsigned int) proxy_command_pid);
+      }
+      else
+      {
+        debug("ERROR. Cannot terminate proxy process (pid = %u).", 
+                  (unsigned int) proxy_command_pid);
+      }
+    }
+
+    CloseHandle(proxy_command_handle);
+  }
+}
+
+/*
+ * This function handles exit signal.
+ */
+
+BOOL WINAPI CtrlHandlerRoutine(DWORD dwCtrlType)
+{
+  debug("Exit signal received...");
+
+  CleanUpProxyProcess();
+  
+  #ifdef KRB5
+  #ifdef GSSAPI
+
+  UninitMitKerberos();
+  
+  #endif
+  #endif
+  
+  cleanup_exit(0);
+  
+  return TRUE;
+}
+
+#endif /* NX_WIN32_FIXME */
+
 /*
  * Main program for the ssh client.
  */
@@ -249,6 +335,29 @@ main(int ac, char **av)
 	struct servent *sp;
 	Forward fwd;
 
+  #ifdef NX_WIN32_FIXME
+  
+    /*
+     * Setup exit signal handler for receiving signal, when 
+     * parent server is stopped.
+     */
+  
+    AllocConsole();
+
+    SetConsoleCtrlHandler(CtrlHandlerRoutine, TRUE);
+
+    /*
+     * Initialize wrapped stdio.
+     */
+
+    WSHELPinitialize();
+   
+    allocate_standard_descriptor(STDIN_FILENO);
+    allocate_standard_descriptor(STDOUT_FILENO);
+    allocate_standard_descriptor(STDERR_FILENO);
+    
+  #endif
+
 	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
 	sanitise_stdfd();
 
@@ -626,6 +735,30 @@ main(int ac, char **av)
 		ac--, av++;
 	}
 
+  #ifdef NX_WIN32_FIXME
+  
+    /*
+     * Redirect stdin/stdout for password read. This trick allow
+     * use of all auth procedures from ssh client in sftp without
+     * additional code in parent.
+     */
+     
+    if (options.passInputHandle_)
+    {
+      debug3("Redirecting pass input to %d...\n", options.passInputHandle_);
+    
+      PassInputFd = _open_osfhandle(options.passInputHandle_, O_RDONLY);
+    }
+
+    if (options.passOutputHandle_)
+    { 
+      debug3("Redirecting pass prompt output to %d...\n", options.passOutputHandle_);
+    
+      PassOutputFd = _open_osfhandle(options.passOutputHandle_, O_WRONLY);
+    }
+
+  #endif
+
 	/* Check that we got a host name. */
 	if (!host)
 		usage();
@@ -692,6 +825,27 @@ main(int ac, char **av)
 	    options.log_level == -1 ? SYSLOG_LEVEL_INFO : options.log_level,
 	    SYSLOG_FACILITY_USER, !use_syslog);
 
+  /*
+   * If user wants Kerberos, check is MIT KfW libraries availible.
+   * Don't go on without Kerberos.
+   */
+   
+  #ifdef NX_WIN32_FIXME
+  #ifdef KRB5
+  #ifdef GSSAPI
+  
+    if (options.gss_authentication == 1)
+    {
+      if (InitMitKerberos() != 0)
+      {
+        cleanup_exit(1);
+      }
+    }
+    
+  #endif
+  #endif
+  #endif
+  
 	/*
 	 * Read per-user configuration file.  Ignore the system wide config
 	 * file if the user specifies a config file on the command line.
@@ -904,8 +1058,10 @@ main(int ac, char **av)
 	    options.num_system_hostfiles);
 	tilde_expand_paths(options.user_hostfiles, options.num_user_hostfiles);
 
+#ifndef NX_WIN32_FIXME
 	signal(SIGPIPE, SIG_IGN); /* ignore SIGPIPE early */
 	signal(SIGCHLD, main_sigchld_handler);
+#endif
 
 	/* Log into the remote system.  Never returns if the login fails. */
 	ssh_login(&sensitive_data, host, (struct sockaddr *)&hostaddr,
@@ -947,15 +1103,36 @@ main(int ac, char **av)
 	if (options.control_path != NULL && muxserver_sock != -1)
 		unlink(options.control_path);
 
+  /*
+   * Windows specific Cleanup.
+   */
+   
+  #ifdef NX_WIN32_FIXME
+  
+    CleanUpProxyProcess();
+
+    #ifdef KRB5
+    #ifdef GSSAPI
+
+    UninitMitKerberos();
+    
+    #endif
+    #endif
+
+  #else
+
 	/* Kill ProxyCommand if it is running. */
 	ssh_kill_proxy_command();
 
+  #endif
+  
 	return exit_status;
 }
 
 static void
 control_persist_detach(void)
 {
+#ifndef NX_WIN32_FIXME
 	pid_t pid;
 	int devnull;
 
@@ -995,6 +1172,7 @@ control_persist_detach(void)
 			close(devnull);
 	}
 	setproctitle("%s [mux]", options.control_path);
+#endif
 }
 
 /* Do fork() after authentication. Used by "ssh -f" */
@@ -1158,7 +1336,11 @@ ssh_session(void)
 	int type;
 	int interactive = 0;
 	int have_tty = 0;
-	struct winsize ws;
+
+  #ifndef NX_WIN32_FIXME
+  struct winsize ws;
+  #endif
+
 	char *cp;
 	const char *display;
 
@@ -1201,6 +1383,16 @@ ssh_session(void)
 		packet_put_cstring(cp);
 
 		/* Store window size in the packet. */
+  
+  #ifdef NX_WIN32_FIXME
+  
+    packet_put_int((u_int) 25);  /*row*/
+    packet_put_int((u_int) 80);  /*col*/
+    packet_put_int((u_int) 640); /*xpixel*/
+    packet_put_int((u_int) 480); /*ypixel*/
+
+  #else
+
 		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) < 0)
 			memset(&ws, 0, sizeof(ws));
 		packet_put_int((u_int)ws.ws_row);
@@ -1208,6 +1400,8 @@ ssh_session(void)
 		packet_put_int((u_int)ws.ws_xpixel);
 		packet_put_int((u_int)ws.ws_ypixel);
 
+  #endif
+  
 		/* Store tty modes in the packet. */
 		tty_make_modes(fileno(stdin), NULL);
 
@@ -1571,6 +1765,7 @@ load_public_identity_files(void)
 	xfree(pwdir);
 }
 
+#ifdef SIGCHLD
 static void
 main_sigchld_handler(int sig)
 {
@@ -1585,4 +1780,4 @@ main_sigchld_handler(int sig)
 	signal(sig, main_sigchld_handler);
 	errno = save_errno;
 }
-
+#endif
diff --git a/sshconnect.c b/sshconnect.c
index 0ee7266..f65a6f7 100644
--- a/sshconnect.c
+++ b/sshconnect.c
@@ -67,7 +67,18 @@ char *server_version_string = NULL;
 
 static int matching_host_key_dns = 0;
 
+#ifdef NX_WIN32_FIXME
+
+  #define ECONNABORTED WSAECONNABORTED
+  #define ECONNREFUSED WSAECONNREFUSED
+  #define FAIL(X) if (X) goto fail
+
+  HANDLE proxy_command_handle = NULL;
+  DWORD proxy_command_pid = 0;
+  
+#else
 static pid_t proxy_command_pid = 0;
+#endif
 
 /* import */
 extern Options options;
@@ -84,6 +95,121 @@ static void warn_changed_key(Key *);
 static int
 ssh_proxy_connect(const char *host, u_short port, const char *proxy_command)
 {
+  /*
+   * Win32 code.
+   */
+
+  #ifdef NX_WIN32_FIXME
+  
+    PROCESS_INFORMATION pi = {0};
+  
+    STARTUPINFO si = {0};
+    
+    char *fullCmd = NULL;
+
+    char strport[NI_MAXSERV] = {0};
+    
+    int sockin[2]  = {-1, -1};
+    int sockout[2] = {-1, -1};
+    
+    int exitCode = -1;
+  
+    /*
+     * Create command to execute as proxy.
+     */
+
+    debug("Creating proxy command...");
+    
+    snprintf(strport, sizeof strport, "%hu", port);
+    
+    fullCmd = percent_expand(proxy_command, "h", host, 
+                                 "p", strport, (char *) NULL);
+                                 
+    FAIL(fullCmd == NULL);                             
+
+    /*
+     * Create socket pairs for stdin and stdout.
+     */
+
+    debug("Creating socket pairs for proxy process...");
+
+    socketpair(sockin);
+    socketpair(sockout);
+    
+    debug("sockin[0]: %d sockin[1]: %d", sockin[0], sockin[1]);
+    debug("sockout[0]: %d sockout[1]: %d", sockout[0], sockout[1]);
+
+    permanently_drop_suid(original_real_uid);
+    
+    /*
+     * Assign sockets to StartupInfo
+     */
+
+    si.cb          = sizeof(STARTUPINFO);
+    si.hStdInput   = (HANDLE) sfd_to_handle(sockin[0]);
+    si.hStdOutput  = (HANDLE) sfd_to_handle(sockout[0]);
+    si.hStdError   = GetStdHandle(STD_ERROR_HANDLE);
+    si.wShowWindow = SW_HIDE;
+    si.dwFlags     = STARTF_USESTDHANDLES;
+    si.lpDesktop   = NULL;
+
+    /*               
+     * Create proxy process with given stdout/stdin.
+     */
+    
+    debug("Executing proxy command: \"%.500s\"...\n", fullCmd);
+
+    FAIL(CreateProcess(NULL, fullCmd, NULL, NULL, TRUE, 
+                           CREATE_NEW_PROCESS_GROUP, NULL, 
+                               NULL, &si, &pi) == FALSE);
+
+    proxy_command_handle = pi.hProcess;
+    proxy_command_pid    = pi.dwProcessId;
+    
+    /*
+     * Redirect network in/out to proxy sockets.
+     */
+    
+    packet_set_connection(sockout[1], sockin[1]);
+
+    
+    exitCode = 0;
+   
+    fail:
+  
+    /*
+     / Clean up.
+     */
+
+    close(sockout[0]);
+    close(sockin[0]);
+
+    CloseHandle(pi.hThread);
+    
+    xfree(fullCmd);
+    
+    /*
+     * Error handler.
+     */
+    
+    if (exitCode)
+    {
+      debug("Error cannot create proxy process (%u).\n", (unsigned int) GetLastError());
+      
+      close(sockout[1]);
+      close(sockin[1]);
+      
+      CloseHandle(pi.hProcess);
+    }
+ 
+    return exitCode;
+
+  #else
+
+  /*
+   * Original OpenSSH code.
+   */
+
 	char *command_string, *tmp;
 	int pin[2], pout[2];
 	pid_t pid;
@@ -168,17 +294,21 @@ ssh_proxy_connect(const char *host, u_short port, const char *proxy_command)
 
 	/* Indicate OK return */
 	return 0;
+
+  #endif /* else NX_WIN32_FIXME */
 }
 
 void
 ssh_kill_proxy_command(void)
 {
+#ifndef NX_WIN32_FIXME
 	/*
 	 * Send SIGHUP to proxy command if used. We don't wait() in
 	 * case it hangs and instead rely on init to reap the child
 	 */
 	if (proxy_command_pid > 1)
 		kill(proxy_command_pid, SIGHUP);
+#endif
 }
 
 /*
@@ -211,7 +341,9 @@ ssh_create_socket(int privileged, struct addrinfo *ai)
 		error("socket: %.100s", strerror(errno));
 		return -1;
 	}
+#ifndef NX_WIN32_FIXME
 	fcntl(sock, F_SETFD, FD_CLOEXEC);
+#endif
 
 	/* Bind the socket to an alternative local IP address */
 	if (options.bind_address == NULL)
@@ -267,8 +399,14 @@ timeout_connect(int sockfd, const struct sockaddr *serv_addr,
 		goto done;
 	}
 
+#ifndef NX_WIN32_FIXME
 	fdset = (fd_set *)xcalloc(howmany(sockfd + 1, NFDBITS),
 	    sizeof(fd_mask));
+#else
+	fdset = xmalloc(sizeof(fd_set));
+	FD_ZERO(fdset);
+#endif
+
 	FD_SET(sockfd, fdset);
 	ms_to_timeval(&tv, *timeoutp);
 
@@ -344,6 +482,12 @@ ssh_connect(const char *host, struct sockaddr_storage * hostaddr,
 	char ntop[NI_MAXHOST], strport[NI_MAXSERV];
 	struct addrinfo hints, *ai, *aitop;
 
+  #ifdef NX_WIN32_FIXME
+
+  DWORD error_win32 = 0;
+
+  #endif
+
 	debug2("ssh_connect: needpriv %d", needpriv);
 
 	/* If a proxy command is given, connect using it. */
@@ -396,6 +540,9 @@ ssh_connect(const char *host, struct sockaddr_storage * hostaddr,
 			} else {
 				debug("connect to address %s port %s: %s",
 				    ntop, strport, strerror(errno));
+#ifdef NX_WIN32_FIXME
+                                error_win32 = WSAGetLastError();
+#endif
 				close(sock);
 				sock = -1;
 			}
@@ -408,6 +555,9 @@ ssh_connect(const char *host, struct sockaddr_storage * hostaddr,
 
 	/* Return failure if we didn't get a successful connection. */
 	if (sock == -1) {
+#ifdef NX_WIN32_FIXME
+                WSASetLastError(error_win32);
+#endif
 		error("ssh: connect to host %s port %s: %s",
 		    host, strport, strerror(errno));
 		return (-1);
@@ -1256,6 +1406,7 @@ warn_changed_key(Key *host_key)
 int
 ssh_local_cmd(const char *args)
 {
+#ifndef NX_WIN32_FIXME
 	char *shell;
 	pid_t pid;
 	int status;
@@ -1288,4 +1439,13 @@ ssh_local_cmd(const char *args)
 		return (1);
 
 	return (WEXITSTATUS(status));
+#else
+  
+  /*
+   * Not implemented on Win32.
+   */
+   
+  return -1;  
+
+#endif /* else !NX_WIN32_FIXME */
 }
diff --git a/sshconnect2.c b/sshconnect2.c
index c24b202..b6d3e57 100644
--- a/sshconnect2.c
+++ b/sshconnect2.c
@@ -1574,6 +1574,7 @@ static int
 ssh_keysign(Key *key, u_char **sigp, u_int *lenp,
     u_char *data, u_int datalen)
 {
+#ifndef NX_WIN32_FIXME
 	Buffer b;
 	struct stat st;
 	pid_t pid;
@@ -1645,6 +1646,16 @@ ssh_keysign(Key *key, u_char **sigp, u_int *lenp,
 	buffer_free(&b);
 
 	return 0;
+
+#else
+
+  /*
+   * Not implemented on Win32.
+   */
+   
+  return -1;
+
+#endif
 }
 
 int
@@ -1917,4 +1928,3 @@ authmethods_get(void)
 	buffer_free(&b);
 	return list;
 }
-
diff --git a/sshd.c b/sshd.c
index cc10395..ac1f6f6 100644
--- a/sshd.c
+++ b/sshd.c
@@ -44,6 +44,15 @@
 
 #include "includes.h"
 
+/*
+ * We support only client side kerberos on Windows.
+ */
+
+#ifdef NX_WIN32_FIXME
+  #undef GSSAPI
+  #undef KRB5
+#endif
+
 #include <sys/types.h>
 #include <sys/ioctl.h>
 #include <sys/socket.h>
@@ -170,6 +179,21 @@ int log_stderr = 0;
 char **saved_argv;
 int saved_argc;
 
+/* Arguments to used for fake forked child processes of sshd.exe */
+#ifdef NX_WIN32_FIXME
+/*
+FIXME: GFPZR: Function stat() may be undeclared.
+*/
+#include <sys/stat.h>
+#include <tlhelp32.h>
+
+char *fake_fork_args;
+char *start_dir;
+
+extern int logfd;
+extern int sfd_start;
+#endif
+
 /* re-exec */
 int rexeced_flag = 0;
 int rexec_flag = 1;
@@ -259,6 +283,205 @@ void demote_sensitive_data(void);
 static void do_ssh1_kex(void);
 static void do_ssh2_kex(void);
 
+#ifdef NX_WIN32_FIXME
+
+  /*
+   * Win32 only.
+   */
+   
+  SERVICE_STATUS_HANDLE gSvcStatusHandle;;
+  SERVICE_STATUS gSvcStatus;
+
+  int ranServiceMain = 0;
+  int iAmAService = 1;
+
+  #define SVCNAME "SSHD"
+
+  static VOID ReportSvcStatus(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint)
+  {
+    static DWORD dwCheckPoint = 1;
+
+    /*
+     * Fill in the SERVICE_STATUS structure. 
+     */
+
+    gSvcStatus.dwCurrentState = dwCurrentState;
+    gSvcStatus.dwWin32ExitCode = dwWin32ExitCode;
+    gSvcStatus.dwWaitHint = dwWaitHint;
+
+    if (dwCurrentState == SERVICE_START_PENDING)
+    {
+      gSvcStatus.dwControlsAccepted = 0;
+    }  
+    else 
+    {  
+      gSvcStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
+    }  
+
+    if ((dwCurrentState == SERVICE_RUNNING) || (dwCurrentState == SERVICE_STOPPED))
+    {
+      gSvcStatus.dwCheckPoint = 0;
+    }  
+    else
+    {
+      gSvcStatus.dwCheckPoint = dwCheckPoint++;
+    }
+
+    /*
+     * Report the status of the service to the SCM.
+     */
+    
+    SetServiceStatus( gSvcStatusHandle, &gSvcStatus );
+  }
+
+  static VOID WINAPI SSHDHandlerEx(DWORD dwControl)
+  {
+    debug("Request received (%u)\n", dwControl);
+  
+    /*
+     * Handle the requested control code.
+     */
+
+    switch(dwControl) 
+    {
+      case SERVICE_CONTROL_STOP:
+      {
+        debug("SERVICE_CONTROL_STOP signal received...");
+    
+        ReportSvcStatus(SERVICE_STOP_PENDING, NO_ERROR, 500);
+   
+        /*
+         * Send exit signal to child 'nxsshd.exe' processes.
+         */
+      
+        debug("Sending exit signal to child 'nxsshd.exe' processes...");
+        
+        if (!GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT, 0))
+        {
+          debug("ERROR. Cannot send exit signal to childs (%u).\n", GetLastError());
+        }
+    
+        cleanup_exit(0);
+       
+        /*
+         * Signal the service to stop.
+         */
+     
+        ReportSvcStatus(SERVICE_STOPPED, NO_ERROR, 0);
+  
+        return;
+      }  
+ 
+      case SERVICE_CONTROL_INTERROGATE:
+      {
+        /* 
+         * Fall through to send current status.
+         */
+      
+        break;
+      }   
+ 
+      default:
+      {
+        break;
+      }
+    }  
+
+    ReportSvcStatus(gSvcStatus.dwCurrentState, NO_ERROR, 0);
+  }
+
+  static VOID SvcUninstall()
+  {
+    SC_HANDLE schSCManager;
+    SC_HANDLE schService;
+
+    /*
+     * Get a handle to the SCM database.
+     */
+    
+    schSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
+ 
+    if (NULL == schSCManager) 
+    {
+      printf("OpenSCManager failed (%d)\n", GetLastError());
+      
+      return;
+    }
+
+    schService = OpenService(schSCManager, SVCNAME, DELETE);
+    
+    if (NULL == schService)
+    {
+      printf("OpenService failed (%d)\n", GetLastError());
+      
+      return;
+    }
+
+    if (!DeleteService(schService))
+    {
+      printf("DeleteService failed (%d)\n", GetLastError());
+      
+      return;
+    }
+
+    printf("Service (%s) deleted.", SVCNAME);
+  }
+
+  static VOID SvcInstall()
+  {
+    SC_HANDLE schSCManager;
+    SC_HANDLE schService;
+    
+    TCHAR szPath[MAX_PATH];
+
+    if(GetModuleFileName(NULL, szPath, MAX_PATH) == FALSE)
+    {
+      printf("Cannot install service (%d)\n", GetLastError());
+      
+      return;
+    }
+
+    /*
+     * Get a handle to the SCM database.
+     */
+
+    schSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
+
+    if (NULL == schSCManager) 
+    {
+      printf("OpenSCManager failed (%d)\n", GetLastError());
+      
+      return;
+    }
+
+    /*
+     * Create the service
+     */
+     
+    schService = CreateService(schSCManager, SVCNAME, SVCNAME, SERVICE_ALL_ACCESS,
+                                   SERVICE_WIN32_OWN_PROCESS, SERVICE_DEMAND_START,
+                                       SERVICE_ERROR_NORMAL, szPath, NULL, NULL,
+                                           NULL, NULL, NULL);
+ 
+    if (schService == NULL) 
+    {
+      printf("CreateService failed (%d)\n", GetLastError()); 
+      
+      CloseServiceHandle(schSCManager);
+      
+      return;
+    }
+    else
+    {
+      printf("Service installed successfully\n");
+    }  
+
+    CloseServiceHandle(schService); 
+    CloseServiceHandle(schSCManager);
+  }
+
+#endif /* NX_WIN32_FIXME */
+
 /*
  * Close all listening sockets
  */
@@ -293,11 +516,13 @@ close_startup_pipes(void)
 static void
 sighup_handler(int sig)
 {
+#ifndef NX_WIN32_FIXME
 	int save_errno = errno;
 
 	received_sighup = 1;
 	signal(SIGHUP, sighup_handler);
 	errno = save_errno;
+#endif
 }
 
 /*
@@ -307,6 +532,7 @@ sighup_handler(int sig)
 static void
 sighup_restart(void)
 {
+#ifndef NX_WIN32_FIXME
 	logit("Received SIGHUP; restarting.");
 	close_listen_socks();
 	close_startup_pipes();
@@ -316,6 +542,7 @@ sighup_restart(void)
 	logit("RESTART FAILED: av[0]='%.100s', error: %.100s.", saved_argv[0],
 	    strerror(errno));
 	exit(1);
+#endif
 }
 
 /*
@@ -336,6 +563,7 @@ sigterm_handler(int sig)
 static void
 main_sigchld_handler(int sig)
 {
+#ifndef NX_WIN32_FIXME
 	int save_errno = errno;
 	pid_t pid;
 	int status;
@@ -346,6 +574,7 @@ main_sigchld_handler(int sig)
 
 	signal(SIGCHLD, main_sigchld_handler);
 	errno = save_errno;
+#endif
 }
 
 /*
@@ -355,11 +584,13 @@ main_sigchld_handler(int sig)
 static void
 grace_alarm_handler(int sig)
 {
+#ifndef NX_WIN32_FIXME
 	if (use_privsep && pmonitor != NULL && pmonitor->m_pid > 0)
 		kill(pmonitor->m_pid, SIGALRM);
 
 	/* Log error and exit. */
 	sigdie("Timeout before authentication for %s", get_remote_ipaddr());
+#endif
 }
 
 /*
@@ -586,6 +817,7 @@ demote_sensitive_data(void)
 static void
 privsep_preauth_child(void)
 {
+#ifndef NX_WIN32_FIXME
 	u_int32_t rnd[256];
 	gid_t gidset[1];
 
@@ -618,11 +850,13 @@ privsep_preauth_child(void)
 		fatal("setgroups: %.100s", strerror(errno));
 	permanently_set_uid(privsep_pw);
 #endif
+#endif
 }
 
 static int
 privsep_preauth(Authctxt *authctxt)
 {
+#ifndef NX_WIN32_FIXME
 	int status;
 	pid_t pid;
 	struct ssh_sandbox *box = NULL;
@@ -681,11 +915,21 @@ privsep_preauth(Authctxt *authctxt)
 
 		return 0;
 	}
+#else
+
+  /*
+   * Not implemented on Win32.
+   */
+   
+  return 0;
+  
+#endif
 }
 
 static void
 privsep_postauth(Authctxt *authctxt)
 {
+#ifndef NX_WIN32_FIXME
 	u_int32_t rnd[256];
 
 #ifdef DISABLE_FD_PASSING
@@ -737,6 +981,7 @@ privsep_postauth(Authctxt *authctxt)
 	 * this information is not part of the key state.
 	 */
 	packet_set_authenticated();
+#endif /* !NX_WIN32_FIXME */
 }
 
 static char *
@@ -1061,6 +1306,21 @@ server_listen(void)
 		if (ai->ai_family == AF_INET6)
 			sock_set_v6only(listen_sock);
 
+    #ifdef NX_WIN32_FIXME
+
+    /*
+     * Forbid inheriting of listen socket.
+     */
+     
+    if (SetHandleInformation(sfd_to_handle(listen_sock), 
+                                 HANDLE_FLAG_INHERIT, 0) == FALSE)
+    {
+      debug("ERROR. Cannot clear inherit flag from listen socket [%d]. "
+                "Error code : %u.", listen_sock, GetLastError());
+    }  
+  
+    #endif
+
 		debug("Bind to port %s on %s.", strport, ntop);
 
 		/* Bind the socket to the desired port. */
@@ -1120,8 +1380,14 @@ server_accept_loop(int *sock_in, int *sock_out, int *newsock, int *config_s)
 			sighup_restart();
 		if (fdset != NULL)
 			xfree(fdset);
+
+#ifndef NX_WIN32_FIXME
 		fdset = (fd_set *)xcalloc(howmany(maxfd + 1, NFDBITS),
 		    sizeof(fd_mask));
+#else
+		fdset = (fd_set *) xmalloc(sizeof(fd_set));
+		FD_ZERO(fdset);
+#endif
 
 		for (i = 0; i < num_listen_socks; i++)
 			FD_SET(listen_socks[i], fdset);
@@ -1182,6 +1448,13 @@ server_accept_loop(int *sock_in, int *sock_out, int *newsock, int *config_s)
 				close(*newsock);
 				continue;
 			}
+
+  /*
+   * We don't need startup pipe on windows.
+   */
+   
+#ifndef NX_WIN32_FIXME      
+
 			if (pipe(startup_p) == -1) {
 				close(*newsock);
 				continue;
@@ -1197,6 +1470,8 @@ server_accept_loop(int *sock_in, int *sock_out, int *newsock, int *config_s)
 				continue;
 			}
 
+#endif
+
 			for (j = 0; j < options.max_startups; j++)
 				if (startup_pipes[j] == -1) {
 					startup_pipes[j] = startup_p[0];
@@ -1206,6 +1481,72 @@ server_accept_loop(int *sock_in, int *sock_out, int *newsock, int *config_s)
 					break;
 				}
 
+      #ifdef NX_WIN32_FIXME
+  
+        /*
+         *  Win32 code.
+         */
+
+         {
+           PROCESS_INFORMATION pi;
+           
+           STARTUPINFO si;
+           
+           BOOL b;
+
+
+           /*
+            * Assign sockets to StartupInfo.
+            */
+           
+           memset(&si, 0 , sizeof(STARTUPINFO));
+           
+           si.cb = sizeof(STARTUPINFO);
+           si.hStdInput = (HANDLE) sfd_to_handle(*newsock);
+           si.hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE);
+           si.hStdError = GetStdHandle(STD_ERROR_HANDLE);
+           si.wShowWindow = SW_HIDE;
+           si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
+
+           /*
+            * Create the child process 
+            */
+            
+           b = CreateProcess(NULL, fake_fork_args, NULL, NULL, TRUE,
+                                 CREATE_NEW_PROCESS_GROUP, NULL, start_dir,
+                                     &si, &pi);
+          if (!b)
+          {
+            debug("CreateProcess failure: %d", GetLastError());
+            
+            exit(1);
+          }
+
+          /*
+           * Close child thread and process handles so it can go away 
+           */
+
+          CloseHandle(pi.hThread);
+          CloseHandle(pi.hProcess);
+          
+          close(*newsock);
+
+          /*
+           * FIXME pipes are not used so instead of  
+           * cleaning we can disable creation.
+           */
+          
+          close(startup_pipes[i]);
+          startup_pipes[i] = -1;
+          startups--;
+        }
+
+      #else
+        
+        /* 
+         * Original OpenSSH code.
+         */
+      
 			/*
 			 * Got connection.  Fork a child to handle it, unless
 			 * we are in debugging mode.
@@ -1231,7 +1572,6 @@ server_accept_loop(int *sock_in, int *sock_out, int *newsock, int *config_s)
 				}
 				break;
 			}
-
 			/*
 			 * Normal production daemon.  Fork, and have
 			 * the child process the connection. The
@@ -1296,6 +1636,9 @@ server_accept_loop(int *sock_in, int *sock_out, int *newsock, int *config_s)
 			 * from that of the child
 			 */
 			arc4random_stir();
+
+      #endif /* else NX_WIN32_FIXME */
+
 		}
 
 		/* child process check (or debug mode) */
@@ -1304,6 +1647,42 @@ server_accept_loop(int *sock_in, int *sock_out, int *newsock, int *config_s)
 	}
 }
 
+#ifdef NX_WIN32_FIXME
+
+  /*
+   * Win32 only.
+   */
+   
+  char *create_fake_fork_args(int ac, char **av)
+  {
+    char *orig_cmd_line = GetCommandLine();
+    
+    char fake_fork_param[] = " -~";
+    
+    int orig_cmd_line_len = strlen(orig_cmd_line);
+    
+    char *new_cmd_line = xmalloc (orig_cmd_line_len + 1 + sizeof(fake_fork_param));
+
+    strcpy(new_cmd_line, orig_cmd_line);
+    strcpy(new_cmd_line + orig_cmd_line_len, fake_fork_param);
+
+    return new_cmd_line;
+  }
+
+  /*
+   * This function handles exit signal from parent process.
+   */
+
+  BOOL WINAPI CtrlHandlerRoutine(DWORD dwCtrlType)
+  {
+    debug("Exit signal received...");
+
+    cleanup_exit(0);
+
+    return TRUE;
+  }
+
+#endif /* NX_WIN32_FIXME */
 
 /*
  * Main program for the daemon.
@@ -1325,6 +1704,37 @@ main(int ac, char **av)
 	Key *key;
 	Authctxt *authctxt;
 
+  #ifdef HAVE_STARTUP_NEEDS /* NX */
+  
+    int startup_handler(void);
+    
+    startup_handler();
+  
+  #endif
+
+  #ifdef NX_WIN32_FIXME
+
+    /*
+     * Setup exit signal handler for receiving signal, when 
+     * parent server is stopped.
+     */
+  
+    AllocConsole();
+
+    SetConsoleCtrlHandler(CtrlHandlerRoutine, TRUE);
+  
+    //authctxt -> hTokenLsa_ = NULL;
+   
+    WSHELPinitialize();
+    
+    allocate_standard_descriptor(STDIN_FILENO);
+    allocate_standard_descriptor(STDOUT_FILENO);
+    allocate_standard_descriptor(STDERR_FILENO);
+
+    sfd_start = 3;
+
+  #endif /* NX_WIN32_FIXME */
+
 #ifdef HAVE_SECUREWARE
 	(void)set_auth_parameters(ac, av);
 #endif
@@ -1338,14 +1748,34 @@ main(int ac, char **av)
 		saved_argv[i] = xstrdup(av[i]);
 	saved_argv[i] = NULL;
 
+  #ifdef NX_WIN32_FIXME
+  
+    /*
+     * Create arguments for starting fake forked sshd.exe instances.
+     */
+
+    fake_fork_args = create_fake_fork_args(ac, av);
+
+    {
+      int start_dir_len = GetCurrentDirectory(0, NULL);
+      
+      start_dir = xmalloc(start_dir_len + 1);
+      
+      GetCurrentDirectory(start_dir_len, start_dir);
+    }
+  
+  #endif /* NX_WIN32_FIXME */
+
 #ifndef HAVE_SETPROCTITLE
 	/* Prepare for later setproctitle emulation */
 	compat_init_setproctitle(ac, av);
 	av = saved_argv;
 #endif
 
+#ifndef NX_WIN32_FIXME
 	if (geteuid() == 0 && setgroups(0, NULL) == -1)
 		debug("setgroups(): %.200s", strerror(errno));
+#endif
 
 	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
 	sanitise_stdfd();
@@ -1353,9 +1783,34 @@ main(int ac, char **av)
 	/* Initialize configuration options to their default values. */
 	initialize_server_options(&options);
 
+  #ifdef NX_WIN32_FIXME
+
+    debug_flag = 1;
+
+    #define NX_FAKE_FORK_ARG "~"
+  
+  #else
+    
+    #define NX_FAKE_FORK_ARG
+    
+  #endif
+
+  
 	/* Parse command-line arguments. */
-	while ((opt = getopt(ac, av, "f:p:b:k:h:g:u:o:C:dDeiqrtQRT46")) != -1) {
+	while ((opt = getopt(ac, av, "f:p:b:k:h:g:u:o:C:dDeiqrtQRT46" NX_FAKE_FORK_ARG)) != -1) {
 		switch (opt) {
+    
+    #ifdef NX_WIN32_FIXME
+    case '~':
+    {
+      debug("fake fork child");
+      
+      options.i_am_a_fake_fork = 1;
+      
+      break;
+    }  
+    #endif
+    
 		case '4':
 			options.address_family = AF_INET;
 			break;
@@ -1374,11 +1829,13 @@ main(int ac, char **av)
 			   derelativise_path(optarg);
 			break;
 		case 'd':
+#ifndef NX_WIN32_FIXME
 			if (debug_flag == 0) {
 				debug_flag = 1;
 				options.log_level = SYSLOG_LEVEL_DEBUG1;
 			} else if (options.log_level < SYSLOG_LEVEL_DEBUG3)
 				options.log_level++;
+#endif
 			break;
 		case 'D':
 			no_daemon_flag = 1;
@@ -1435,7 +1892,7 @@ main(int ac, char **av)
 				fprintf(stderr, "too many host keys.\n");
 				exit(1);
 			}
-			options.host_key_files[options.num_host_key_files++] = 
+			options.host_key_files[options.num_host_key_files++] =
 			   derelativise_path(optarg);
 			break;
 		case 't':
@@ -1480,14 +1937,192 @@ main(int ac, char **av)
 			break;
 		}
 	}
+
+  #ifdef NX_WIN32_FIXME
+    
+    /*
+     * Win32 only.
+     */
+     
+    WSHELPinitialize();
+
+    /* 
+     * Handle install and uninstall service options 
+     */
+    
+    if (ac > 1 && strcmp("install", av[1]) == 0)
+    {
+      /*
+       * Install the service 
+       */
+      
+      SvcInstall();
+      
+      return 0;
+    }
+    else if (ac > 1 && strcmp("uninstall", av[1]) == 0)
+    {
+      /*
+       * Remove the service 
+       */
+      
+      SvcUninstall();
+      
+      return 0;
+    }
+
+    if (!options.i_am_a_fake_fork)
+    {
+      if (!ranServiceMain)
+      {
+        do
+        {
+          SERVICE_TABLE_ENTRY DispatchTable[] = 
+          { 
+            {SVCNAME, (LPSERVICE_MAIN_FUNCTION) main},
+            {NULL, NULL} 
+          };
+ 
+          /* 
+           * Don't come back here now 
+           */
+          
+          ranServiceMain = 1;
+
+          /*
+           * This call returns when the service has stopped. 
+           */
+          
+          /* 
+           * The process should simply terminate when the call returns. 
+           */
+
+          /*
+           * If the service control dispatcher failed to register
+           * for any other reason, bail out.
+           */
+           
+          if (!StartServiceCtrlDispatcher(DispatchTable))
+          { 
+            if (GetLastError() == ERROR_FAILED_SERVICE_CONTROLLER_CONNECT)
+            {
+              /*
+               * We're a console app, baby! 
+               */
+              
+              iAmAService = 0;
+              
+              break;
+            }
+
+            /*
+             * We're a service that can't go any further 
+             */
+             
+            return -1;
+          }
+
+          return 0;
+        } while (0);
+      }
+      else
+      {
+        /* 
+         * Finish up the service initialization 
+         */
+         
+        gSvcStatusHandle = RegisterServiceCtrlHandler("SSHD", SSHDHandlerEx);
+        
+        ZeroMemory(&gSvcStatus, sizeof(gSvcStatus));
+        
+        gSvcStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
+        ReportSvcStatus(SERVICE_START_PENDING, NO_ERROR, 300);
+        ReportSvcStatus(SERVICE_RUNNING, NO_ERROR, 0);
+      }
+    }
+  
+    rexec_flag = 0;
+    use_privsep = 0;
+
+    struct stat s;
+
+    if (stat(config_file_name, &s) != 0)
+    {
+      int configFound = 0;
+      
+      TCHAR szPath[MAX_PATH];
+      TCHAR szPathCopy[MAX_PATH];
+      
+      if (GetModuleFileName(NULL, szPath, MAX_PATH))
+      {
+        char *p = NULL;
+
+        p = strrchr(szPath, '\\');
+        
+        if (p)
+        {
+          *p = '\0';
+        }
+        
+        strncpy(szPathCopy, szPath, MAX_PATH);
+        strncat(szPath, "\\sshd_config", MAX_PATH);
+        
+        if (stat(szPath, &s) == 0)
+        {
+          configFound = 1;
+          
+          goto configFound;
+        }
+
+        strncpy(szPath, szPathCopy, MAX_PATH);
+        strncat(szPath, "\\etc\\sshd_config", MAX_PATH);
+        
+        if (stat(szPath, &s) == 0)
+        {
+          configFound = 1;
+
+          goto configFound;
+        }
+
+        strncpy(szPath, szPathCopy, MAX_PATH);
+        
+        p = strrchr(szPath, '\\');
+       
+        if (p)
+        {
+          *p = '\0';
+        }
+       
+        strncat(szPath, "\\etc\\sshd_config", MAX_PATH);
+       
+        if (stat(szPath, &s) == 0)
+        {
+          configFound = 1;
+         
+          goto configFound;
+        }
+      }
+  
+  configFound:
+  
+      if (configFound)
+      {
+        config_file_name = szPath;
+      }  
+    }
+  
+  #endif /* NX_WIN32_FIXME */
+
 	if (rexeced_flag || inetd_flag)
 		rexec_flag = 0;
 	if (!test_flag && (rexec_flag && (av[0] == NULL || *av[0] != '/')))
 		fatal("sshd re-exec requires execution with an absolute path");
+#ifndef NX_WIN32_FIXME
 	if (rexeced_flag)
 		closefrom(REEXEC_MIN_FREE_FD);
 	else
 		closefrom(REEXEC_DEVCRYPTO_RESERVED_FD);
+#endif
 
 	OpenSSL_add_all_algorithms();
 
@@ -1506,8 +2141,10 @@ main(int ac, char **av)
 	 * Unset KRB5CCNAME, otherwise the user's session may inherit it from
 	 * root's environment
 	 */
+#ifndef NX_WIN32_FIXME
 	if (getenv("KRB5CCNAME") != NULL)
 		unsetenv("KRB5CCNAME");
+#endif
 
 #ifdef _UNICOS
 	/* Cray can define user privs drop all privs now!
@@ -1694,6 +2331,7 @@ main(int ac, char **av)
 			fatal("Missing privilege separation directory: %s",
 			    _PATH_PRIVSEP_CHROOT_DIR);
 
+#ifndef NX_WIN32_FIXME
 #ifdef HAVE_CYGWIN
 		if (check_ntsec(_PATH_PRIVSEP_CHROOT_DIR) &&
 		    (st.st_uid != getuid () ||
@@ -1703,6 +2341,7 @@ main(int ac, char **av)
 #endif
 			fatal("%s must be owned by root and not group or "
 			    "world-writable.", _PATH_PRIVSEP_CHROOT_DIR);
+#endif
 	}
 
 	if (test_flag > 1) {
@@ -1723,8 +2362,10 @@ main(int ac, char **av)
 	 * to create a file, and we can't control the code in every
 	 * module which might be used).
 	 */
+#ifndef NX_WIN32_FIXME
 	if (setgroups(0, NULL) < 0)
 		debug("setgroups() failed: %.200s", strerror(errno));
+#endif
 
 	if (rexec_flag) {
 		rexec_argv = xcalloc(rexec_argc + 2, sizeof(char *));
@@ -1784,6 +2425,9 @@ main(int ac, char **av)
 		server_accept_inetd(&sock_in, &sock_out);
 	} else {
 		platform_pre_listen();
+#ifdef NX_WIN32_FIXME
+    if (!options.i_am_a_fake_fork)
+#endif
 		server_listen();
 
 		if (options.protocol & SSH_PROTO_1)
@@ -1810,9 +2454,44 @@ main(int ac, char **av)
 			}
 		}
 
+    #ifdef NX_WIN32_FIXME
+      
+      if (!options.i_am_a_fake_fork)
+      {
+        /* 
+         * Accept a connection and return in a forked child 
+         */
+         
+        server_accept_loop(&sock_in, &sock_out, &newsock, config_s);
+      }
+      else
+      {
+        STARTUPINFO si;
+
+        memset(&si, 0 , sizeof(STARTUPINFO));
+        
+        si.cb = sizeof(STARTUPINFO);
+
+        /* 
+         * Get the stdin handle from process info to use for client 
+         */
+        
+        GetStartupInfo(&si);
+        
+        sock_in = sock_out = newsock = allocate_sfd(si.hStdInput);
+
+        /*
+         * We don't have a startup_pipe 
+         */
+        
+        startup_pipe = -1;
+      }
+   
+    #else
 		/* Accept a connection and return in a forked child */
 		server_accept_loop(&sock_in, &sock_out,
 		    &newsock, config_s);
+    #endif
 	}
 
 	/* This is the child processing a new connection. */
@@ -1823,6 +2502,7 @@ main(int ac, char **av)
 	 * setlogin() affects the entire process group.  We don't
 	 * want the child to be able to affect the parent.
 	 */
+#ifndef NX_WIN32_FIXME
 #if !defined(SSHD_ACQUIRES_CTTY)
 	/*
 	 * If setsid is called, on some platforms sshd will later acquire a
@@ -1832,8 +2512,10 @@ main(int ac, char **av)
 	if (!debug_flag && !inetd_flag && setsid() < 0)
 		error("setsid: %.100s", strerror(errno));
 #endif
+#endif
 
 	if (rexec_flag) {
+#ifndef NX_WIN32_FIXME
 		int fd;
 
 		debug("rexec start in %d out %d newsock %d pipe %d sock %d",
@@ -1871,11 +2553,14 @@ main(int ac, char **av)
 		}
 		debug("rexec cleanup in %d out %d newsock %d pipe %d sock %d",
 		    sock_in, sock_out, newsock, startup_pipe, config_s[0]);
+#endif /* !NX_WIN32_FIXME */
 	}
 
+#ifndef NX_WIN32_FIXME
 	/* Executed child processes don't need these. */
 	fcntl(sock_out, F_SETFD, FD_CLOEXEC);
 	fcntl(sock_in, F_SETFD, FD_CLOEXEC);
+#endif
 
 	/*
 	 * Disable the key regeneration alarm.  We will not regenerate the
@@ -2367,5 +3052,8 @@ cleanup_exit(int i)
 	if (!use_privsep || mm_is_monitor())
 		audit_event(SSH_CONNECTION_ABANDON);
 #endif
+#ifdef NX_WIN32_FIXME
+   if (!iAmAService || options.i_am_a_fake_fork)
+#endif
 	_exit(i);
 }
diff --git a/sshpty.c b/sshpty.c
index bbbc0fe..6fd7222 100644
--- a/sshpty.c
+++ b/sshpty.c
@@ -63,6 +63,7 @@
 int
 pty_allocate(int *ptyfd, int *ttyfd, char *namebuf, size_t namebuflen)
 {
+#ifndef NX_WIN32_FIXME
 	/* openpty(3) exists in OSF/1 and some other os'es */
 	char *name;
 	int i;
@@ -78,6 +79,15 @@ pty_allocate(int *ptyfd, int *ttyfd, char *namebuf, size_t namebuflen)
 
 	strlcpy(namebuf, name, namebuflen);	/* possible truncation */
 	return 1;
+#else
+
+  /*
+   * Not implemented on Win32.
+   */
+   
+  return 0;  
+   
+#endif
 }
 
 /* Releases the tty.  Its ownership is returned to root, and permissions to 0666. */
@@ -85,12 +95,14 @@ pty_allocate(int *ptyfd, int *ttyfd, char *namebuf, size_t namebuflen)
 void
 pty_release(const char *tty)
 {
+#ifndef NX_WIN32_FIXME
 #ifndef __APPLE_PRIVPTY__
 	if (chown(tty, (uid_t) 0, (gid_t) 0) < 0)
 		error("chown %.100s 0 0 failed: %.100s", tty, strerror(errno));
 	if (chmod(tty, (mode_t) 0666) < 0)
 		error("chmod %.100s 0666 failed: %.100s", tty, strerror(errno));
 #endif /* __APPLE_PRIVPTY__ */
+#endif
 }
 
 /* Makes the tty the process's controlling tty and sets it to sane modes. */
@@ -98,6 +110,7 @@ pty_release(const char *tty)
 void
 pty_make_controlling_tty(int *ttyfd, const char *tty)
 {
+#ifndef NX_WIN32_FIXME
 	int fd;
 #ifdef USE_VHANGUP
 	void *old;
@@ -181,6 +194,7 @@ pty_make_controlling_tty(int *ttyfd, const char *tty)
 	else
 		close(fd);
 #endif /* _UNICOS */
+#endif
 }
 
 /* Changes the window size associated with the pty. */
@@ -189,6 +203,7 @@ void
 pty_change_window_size(int ptyfd, u_int row, u_int col,
 	u_int xpixel, u_int ypixel)
 {
+#ifndef NX_WIN32_FIXME
 	struct winsize w;
 
 	/* may truncate u_int -> u_short */
@@ -197,11 +212,13 @@ pty_change_window_size(int ptyfd, u_int row, u_int col,
 	w.ws_xpixel = xpixel;
 	w.ws_ypixel = ypixel;
 	(void) ioctl(ptyfd, TIOCSWINSZ, &w);
+#endif
 }
 
 void
 pty_setowner(struct passwd *pw, const char *tty)
 {
+#ifndef NX_WIN32_FIXME
 	struct group *grp;
 	gid_t gid;
 	mode_t mode;
@@ -255,4 +272,5 @@ pty_setowner(struct passwd *pw, const char *tty)
 				    tty, (u_int)mode, strerror(errno));
 		}
 	}
+#endif
 }
diff --git a/sshtty.c b/sshtty.c
index d214ce3..40cc021 100644
--- a/sshtty.c
+++ b/sshtty.c
@@ -50,12 +50,21 @@ static int _in_raw_mode = 0;
 struct termios *
 get_saved_tio(void)
 {
+  #ifdef NX_WIN32_FIXME
+  DebugBreak();
+  #endif
+  
 	return _in_raw_mode ? &_saved_tio : NULL;
 }
 
 void
 leave_raw_mode(int quiet)
 {
+  /*
+   * Win32 has no ttys so there is no raw mode to leave 
+   */
+   
+#ifndef NX_WIN32_FIXME
 	if (!_in_raw_mode)
 		return;
 	if (tcsetattr(fileno(stdin), TCSADRAIN, &_saved_tio) == -1) {
@@ -63,11 +72,17 @@ leave_raw_mode(int quiet)
 			perror("tcsetattr");
 	} else
 		_in_raw_mode = 0;
+#endif
 }
 
 void
 enter_raw_mode(int quiet)
 {
+  /*
+   * Win32 has no ttys so there is no raw mode to enter 
+   */
+   
+#ifndef NX_WIN32_FIXME
 	struct termios tio;
 
 	if (tcgetattr(fileno(stdin), &tio) == -1) {
@@ -93,4 +108,5 @@ enter_raw_mode(int quiet)
 			perror("tcsetattr");
 	} else
 		_in_raw_mode = 1;
+#endif
 }
diff --git a/ttymodes.c b/ttymodes.c
index 6f51b8a..c16548c 100644
--- a/ttymodes.c
+++ b/ttymodes.c
@@ -67,6 +67,7 @@
 #define TTY_OP_ISPEED_PROTO2	128
 #define TTY_OP_OSPEED_PROTO2	129
 
+#ifndef NX_WIN32_FIXME
 /*
  * Converts POSIX speed_t to a baud rate.  The values of the
  * constants for speed_t are not themselves portable.
@@ -271,6 +272,7 @@ special_char_decode(u_int c)
 #endif /* _POSIX_VDISABLE */
 	return c;
 }
+#endif /* !NX_WIN32_FIXME */
 
 /*
  * Encodes terminal modes for the terminal referenced by fd
@@ -280,7 +282,9 @@ special_char_decode(u_int c)
 void
 tty_make_modes(int fd, struct termios *tiop)
 {
+#ifndef NX_WIN32_FIXME
 	struct termios tio;
+#endif
 	int baud;
 	Buffer buf;
 	int tty_op_ospeed, tty_op_ispeed;
@@ -297,6 +301,7 @@ tty_make_modes(int fd, struct termios *tiop)
 		put_arg = (void (*)(Buffer *, u_int)) buffer_put_char;
 	}
 
+#ifndef NX_WIN32_FIXME
 	if (tiop == NULL) {
 		if (fd == -1) {
 			debug("tty_make_modes: no fd or tio");
@@ -308,12 +313,22 @@ tty_make_modes(int fd, struct termios *tiop)
 		}
 	} else
 		tio = *tiop;
+#endif
 
 	/* Store input and output baud rates. */
+#ifndef NX_WIN32_FIXME
 	baud = speed_to_baud(cfgetospeed(&tio));
+#else
+	baud = 9600;
+#endif
+
 	buffer_put_char(&buf, tty_op_ospeed);
 	buffer_put_int(&buf, baud);
+#ifndef NX_WIN32_FIXME
 	baud = speed_to_baud(cfgetispeed(&tio));
+#else
+	baud = 9600;
+#endif
 	buffer_put_char(&buf, tty_op_ispeed);
 	buffer_put_int(&buf, baud);
 
@@ -326,7 +341,9 @@ tty_make_modes(int fd, struct termios *tiop)
 	buffer_put_char(&buf, OP); \
 	put_arg(&buf, ((tio.FIELD & NAME) != 0));
 
+#ifndef NX_WIN32_FIXME
 #include "ttymodes.h"
+#endif
 
 #undef TTYCHAR
 #undef TTYMODE
@@ -348,6 +365,7 @@ end:
 void
 tty_parse_modes(int fd, int *n_bytes_ptr)
 {
+#ifndef NX_WIN32_FIXME
 	struct termios tio;
 	int opcode, baud;
 	int n_bytes = 0;
@@ -487,4 +505,5 @@ set:
 	/* Set the new modes for the terminal. */
 	if (tcsetattr(fd, TCSANOW, &tio) == -1)
 		logit("Setting tty modes failed: %.100s", strerror(errno));
+#endif
 }
diff --git a/uidswap.c b/uidswap.c
index 8376483..907b4af 100644
--- a/uidswap.c
+++ b/uidswap.c
@@ -58,6 +58,7 @@ static int	saved_egroupslen = -1, user_groupslen = -1;
 void
 temporarily_use_uid(struct passwd *pw)
 {
+#ifndef NX_WIN32_FIXME
 	/* Save the current euid, and egroups. */
 #ifdef SAVED_IDS_WORK_WITH_SETEUID
 	saved_euid = geteuid();
@@ -130,6 +131,7 @@ temporarily_use_uid(struct passwd *pw)
 	if (seteuid(pw->pw_uid) == -1)
 		fatal("seteuid %u: %.100s", (u_int)pw->pw_uid,
 		    strerror(errno));
+#endif
 }
 
 void
@@ -173,6 +175,7 @@ permanently_drop_suid(uid_t uid)
 void
 restore_uid(void)
 {
+#ifndef NX_WIN32_FIXME
 	/* it's a no-op unless privileged */
 	if (!privileged) {
 		debug("restore_uid: (unprivileged)");
@@ -201,6 +204,7 @@ restore_uid(void)
 	if (setgroups(saved_egroupslen, saved_egroups) < 0)
 		fatal("setgroups: %.100s", strerror(errno));
 	temporarily_use_uid_effective = 0;
+#endif
 }
 
 /*
